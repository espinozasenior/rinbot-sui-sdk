{"version":3,"sources":["../src/index.ts","../src/managers/coin/CoinManager.ts","../src/errors/create-coin/invalid-param-errors.ts","../src/providers/common.ts","../src/managers/coin/create-coin/utils/move-bytecode-template.js","../src/managers/coin/create-coin/utils/template.ts","../src/managers/coin/create-coin/utils/validation.ts","../src/common/reg-exp.ts","../src/managers/RouteManager.ts","../src/errors/NoRoutesError.ts","../src/providers/utils/isSuiCoinType.ts","../src/managers/utils.ts","../src/providers/utils/hasPath.ts","../src/providers/utils/tryCatchWrapper.ts","../src/managers/WalletManager.ts","../src/managers/WalletManager.utils.ts","../src/managers/FeeManager.ts","../src/managers/dca/DCAManager.ts","../src/providers/utils/splitBy.ts","../src/providers/utils/getAllObjects.ts","../src/transactions/utils.ts","../src/managers/dca/config.ts","../src/managers/dca/utils.ts","../src/managers/dca/types.ts","../src/managers/refund/RefundManager.ts","../src/managers/refund/utils.ts","../src/providers/utils/getAllOwnedObjects.ts","../src/providers/utils/convertSlippage.ts","../src/providers/utils/convertToBNFormat.ts","../src/providers/utils/isValidTokenAddress.ts","../src/providers/utils/normalizeSuiCoinType.ts","../src/providers/utils/getSuiProvider.ts","../src/providers/utils/isValidTokenAmount.ts","../src/providers/utils/transactionFromSerializedTransaction.ts","../src/providers/aftermath/aftermath.ts","../src/emitters/EventEmitter.ts","../src/storages/InMemoryStorage.ts","../src/storages/types.ts","../src/storages/utils/typeguards.ts","../src/storages/utils/getCoinsCache.ts","../src/storages/utils/getPathsCache.ts","../src/storages/utils/getCoinsAndPathsCaches.ts","../src/storages/utils/storeCaches.ts","../src/providers/utils/getCoinInfoFromCache.ts","../src/providers/utils/removeDecimalPart.ts","../src/providers/aftermath/constants.ts","../src/providers/aftermath/create-pool-utils.ts","../src/providers/aftermath/utils.ts","../src/providers/cetus/cetus.ts","../src/storages/utils/getCetusPathsCache.ts","../src/storages/utils/storeCetusPathsCache.ts","../src/providers/cetus/config.ts","../src/providers/cetus/utils.ts","../src/managers/dca/adapters/cetusAdapter.ts","../src/providers/cetus/forked.ts","../src/providers/flowx/flowx.ts","../src/providers/flowx/calculateAmountOutInternal.ts","../src/providers/flowx/utils.ts","../src/storages/utils/getCoinsMetadataCache.ts","../src/managers/dca/adapterUtils/flowxUtils.ts","../src/managers/dca/adapters/flowxAdapter.ts","../src/providers/turbos/turbos.ts","../src/managers/dca/adapterUtils/turbosUtils.ts","../src/managers/dca/adapters/turbosAdapter.ts","../src/storages/utils/getPoolsCache.ts","../src/providers/turbos/utils.ts","../src/providers/interest/interest.ts","../src/providers/utils/getUserCoinObjects.ts","../src/providers/interest/type-guards.ts","../src/providers/interest/utils.ts","../src/providers/interest/config.ts","../src/storages/RedisStorage.ts","../src/launchpad/surfdog/surfdog.ts","../src/launchpad/surfdog/__generated__/meme/index.ts","../src/launchpad/surfdog/__generated__/_framework/util.ts","../src/launchpad/surfdog/__generated__/meme/meme/functions.ts","../src/launchpad/surfdog/__generated__/_framework/reified.ts","../src/launchpad/surfdog/__generated__/_dependencies/source/0x2/balance/structs.ts","../src/launchpad/surfdog/__generated__/_dependencies/source/0x2/object/structs.ts","../src/launchpad/surfdog/__generated__/meme/meme/structs.ts","../src/launchpad/surfdog/__generated__/meme/surf/structs.ts","../src/launchpad/surfdog/mainnet.config.ts","../src/launchpad/surfdog/testnet.config.ts"],"sourcesContent":["// Managers\nexport * from \"./managers/coin/CoinManager\";\nexport * from \"./managers/RouteManager\";\nexport * from \"./managers/WalletManager\";\nexport * from \"./managers/types\";\nexport * from \"./managers/utils\";\nexport * from \"./managers/dca/DCAManager\";\nexport * from \"./managers/dca/types\";\nexport * from \"./managers/dca/utils\";\nexport * from \"./managers/refund/RefundManager\";\nexport * from \"./managers/FeeManager\";\n\n// Providers (common & utils)\nexport * from \"./providers/common\";\nexport * from \"./providers/utils/convertSlippage\";\nexport * from \"./providers/utils/convertToBNFormat\";\nexport * from \"./providers/utils/isValidTokenAddress\";\nexport * from \"./providers/utils/normalizeSuiCoinType\";\nexport * from \"./providers/utils/tryCatchWrapper\";\nexport * from \"./providers/utils/getSuiProvider\";\nexport * from \"./providers/utils/isValidTokenAmount\";\nexport * from \"./providers/utils/transactionFromSerializedTransaction\";\nexport * from \"./providers/utils/isSuiCoinType\";\n\n// Aftermath\nexport * from \"./providers/aftermath/aftermath\";\nexport * from \"./providers/aftermath/types\";\nexport * from \"./providers/aftermath/create-pool-utils\";\n\n// Cetus\nexport * from \"./providers/cetus/cetus\";\nexport * from \"./providers/cetus/config\";\n\n// FlowX\nexport * from \"./providers/flowx/flowx\";\n\n// Turbos\nexport * from \"./providers/turbos/turbos\";\nexport * from \"./providers/turbos/types\";\nexport * from \"./providers/turbos/utils\";\n\n// Interest Protocol\nexport * from \"./providers/interest/interest\";\nexport * from \"./providers/interest/types\";\nexport * from \"./providers/interest/utils\";\nexport * from \"./providers/interest/type-guards\";\nexport * from \"./providers/interest/config\";\n\n// Storages\nexport * from \"./storages/RedisStorage\";\nexport * from \"./storages/InMemoryStorage\";\nexport * from \"./storages/types\";\nexport * from \"./storages/utils/typeguards\";\n\n// Misc\nexport { SUI_DECIMALS, isValidSuiAddress } from \"@mysten/sui.js/utils\";\nexport { TransactionBlock, isTransactionBlock } from \"@mysten/sui.js/transactions\";\nexport { Ed25519Keypair } from \"@mysten/sui.js/keypairs/ed25519\";\n\n// Launchpad\nexport * from \"./launchpad/surfdog/surfdog\";\nexport * from \"./launchpad/surfdog/types\";\nexport * as mainnetSurfdogConfig from \"./launchpad/surfdog/mainnet.config\";\nexport * as testnetSurfdogConfig from \"./launchpad/surfdog/testnet.config\";\n\n// Transaction\nexport * from \"./transactions/types\";\nexport * from \"./transactions/utils\";\n\n// Errors\nexport * from \"./errors/NoRoutesError\";\n","import { CoinMetadata, SuiClient } from \"@mysten/sui.js/client\";\nimport { TransactionBlock } from \"@mysten/sui.js/transactions\";\nimport { isValidSuiAddress, normalizeSuiAddress } from \"@mysten/sui.js/utils\";\nimport {\n  InvalidCoinDecimalsError,\n  InvalidCoinDescriptionError,\n  InvalidCoinImageError,\n  InvalidCoinNameError,\n  InvalidCoinSymbolError,\n  InvalidCoinTotalSupplyError,\n  InvalidSignerAddressError,\n  NameEqualsToDescriptionError,\n  SymbolEqualsToDescriptionError,\n} from \"../../errors/create-coin/invalid-param-errors\";\nimport { LONG_SUI_COIN_TYPE, SHORT_SUI_COIN_TYPE } from \"../../providers/common\";\nimport { CommonCoinData, CreateCoinTransactionParams, ICoinManager, Providers, UpdatedCoinsCache } from \"../types\";\nimport initMoveByteCodeTemplate from \"./create-coin/utils/move-bytecode-template\";\nimport { getBytecode } from \"./create-coin/utils/template\";\nimport {\n  validateCoinDecimals,\n  validateCoinDescription,\n  validateCoinImage,\n  validateCoinName,\n  validateCoinSymbol,\n  validateTotalSupply,\n} from \"./create-coin/utils/validation\";\n\n/**\n * @class CoinManagerSingleton\n * @implements {ICoinManager}\n * @description Singleton class for managing coins.\n */\nexport class CoinManagerSingleton implements ICoinManager {\n  private static _instance: CoinManagerSingleton;\n  private allCoinsCache: Map<string, CommonCoinData> = new Map();\n  private coinsByProviderNameCache: Map<string, Map<string, CommonCoinData>> = new Map();\n  private provider: SuiClient;\n  private static COIN_CREATION_BYTECODE_TEMPLATE_URL = \"https://www.suicoins.com/move_bytecode_template_bg.wasm\";\n\n  /**\n   * Constructs a new instance of the SuiProvider class with the provided SUI provider URL.\n   *\n   * @private\n   * @constructor\n   * @param {string} suiProviderUrl - The URL of the SUI provider.\n   */\n  private constructor(suiProviderUrl: string) {\n    this.provider = new SuiClient({ url: suiProviderUrl });\n  }\n\n  /**\n   * @public\n   * @method getInstance\n   * @description Gets the singleton instance of CoinManagerSingleton.\n   * @param {Providers} [providers] - The list of providers.\n   * @param {string} [suiProviderUrl] - Url of SUI provider.\n   * @return {CoinManagerSingleton} The singleton instance of CoinManagerSingleton.\n   */\n  public static getInstance(providers?: Providers, suiProviderUrl?: string): CoinManagerSingleton {\n    if (!CoinManagerSingleton._instance) {\n      if (providers === undefined) {\n        throw new Error(\"[Coin] Providers are required in arguments to create CoinManager instance.\");\n      }\n      if (suiProviderUrl === undefined) {\n        throw new Error(\"[Coin] SUI provider url is required in arguments to create CoinManager instance.\");\n      }\n\n      const instance = new CoinManagerSingleton(suiProviderUrl);\n      instance.init(providers);\n      CoinManagerSingleton._instance = instance;\n    }\n\n    return CoinManagerSingleton._instance;\n  }\n\n  /**\n   * @private\n   * @method init\n   * @description Initializes the CoinManagerSingleton instance.\n   * @param {Providers} providers - The list of providers.\n   * @return {void}\n   */\n  private init(providers: Providers) {\n    providers.forEach((provider) => {\n      provider.on(\"cachesUpdate\", this.handleCacheUpdate.bind(this));\n      provider.flushBuffer();\n    });\n  }\n\n  /**\n   * @private\n   * @method handleCacheUpdate\n   * @description Handles cache updates.\n   * @param {UpdatedCoinsCache} updateData - The update data.\n   * @return {void}\n   */\n  private handleCacheUpdate(updateData: UpdatedCoinsCache): void {\n    console.log(\"[COIN MANAGER] Update data received:\", updateData.provider);\n    const { provider, data: coins } = updateData;\n\n    const coinsByProviderMap: Map<string, CommonCoinData> = new Map();\n\n    coins.forEach((coin: CommonCoinData) => {\n      const coinType = coin.type;\n\n      // set coins to allCoinsMap\n      const coinInAllCoinsMap = this.allCoinsCache.get(coinType);\n      if (coinInAllCoinsMap) {\n        // TODO: Refactor this logic\n        if (coinType === LONG_SUI_COIN_TYPE) {\n          this.allCoinsCache.set(SHORT_SUI_COIN_TYPE, coin);\n        } else if (coinType === SHORT_SUI_COIN_TYPE) {\n          this.allCoinsCache.set(LONG_SUI_COIN_TYPE, coin);\n        }\n\n        const symbolExists = !!coinInAllCoinsMap.symbol;\n\n        if (!symbolExists) {\n          this.allCoinsCache.set(coinType, coin);\n        }\n      } else {\n        // TODO: Refactor this logic\n        if (coinType === LONG_SUI_COIN_TYPE) {\n          this.allCoinsCache.set(SHORT_SUI_COIN_TYPE, coin);\n        } else if (coinType === SHORT_SUI_COIN_TYPE) {\n          this.allCoinsCache.set(LONG_SUI_COIN_TYPE, coin);\n        }\n\n        this.allCoinsCache.set(coinType, coin);\n      }\n\n      // set coins to coinsByProviderMap\n      const coinInCoinsByProviderMap = coinsByProviderMap.get(coinType);\n      if (!coinInCoinsByProviderMap) {\n        coinsByProviderMap.set(coinType, coin);\n      }\n    });\n\n    this.coinsByProviderNameCache.set(provider, coinsByProviderMap);\n  }\n\n  /**\n   * @public\n   * @method getCoinByType\n   * @deprecated\n   * @description Gets coin data by coin type.\n   * @param {string} coinType - The coin type.\n   * @return {CommonCoinData} The coin data.\n   * @throws {Error} Throws an error if the coin is not found.\n   */\n  public getCoinByType(coinType: string): CommonCoinData {\n    const coinData = this.allCoinsCache.get(coinType);\n\n    if (coinData === undefined) {\n      throw new Error(`[CoinManager] Cannot find coin by type \"${coinType}\".`);\n    }\n\n    return coinData;\n  }\n\n  /**\n   * @public\n   * @method getCoinByType2\n   * @description Retrieves coin data by its type from the cache or asynchronously.\n   * @param {string} coinType - The type of the coin to retrieve.\n   * @return {Promise<CommonCoinData | null>} The coin data if found or fetched, otherwise null.\n   */\n  public async getCoinByType2(coinType: string): Promise<CommonCoinData | null> {\n    const coinData = this.allCoinsCache.get(coinType);\n\n    if (coinData === undefined) {\n      // TODO: Add storing into cache the `coinData` afterwards, in case we are fetched it\n      console.warn(`[getCoinByType2] No decimals for coin ${coinType}, so fetching...`);\n      const fetchedCoinMetadata: CoinMetadata | null = await this.fetchCoinMetadata(coinType);\n\n      return fetchedCoinMetadata === null\n        ? null\n        : { decimals: fetchedCoinMetadata.decimals, type: coinType, symbol: fetchedCoinMetadata.symbol };\n    }\n\n    return coinData;\n  }\n\n  /**\n   * @public\n   * @method getCoinsByProviderMap\n   * @description Gets coins by provider map.\n   * @return {Map<string, Map<string, CommonCoinData>>} Coins by provider map.\n   */\n  public getCoinsByProviderMap() {\n    return this.coinsByProviderNameCache;\n  }\n\n  /**\n   * @public\n   * @method getAllCoins\n   * @description Gets all coins.\n   * @return {Map<string, CommonCoinData>} All coins.\n   */\n  public getAllCoins() {\n    return this.allCoinsCache;\n  }\n\n  /**\n   * Fetches metadata for a specific coin asynchronously.\n   *\n   * @public\n   * @param {string} coinType - The type of the coin for which to fetch metadata.\n   * @return {Promise<CoinMetadata | null>} A promise that resolves to the metadata of the specified coin,\n   * or null if no metadata is available.\n   */\n  public async fetchCoinMetadata(coinType: string): Promise<CoinMetadata | null> {\n    try {\n      const coinMetadata = await this.provider.getCoinMetadata({ coinType });\n\n      return coinMetadata;\n    } catch (e) {\n      console.warn(\n        `[CoinManager.fetchCoinMetadata] error occured while fetching metadata for ${coinType} from RPC: `,\n        e,\n      );\n\n      return null;\n    }\n  }\n\n  /**\n   * Gets a transaction for creating a coin on SUI blockchain.\n   *\n   * @param {CreateCoinTransactionParams} params - Parameters for creating the coin.\n   * @param {string} params.name - The name of the coin.\n   * @param {string} params.symbol - The symbol of the coin.\n   * @param {string} params.decimals - The number of decimals for the coin.\n   * @param {boolean} params.fixedSupply - Indicates if the coin has a fixed supply.\n   * @param {string} params.mintAmount - The initial mint amount for the coin.\n   * @param {string} params.url - The URL associated with the coin.\n   * @param {string} params.description - The description of the coin.\n   * @param {string} params.signerAddress - The address of the signer.\n   * @param {TransactionBlock} [params.transaction] - The optional transaction block.\n   * @return {Promise<TransactionBlock>} - A promise resolving to the created transaction block.\n   * @throws {Error} If the request to create the coin or params validation fails.\n   */\n  public static async getCreateCoinTransaction(params: CreateCoinTransactionParams): Promise<TransactionBlock> {\n    try {\n      CoinManagerSingleton.validateCreateCoinParams(params);\n\n      const { name, symbol, decimals, fixedSupply, mintAmount, url, description, signerAddress, transaction } = params;\n      const tx = transaction ?? new TransactionBlock();\n\n      await initMoveByteCodeTemplate(CoinManagerSingleton.COIN_CREATION_BYTECODE_TEMPLATE_URL);\n\n      const [upgradeCap] = tx.publish({\n        modules: [\n          [\n            ...getBytecode({\n              name,\n              symbol,\n              totalSupply: mintAmount,\n              description,\n              fixedSupply,\n              decimals: +decimals,\n              imageUrl: url,\n              recipient: signerAddress,\n            }),\n          ],\n        ],\n        dependencies: [normalizeSuiAddress(\"0x1\"), normalizeSuiAddress(\"0x2\")],\n      });\n\n      tx.transferObjects([upgradeCap], tx.pure(signerAddress));\n\n      return tx;\n    } catch (error) {\n      console.error(\"[CoinManager.getCreateCoinTransaction] error: \", error);\n      throw error;\n    }\n  }\n\n  /**\n   * Validates parameters for creating the coin.\n   *\n   * @param {CreateCoinTransactionParams} params - Parameters for creating the coin.\n   * @throws {Error} If the validation fails.\n   */\n  public static validateCreateCoinParams({\n    name,\n    symbol,\n    decimals,\n    mintAmount,\n    url,\n    description,\n    signerAddress,\n  }: CreateCoinTransactionParams): void {\n    if (!validateCoinName(name)) {\n      throw new InvalidCoinNameError(`[validateCreateCoinParams] Coin name ${name} is invalid`);\n    }\n\n    if (!validateCoinSymbol(symbol)) {\n      throw new InvalidCoinSymbolError(`[validateCreateCoinParams] Coin symbol ${symbol} is invalid`);\n    }\n\n    if (!validateCoinDecimals(decimals)) {\n      throw new InvalidCoinDecimalsError(`[validateCreateCoinParams] Coin decimals ${decimals} are invalid`);\n    }\n\n    if (!validateTotalSupply(mintAmount, decimals)) {\n      throw new InvalidCoinTotalSupplyError(`[validateCreateCoinParams] Total supply ${mintAmount} is invalid`);\n    }\n\n    if (!validateCoinDescription(description)) {\n      throw new InvalidCoinDescriptionError(`[validateCreateCoinParams] Coin description ${description} is invalid`);\n    }\n\n    if (!validateCoinImage(url)) {\n      throw new InvalidCoinImageError(`[validateCreateCoinParams] Coin image ${url} is invalid`);\n    }\n\n    if (!isValidSuiAddress(signerAddress)) {\n      throw new InvalidSignerAddressError(`[validateCreateCoinParams] Signer address ${signerAddress} is invalid`);\n    }\n\n    if (name.trim() === description.trim()) {\n      throw new NameEqualsToDescriptionError(\n        `[validateCreateCoinParams] Coin name ${name} and coin description ${description} are equal`,\n      );\n    }\n\n    if (symbol.trim() === description.trim()) {\n      throw new SymbolEqualsToDescriptionError(\n        `[validateCreateCoinParams] Coin symbol ${symbol} and coin description ${description} are equal`,\n      );\n    }\n  }\n}\n","/**\n * Custom error class representing an error when a coin name provided for the coin creation is invalid.\n * @class\n * @extends Error\n */\nexport class InvalidCoinNameError extends Error {\n  /**\n   * Creates an instance of InvalidCoinNameError.\n   * @constructor\n   * @param {string} msg - The error message.\n   */\n  constructor(msg: string) {\n    super(msg);\n  }\n}\n\n/**\n * Custom error class representing an error when a coin symbol provided for the coin creation is invalid.\n * @class\n * @extends Error\n */\nexport class InvalidCoinSymbolError extends Error {\n  /**\n   * Creates an instance of InvalidCoinSymbolError.\n   * @constructor\n   * @param {string} msg - The error message.\n   */\n  constructor(msg: string) {\n    super(msg);\n  }\n}\n\n/**\n * Custom error class representing an error when a coin decimals provided for the coin creation are invalid.\n * @class\n * @extends Error\n */\nexport class InvalidCoinDecimalsError extends Error {\n  /**\n   * Creates an instance of InvalidCoinDecimalsError.\n   * @constructor\n   * @param {string} msg - The error message.\n   */\n  constructor(msg: string) {\n    super(msg);\n  }\n}\n\n/**\n * Custom error class representing an error when a coin total supply provided for the coin creation is invalid.\n * @class\n * @extends Error\n */\nexport class InvalidCoinTotalSupplyError extends Error {\n  /**\n   * Creates an instance of InvalidCoinTotalSupplyError.\n   * @constructor\n   * @param {string} msg - The error message.\n   */\n  constructor(msg: string) {\n    super(msg);\n  }\n}\n\n/**\n * Custom error class representing an error when a coin description provided for the coin creation is invalid.\n * @class\n * @extends Error\n */\nexport class InvalidCoinDescriptionError extends Error {\n  /**\n   * Creates an instance of InvalidCoinDescriptionError.\n   * @constructor\n   * @param {string} msg - The error message.\n   */\n  constructor(msg: string) {\n    super(msg);\n  }\n}\n\n/**\n * Custom error class representing an error when a coin image provided for the coin creation is invalid.\n * @class\n * @extends Error\n */\nexport class InvalidCoinImageError extends Error {\n  /**\n   * Creates an instance of InvalidCoinImageError.\n   * @constructor\n   * @param {string} msg - The error message.\n   */\n  constructor(msg: string) {\n    super(msg);\n  }\n}\n\n/**\n * Custom error class representing an error when a signer address provided for the coin creation is invalid.\n * @class\n * @extends Error\n */\nexport class InvalidSignerAddressError extends Error {\n  /**\n   * Creates an instance of InvalidSignerAddressError.\n   * @constructor\n   * @param {string} msg - The error message.\n   */\n  constructor(msg: string) {\n    super(msg);\n  }\n}\n\n/**\n * Custom error class representing an error when a coin name and a coin description provided for the coin creation\n * are equal.\n * @class\n * @extends Error\n */\nexport class NameEqualsToDescriptionError extends Error {\n  /**\n   * Creates an instance of NameEqualsToDescriptionError.\n   * @constructor\n   * @param {string} msg - The error message.\n   */\n  constructor(msg: string) {\n    super(msg);\n  }\n}\n\n/**\n * Custom error class representing an error when a coin symbol and a coin description provided for the coin creation\n * are equal.\n * @class\n * @extends Error\n */\nexport class SymbolEqualsToDescriptionError extends Error {\n  /**\n   * Creates an instance of SymbolEqualsToDescriptionError.\n   * @constructor\n   * @param {string} msg - The error message.\n   */\n  constructor(msg: string) {\n    super(msg);\n  }\n}\n","import { EventId, PaginatedEvents, SuiClient, SuiEvent } from \"@mysten/sui.js/client\";\nimport { SUI_DECIMALS } from \"@mysten/sui.js/utils\";\nimport { ExitHandlerOptions } from \"./types\";\n\nexport const SUI_DENOMINATOR = 10 ** SUI_DECIMALS;\nexport const SHORT_SUI_COIN_TYPE = \"0x2::sui::SUI\";\nexport const LONG_SUI_COIN_TYPE = \"0x0000000000000000000000000000000000000000000000000000000000000002::sui::SUI\";\nexport const SWAP_GAS_BUDGET = 50_000_000;\nexport const MAX_BATCH_OBJECTS_PER_GET_OBJECT_REQUEST = 50;\nexport const MAX_BATCH_EVENTS_PER_QUERY_EVENTS_REQUEST = 50;\nexport const TOKEN_ADDRESS_BASE_REGEX = /0x[0-9a-fA-F]+::[0-9a-zA-z_-]+::[0-9a-zA-z_-]+/;\n\nexport const exitHandler = (options: ExitHandlerOptions) => {\n  if (options.cleanup) {\n    console.log(`[EXIT HANDLER] ${options.providerName} cache cleanup.`);\n    clearInterval(options.intervalId);\n\n    // TODO: Add event listeners removal for window\n    // When the application restarts multiple times, event listeners remain active after each restart,\n    // accumulating for the same events, leading to overflow and eventual application crash. To prevent this,\n    // all event listeners for the process are cleared before each application exit.\n    if (typeof process !== \"undefined\" && typeof process === \"object\") {\n      process.removeAllListeners();\n    }\n  }\n  if (options.exit) process.exit();\n};\n\nexport const exitHandlerWrapper = (options: ExitHandlerOptions) => {\n  if (typeof window !== \"undefined\" && typeof window === \"object\") {\n    window.addEventListener(\"beforeunload\", exitHandler.bind(null, { cleanup: true, ...options }));\n  }\n  if (typeof process !== \"undefined\" && typeof process === \"object\") {\n    process.on(\"exit\", exitHandler.bind(null, { cleanup: true, ...options }));\n  }\n};\n\nif (typeof process !== \"undefined\" && typeof process === \"object\") {\n  process.on(\"SIGINT\", () => exitHandler({ exit: true }));\n  process.on(\"SIGUSR1\", () => exitHandler({ exit: true }));\n  process.on(\"SIGUSR2\", () => exitHandler({ exit: true }));\n  process.on(\"SIGUSR2\", () => exitHandler({ exit: true }));\n  process.on(\"uncaughtException\", (err) => {\n    console.error(\"Uncaught exception:\", err.stack);\n    exitHandler({ exit: true });\n  });\n}\n\n/**\n * Retrieves all user events associated with the specified public key.\n *\n * @param {SuiClient} provider - The SuiClient provider.\n * @param {string} publicKey - The public key for which to retrieve user events.\n * @return {Promise<SuiEvent[]>} A promise that resolves to an array of user events.\n */\nexport async function getAllUserEvents(provider: SuiClient, publicKey: string): Promise<SuiEvent[]> {\n  const pageCapacity = MAX_BATCH_EVENTS_PER_QUERY_EVENTS_REQUEST;\n  const allEvents: SuiEvent[] = [];\n  let nextCursor: EventId | undefined | null = null;\n  let events: PaginatedEvents = await provider.queryEvents({\n    query: { Sender: publicKey },\n    limit: pageCapacity,\n    cursor: nextCursor,\n  });\n\n  // Fetching and combining part\n  while (events.hasNextPage) {\n    const userEvents: SuiEvent[] = events.data;\n    allEvents.push(...userEvents);\n\n    nextCursor = events.nextCursor;\n    events = await provider.queryEvents({\n      query: { Sender: publicKey },\n      limit: pageCapacity,\n      cursor: nextCursor,\n    });\n  }\n\n  const userEvents: SuiEvent[] = events.data;\n  allEvents.push(...userEvents);\n\n  return allEvents;\n}\n","// This file is totally copied from https://github.com/interest-protocol/sui-coins.\n\nlet wasm;\n\nconst heap = new Array(128).fill(undefined);\n\nheap.push(undefined, null, true, false);\n\nfunction getObject(idx) {\n  return heap[idx];\n}\n\nlet heap_next = heap.length;\n\nfunction dropObject(idx) {\n  if (idx < 132) return;\n  heap[idx] = heap_next;\n  heap_next = idx;\n}\n\nfunction takeObject(idx) {\n  const ret = getObject(idx);\n  dropObject(idx);\n  return ret;\n}\n\nlet WASM_VECTOR_LEN = 0;\n\nlet cachedUint8Memory0 = null;\n\nfunction getUint8Memory0() {\n  if (cachedUint8Memory0 === null || cachedUint8Memory0.byteLength === 0) {\n    cachedUint8Memory0 = new Uint8Array(wasm.memory.buffer);\n  }\n  return cachedUint8Memory0;\n}\n\nconst cachedTextEncoder =\n  typeof TextEncoder !== \"undefined\"\n    ? new TextEncoder(\"utf-8\")\n    : {\n        encode: () => {\n          throw Error(\"TextEncoder not available\");\n        },\n      };\n\nconst encodeString =\n  typeof cachedTextEncoder.encodeInto === \"function\"\n    ? function (arg, view) {\n        return cachedTextEncoder.encodeInto(arg, view);\n      }\n    : function (arg, view) {\n        const buf = cachedTextEncoder.encode(arg);\n        view.set(buf);\n        return {\n          read: arg.length,\n          written: buf.length,\n        };\n      };\n\nfunction passStringToWasm0(arg, malloc, realloc) {\n  if (realloc === undefined) {\n    const buf = cachedTextEncoder.encode(arg);\n    const ptr = malloc(buf.length, 1) >>> 0;\n    getUint8Memory0()\n      .subarray(ptr, ptr + buf.length)\n      .set(buf);\n    WASM_VECTOR_LEN = buf.length;\n    return ptr;\n  }\n\n  let len = arg.length;\n  let ptr = malloc(len, 1) >>> 0;\n\n  const mem = getUint8Memory0();\n\n  let offset = 0;\n\n  for (; offset < len; offset++) {\n    const code = arg.charCodeAt(offset);\n    if (code > 0x7f) break;\n    mem[ptr + offset] = code;\n  }\n\n  if (offset !== len) {\n    if (offset !== 0) {\n      arg = arg.slice(offset);\n    }\n    ptr = realloc(ptr, len, (len = offset + arg.length * 3), 1) >>> 0;\n    const view = getUint8Memory0().subarray(ptr + offset, ptr + len);\n    const ret = encodeString(arg, view);\n\n    offset += ret.written;\n  }\n\n  WASM_VECTOR_LEN = offset;\n  return ptr;\n}\n\nfunction isLikeNone(x) {\n  return x === undefined || x === null;\n}\n\nlet cachedInt32Memory0 = null;\n\nfunction getInt32Memory0() {\n  if (cachedInt32Memory0 === null || cachedInt32Memory0.byteLength === 0) {\n    cachedInt32Memory0 = new Int32Array(wasm.memory.buffer);\n  }\n  return cachedInt32Memory0;\n}\n\nfunction addHeapObject(obj) {\n  if (heap_next === heap.length) heap.push(heap.length + 1);\n  const idx = heap_next;\n  heap_next = heap[idx];\n\n  heap[idx] = obj;\n  return idx;\n}\n\nconst cachedTextDecoder =\n  typeof TextDecoder !== \"undefined\"\n    ? new TextDecoder(\"utf-8\", { ignoreBOM: true, fatal: true })\n    : {\n        decode: () => {\n          throw Error(\"TextDecoder not available\");\n        },\n      };\n\nif (typeof TextDecoder !== \"undefined\") {\n  cachedTextDecoder.decode();\n}\n\nfunction getStringFromWasm0(ptr, len) {\n  ptr = ptr >>> 0;\n  return cachedTextDecoder.decode(getUint8Memory0().subarray(ptr, ptr + len));\n}\n\nlet cachedFloat64Memory0 = null;\n\nfunction getFloat64Memory0() {\n  if (cachedFloat64Memory0 === null || cachedFloat64Memory0.byteLength === 0) {\n    cachedFloat64Memory0 = new Float64Array(wasm.memory.buffer);\n  }\n  return cachedFloat64Memory0;\n}\n\nlet cachedBigInt64Memory0 = null;\n\nfunction getBigInt64Memory0() {\n  if (cachedBigInt64Memory0 === null || cachedBigInt64Memory0.byteLength === 0) {\n    cachedBigInt64Memory0 = new BigInt64Array(wasm.memory.buffer);\n  }\n  return cachedBigInt64Memory0;\n}\n\nfunction debugString(val) {\n  // primitive types\n  const type = typeof val;\n  if (type == \"number\" || type == \"boolean\" || val == null) {\n    return `${val}`;\n  }\n  if (type == \"string\") {\n    return `\"${val}\"`;\n  }\n  if (type == \"symbol\") {\n    const description = val.description;\n    if (description == null) {\n      return \"Symbol\";\n    } else {\n      return `Symbol(${description})`;\n    }\n  }\n  if (type == \"function\") {\n    const name = val.name;\n    if (typeof name == \"string\" && name.length > 0) {\n      return `Function(${name})`;\n    } else {\n      return \"Function\";\n    }\n  }\n  // objects\n  if (Array.isArray(val)) {\n    const length = val.length;\n    let debug = \"[\";\n    if (length > 0) {\n      debug += debugString(val[0]);\n    }\n    for (let i = 1; i < length; i++) {\n      debug += \", \" + debugString(val[i]);\n    }\n    debug += \"]\";\n    return debug;\n  }\n  // Test for built-in\n  const builtInMatches = /\\[object ([^\\]]+)\\]/.exec(toString.call(val));\n  let className;\n  if (builtInMatches.length > 1) {\n    className = builtInMatches[1];\n  } else {\n    // Failed to match the standard '[object ClassName]'\n    return toString.call(val);\n  }\n  if (className == \"Object\") {\n    // we're a user defined class or Object\n    // JSON.stringify avoids problems with cycles, and is generally much\n    // easier than looping through ownProperties of `val`.\n    try {\n      return \"Object(\" + JSON.stringify(val) + \")\";\n    } catch (_) {\n      return \"Object\";\n    }\n  }\n  // errors\n  if (val instanceof Error) {\n    return `${val.name}: ${val.message}\\n${val.stack}`;\n  }\n  // TODO we could test for more things here, like `Set`s and `Map`s.\n  return className;\n}\n/**\n * Get the version of the crate (useful for testing the package).\n * @returns {string}\n */\nexport function version() {\n  let deferred1_0;\n  let deferred1_1;\n  try {\n    const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n    wasm.version(retptr);\n    var r0 = getInt32Memory0()[retptr / 4 + 0];\n    var r1 = getInt32Memory0()[retptr / 4 + 1];\n    deferred1_0 = r0;\n    deferred1_1 = r1;\n    return getStringFromWasm0(r0, r1);\n  } finally {\n    wasm.__wbindgen_add_to_stack_pointer(16);\n    wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);\n  }\n}\n\nfunction passArray8ToWasm0(arg, malloc) {\n  const ptr = malloc(arg.length * 1, 1) >>> 0;\n  getUint8Memory0().set(arg, ptr / 1);\n  WASM_VECTOR_LEN = arg.length;\n  return ptr;\n}\n/**\n * Deserialize the `Uint8Array`` bytecode into a JSON object.\n *\n * ```javascript\n * import * as template from '@mysten/move-binary-template';\n *\n * const json = template.deserialize( binary );\n * console.log( json, json.identifiers );\n * ```\n * @param {Uint8Array} binary\n * @returns {any}\n */\nexport function deserialize(binary) {\n  try {\n    const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n    const ptr0 = passArray8ToWasm0(binary, wasm.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN;\n    wasm.deserialize(retptr, ptr0, len0);\n    var r0 = getInt32Memory0()[retptr / 4 + 0];\n    var r1 = getInt32Memory0()[retptr / 4 + 1];\n    var r2 = getInt32Memory0()[retptr / 4 + 2];\n    if (r2) {\n      throw takeObject(r1);\n    }\n    return takeObject(r0);\n  } finally {\n    wasm.__wbindgen_add_to_stack_pointer(16);\n  }\n}\n\nfunction getArrayU8FromWasm0(ptr, len) {\n  ptr = ptr >>> 0;\n  return getUint8Memory0().subarray(ptr / 1, ptr / 1 + len);\n}\n/**\n * Update the identifiers in the module bytecode, given a map of old -> new identifiers.\n * Returns the updated bytecode.\n *\n * ```javascript\n * import * as template from '@mysten/move-binary-template';\n *\n * const updated = template.update_identifiers( binary, {\n *     'TEMPLATE': 'NEW_VALUE',\n *     'template': 'new_value',\n *     'Name':     'NewName'\n * });\n * ```\n * @param {Uint8Array} binary\n * @param {any} map\n * @returns {Uint8Array}\n */\nexport function update_identifiers(binary, map) {\n  try {\n    const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n    const ptr0 = passArray8ToWasm0(binary, wasm.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN;\n    wasm.update_identifiers(retptr, ptr0, len0, addHeapObject(map));\n    var r0 = getInt32Memory0()[retptr / 4 + 0];\n    var r1 = getInt32Memory0()[retptr / 4 + 1];\n    var r2 = getInt32Memory0()[retptr / 4 + 2];\n    var r3 = getInt32Memory0()[retptr / 4 + 3];\n    if (r3) {\n      throw takeObject(r2);\n    }\n    var v2 = getArrayU8FromWasm0(r0, r1).slice();\n    wasm.__wbindgen_free(r0, r1 * 1);\n    return v2;\n  } finally {\n    wasm.__wbindgen_add_to_stack_pointer(16);\n  }\n}\n\n/**\n * Updates a constant in the constant pool. Because constants don't have names,\n * the only way to identify them is by their type and value.\n *\n * The value of a constant is BCS-encoded and the type is a string representation\n * of the `SignatureToken` enum. String identifier for `SignatureToken` is a\n * capitalized version of the type: U8, Address, Vector(Bool), Vector(U8), etc.\n *\n * ```javascript\n * import * as template from '@mysten/move-binary-template';\n * import { bcs } from '@mysten/bcs';\n *\n * let binary = template.update_constants(\n *     binary, // Uint8Array\n *     bcs.u64().serialize(0).toBytes(),      // new value\n *     bcs.u64().serialize(100000).toBytes(), // old value\n *     'U64'                                  // type\n * );\n * ```\n * @param {Uint8Array} binary\n * @param {Uint8Array} new_value\n * @param {Uint8Array} expected_value\n * @param {string} expected_type\n * @returns {Uint8Array}\n */\nexport function update_constants(binary, new_value, expected_value, expected_type) {\n  try {\n    const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n    const ptr0 = passArray8ToWasm0(binary, wasm.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN;\n    const ptr1 = passArray8ToWasm0(new_value, wasm.__wbindgen_malloc);\n    const len1 = WASM_VECTOR_LEN;\n    const ptr2 = passArray8ToWasm0(expected_value, wasm.__wbindgen_malloc);\n    const len2 = WASM_VECTOR_LEN;\n    const ptr3 = passStringToWasm0(expected_type, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n    const len3 = WASM_VECTOR_LEN;\n    wasm.update_constants(retptr, ptr0, len0, ptr1, len1, ptr2, len2, ptr3, len3);\n    var r0 = getInt32Memory0()[retptr / 4 + 0];\n    var r1 = getInt32Memory0()[retptr / 4 + 1];\n    var r2 = getInt32Memory0()[retptr / 4 + 2];\n    var r3 = getInt32Memory0()[retptr / 4 + 3];\n    if (r3) {\n      throw takeObject(r2);\n    }\n    var v5 = getArrayU8FromWasm0(r0, r1).slice();\n    wasm.__wbindgen_free(r0, r1 * 1);\n    return v5;\n  } finally {\n    wasm.__wbindgen_add_to_stack_pointer(16);\n  }\n}\n\n/**\n * Convenience method to analyze the constant pool; returns all constants in order\n * with their type and BCS value.\n *\n * ```javascript\n * import * as template from '@mysten/move-binary-template';\n *\n * let consts = template.get_constants(binary);\n * ```\n * @param {Uint8Array} binary\n * @returns {any}\n */\nexport function get_constants(binary) {\n  try {\n    const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n    const ptr0 = passArray8ToWasm0(binary, wasm.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN;\n    wasm.get_constants(retptr, ptr0, len0);\n    var r0 = getInt32Memory0()[retptr / 4 + 0];\n    var r1 = getInt32Memory0()[retptr / 4 + 1];\n    var r2 = getInt32Memory0()[retptr / 4 + 2];\n    if (r2) {\n      throw takeObject(r1);\n    }\n    return takeObject(r0);\n  } finally {\n    wasm.__wbindgen_add_to_stack_pointer(16);\n  }\n}\n\n/**\n * Serialize the JSON module into a `Uint8Array` (bytecode).\n * @param {any} json_module\n * @returns {Uint8Array}\n */\nexport function serialize(json_module) {\n  try {\n    const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n    wasm.serialize(retptr, addHeapObject(json_module));\n    var r0 = getInt32Memory0()[retptr / 4 + 0];\n    var r1 = getInt32Memory0()[retptr / 4 + 1];\n    var r2 = getInt32Memory0()[retptr / 4 + 2];\n    var r3 = getInt32Memory0()[retptr / 4 + 3];\n    if (r3) {\n      throw takeObject(r2);\n    }\n    var v1 = getArrayU8FromWasm0(r0, r1).slice();\n    wasm.__wbindgen_free(r0, r1 * 1);\n    return v1;\n  } finally {\n    wasm.__wbindgen_add_to_stack_pointer(16);\n  }\n}\n\nfunction handleError(f, args) {\n  try {\n    return f.apply(this, args);\n  } catch (e) {\n    wasm.__wbindgen_exn_store(addHeapObject(e));\n  }\n}\n/**\n * A transformed constant from the constant pool.\n */\nexport class Constant {\n  __destroy_into_raw() {\n    const ptr = this.__wbg_ptr;\n    this.__wbg_ptr = 0;\n\n    return ptr;\n  }\n\n  free() {\n    const ptr = this.__destroy_into_raw();\n    wasm.__wbg_constant_free(ptr);\n  }\n}\n\nasync function __wbg_load(module, imports) {\n  if (typeof Response === \"function\" && module instanceof Response) {\n    if (typeof WebAssembly.instantiateStreaming === \"function\") {\n      try {\n        return await WebAssembly.instantiateStreaming(module, imports);\n      } catch (e) {\n        if (module.headers.get(\"Content-Type\") != \"application/wasm\") {\n          console.warn(\n            \"`WebAssembly.instantiateStreaming` failed because your server does not serve wasm with `application/wasm` MIME type. Falling back to `WebAssembly.instantiate` which is slower. Original error:\\n\",\n            e,\n          );\n        } else {\n          throw e;\n        }\n      }\n    }\n\n    const bytes = await module.arrayBuffer();\n    return await WebAssembly.instantiate(bytes, imports);\n  } else {\n    const instance = await WebAssembly.instantiate(module, imports);\n\n    if (instance instanceof WebAssembly.Instance) {\n      return { instance, module };\n    } else {\n      return instance;\n    }\n  }\n}\n\nfunction __wbg_get_imports() {\n  const imports = {};\n  imports.wbg = {};\n  imports.wbg.__wbindgen_object_drop_ref = function (arg0) {\n    takeObject(arg0);\n  };\n  imports.wbg.__wbindgen_string_get = function (arg0, arg1) {\n    const obj = getObject(arg1);\n    const ret = typeof obj === \"string\" ? obj : undefined;\n    var ptr1 = isLikeNone(ret) ? 0 : passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n    var len1 = WASM_VECTOR_LEN;\n    getInt32Memory0()[arg0 / 4 + 1] = len1;\n    getInt32Memory0()[arg0 / 4 + 0] = ptr1;\n  };\n  imports.wbg.__wbindgen_is_bigint = function (arg0) {\n    const ret = typeof getObject(arg0) === \"bigint\";\n    return ret;\n  };\n  imports.wbg.__wbindgen_bigint_from_u64 = function (arg0) {\n    const ret = BigInt.asUintN(64, arg0);\n    return addHeapObject(ret);\n  };\n  imports.wbg.__wbindgen_jsval_eq = function (arg0, arg1) {\n    const ret = getObject(arg0) === getObject(arg1);\n    return ret;\n  };\n  imports.wbg.__wbindgen_error_new = function (arg0, arg1) {\n    const ret = new Error(getStringFromWasm0(arg0, arg1));\n    return addHeapObject(ret);\n  };\n  imports.wbg.__wbindgen_boolean_get = function (arg0) {\n    const v = getObject(arg0);\n    const ret = typeof v === \"boolean\" ? (v ? 1 : 0) : 2;\n    return ret;\n  };\n  imports.wbg.__wbindgen_is_string = function (arg0) {\n    const ret = typeof getObject(arg0) === \"string\";\n    return ret;\n  };\n  imports.wbg.__wbindgen_is_object = function (arg0) {\n    const val = getObject(arg0);\n    const ret = typeof val === \"object\" && val !== null;\n    return ret;\n  };\n  imports.wbg.__wbindgen_is_undefined = function (arg0) {\n    const ret = getObject(arg0) === undefined;\n    return ret;\n  };\n  imports.wbg.__wbindgen_in = function (arg0, arg1) {\n    const ret = getObject(arg0) in getObject(arg1);\n    return ret;\n  };\n  imports.wbg.__wbindgen_shr = function (arg0, arg1) {\n    const ret = getObject(arg0) >> getObject(arg1);\n    return addHeapObject(ret);\n  };\n  imports.wbg.__wbindgen_object_clone_ref = function (arg0) {\n    const ret = getObject(arg0);\n    return addHeapObject(ret);\n  };\n  imports.wbg.__wbindgen_jsval_loose_eq = function (arg0, arg1) {\n    const ret = getObject(arg0) == getObject(arg1);\n    return ret;\n  };\n  imports.wbg.__wbindgen_number_get = function (arg0, arg1) {\n    const obj = getObject(arg1);\n    const ret = typeof obj === \"number\" ? obj : undefined;\n    getFloat64Memory0()[arg0 / 8 + 1] = isLikeNone(ret) ? 0 : ret;\n    getInt32Memory0()[arg0 / 4 + 0] = !isLikeNone(ret);\n  };\n  imports.wbg.__wbg_String_88810dfeb4021902 = function (arg0, arg1) {\n    const ret = String(getObject(arg1));\n    const ptr1 = passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n    const len1 = WASM_VECTOR_LEN;\n    getInt32Memory0()[arg0 / 4 + 1] = len1;\n    getInt32Memory0()[arg0 / 4 + 0] = ptr1;\n  };\n  imports.wbg.__wbindgen_number_new = function (arg0) {\n    const ret = arg0;\n    return addHeapObject(ret);\n  };\n  imports.wbg.__wbindgen_bigint_from_u128 = function (arg0, arg1) {\n    const ret = (BigInt.asUintN(64, arg0) << BigInt(64)) | BigInt.asUintN(64, arg1);\n    return addHeapObject(ret);\n  };\n  imports.wbg.__wbindgen_string_new = function (arg0, arg1) {\n    const ret = getStringFromWasm0(arg0, arg1);\n    return addHeapObject(ret);\n  };\n  imports.wbg.__wbg_getwithrefkey_5e6d9547403deab8 = function (arg0, arg1) {\n    const ret = getObject(arg0)[getObject(arg1)];\n    return addHeapObject(ret);\n  };\n  imports.wbg.__wbg_set_841ac57cff3d672b = function (arg0, arg1, arg2) {\n    getObject(arg0)[takeObject(arg1)] = takeObject(arg2);\n  };\n  imports.wbg.__wbindgen_is_function = function (arg0) {\n    const ret = typeof getObject(arg0) === \"function\";\n    return ret;\n  };\n  imports.wbg.__wbg_get_44be0491f933a435 = function (arg0, arg1) {\n    const ret = getObject(arg0)[arg1 >>> 0];\n    return addHeapObject(ret);\n  };\n  imports.wbg.__wbg_length_fff51ee6522a1a18 = function (arg0) {\n    const ret = getObject(arg0).length;\n    return ret;\n  };\n  imports.wbg.__wbg_new_898a68150f225f2e = function () {\n    const ret = new Array();\n    return addHeapObject(ret);\n  };\n  imports.wbg.__wbg_next_526fc47e980da008 = function (arg0) {\n    const ret = getObject(arg0).next;\n    return addHeapObject(ret);\n  };\n  imports.wbg.__wbg_next_ddb3312ca1c4e32a = function () {\n    return handleError(function (arg0) {\n      const ret = getObject(arg0).next();\n      return addHeapObject(ret);\n    }, arguments);\n  };\n  imports.wbg.__wbg_done_5c1f01fb660d73b5 = function (arg0) {\n    const ret = getObject(arg0).done;\n    return ret;\n  };\n  imports.wbg.__wbg_value_1695675138684bd5 = function (arg0) {\n    const ret = getObject(arg0).value;\n    return addHeapObject(ret);\n  };\n  imports.wbg.__wbg_iterator_97f0c81209c6c35a = function () {\n    const ret = Symbol.iterator;\n    return addHeapObject(ret);\n  };\n  imports.wbg.__wbg_get_97b561fb56f034b5 = function () {\n    return handleError(function (arg0, arg1) {\n      const ret = Reflect.get(getObject(arg0), getObject(arg1));\n      return addHeapObject(ret);\n    }, arguments);\n  };\n  imports.wbg.__wbg_call_cb65541d95d71282 = function () {\n    return handleError(function (arg0, arg1) {\n      const ret = getObject(arg0).call(getObject(arg1));\n      return addHeapObject(ret);\n    }, arguments);\n  };\n  imports.wbg.__wbg_new_b51585de1b234aff = function () {\n    const ret = new Object();\n    return addHeapObject(ret);\n  };\n  imports.wbg.__wbg_set_502d29070ea18557 = function (arg0, arg1, arg2) {\n    getObject(arg0)[arg1 >>> 0] = takeObject(arg2);\n  };\n  imports.wbg.__wbg_isArray_4c24b343cb13cfb1 = function (arg0) {\n    const ret = Array.isArray(getObject(arg0));\n    return ret;\n  };\n  imports.wbg.__wbg_instanceof_ArrayBuffer_39ac22089b74fddb = function (arg0) {\n    let result;\n    try {\n      result = getObject(arg0) instanceof ArrayBuffer;\n    } catch {\n      result = false;\n    }\n    const ret = result;\n    return ret;\n  };\n  imports.wbg.__wbg_isSafeInteger_bb8e18dd21c97288 = function (arg0) {\n    const ret = Number.isSafeInteger(getObject(arg0));\n    return ret;\n  };\n  imports.wbg.__wbg_entries_e51f29c7bba0c054 = function (arg0) {\n    const ret = Object.entries(getObject(arg0));\n    return addHeapObject(ret);\n  };\n  imports.wbg.__wbg_buffer_085ec1f694018c4f = function (arg0) {\n    const ret = getObject(arg0).buffer;\n    return addHeapObject(ret);\n  };\n  imports.wbg.__wbg_new_8125e318e6245eed = function (arg0) {\n    const ret = new Uint8Array(getObject(arg0));\n    return addHeapObject(ret);\n  };\n  imports.wbg.__wbg_set_5cf90238115182c3 = function (arg0, arg1, arg2) {\n    getObject(arg0).set(getObject(arg1), arg2 >>> 0);\n  };\n  imports.wbg.__wbg_length_72e2208bbc0efc61 = function (arg0) {\n    const ret = getObject(arg0).length;\n    return ret;\n  };\n  imports.wbg.__wbg_instanceof_Uint8Array_d8d9cb2b8e8ac1d4 = function (arg0) {\n    let result;\n    try {\n      result = getObject(arg0) instanceof Uint8Array;\n    } catch {\n      result = false;\n    }\n    const ret = result;\n    return ret;\n  };\n  imports.wbg.__wbindgen_bigint_get_as_i64 = function (arg0, arg1) {\n    const v = getObject(arg1);\n    const ret = typeof v === \"bigint\" ? v : undefined;\n    getBigInt64Memory0()[arg0 / 8 + 1] = isLikeNone(ret) ? BigInt(0) : ret;\n    getInt32Memory0()[arg0 / 4 + 0] = !isLikeNone(ret);\n  };\n  imports.wbg.__wbindgen_debug_string = function (arg0, arg1) {\n    const ret = debugString(getObject(arg1));\n    const ptr1 = passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n    const len1 = WASM_VECTOR_LEN;\n    getInt32Memory0()[arg0 / 4 + 1] = len1;\n    getInt32Memory0()[arg0 / 4 + 0] = ptr1;\n  };\n  imports.wbg.__wbindgen_throw = function (arg0, arg1) {\n    throw new Error(getStringFromWasm0(arg0, arg1));\n  };\n  imports.wbg.__wbindgen_memory = function () {\n    const ret = wasm.memory;\n    return addHeapObject(ret);\n  };\n\n  return imports;\n}\n\nfunction __wbg_init_memory(imports, maybe_memory) {}\n\nfunction __wbg_finalize_init(instance, module) {\n  wasm = instance.exports;\n  __wbg_init.__wbindgen_wasm_module = module;\n  cachedBigInt64Memory0 = null;\n  cachedFloat64Memory0 = null;\n  cachedInt32Memory0 = null;\n  cachedUint8Memory0 = null;\n\n  return wasm;\n}\n\nfunction initSync(module) {\n  if (wasm !== undefined) return wasm;\n\n  const imports = __wbg_get_imports();\n\n  __wbg_init_memory(imports);\n\n  if (!(module instanceof WebAssembly.Module)) {\n    module = new WebAssembly.Module(module);\n  }\n\n  const instance = new WebAssembly.Instance(module, imports);\n\n  return __wbg_finalize_init(instance, module);\n}\n\nasync function __wbg_init(input) {\n  if (wasm !== undefined) return wasm;\n\n  const imports = __wbg_get_imports();\n\n  if (\n    typeof input === \"string\" ||\n    (typeof Request === \"function\" && input instanceof Request) ||\n    (typeof URL === \"function\" && input instanceof URL)\n  ) {\n    input = fetch(input);\n  }\n\n  __wbg_init_memory(imports);\n\n  const { instance, module } = await __wbg_load(await input, imports);\n\n  return __wbg_finalize_init(instance, module);\n}\n\nexport { initSync };\nexport default __wbg_init;\n","// This file is totally copied from https://github.com/interest-protocol/sui-coins.\n\nimport { bcs } from \"@mysten/sui.js-0.51.2/bcs\";\nimport { fromHEX, normalizeSuiAddress, toHEX } from \"@mysten/sui.js-0.51.2/utils\";\nimport BigNumber from \"bignumber.js\";\n\nimport { ICreateTokenForm } from \"./create-token.types\";\n\nimport * as template from \"./move-bytecode-template\";\n\nconst getCoinTemplateByteCode = () =>\n  \"a11ceb0b060000000a01000c020c1e032a2d04570a05616307c401e70108ab0360068b04570ae204050ce704360007010d02060212021302140000020001020701000002010c01000102030c0100010404020005050700000a000100011105060100020808090102020b0c010100030e0501010c030f0e01010c04100a0b00050c030400010402070307050d040f02080007080400020b020108000b03010800010a02010805010900010b01010900010800070900020a020a020a020b01010805070804020b030109000b0201090001060804010504070b030109000305070804010b0301080002090005010b020108000d434f494e5f54454d504c4154450c436f696e4d65746164617461064f7074696f6e0b5472656173757279436170095478436f6e746578740355726c04636f696e0d636f696e5f74656d706c6174650f6372656174655f63757272656e63790b64756d6d795f6669656c6404696e6974116d696e745f616e645f7472616e73666572156e65775f756e736166655f66726f6d5f6279746573066f7074696f6e137075626c69635f73686172655f6f626a6563740f7075626c69635f7472616e736665720673656e64657204736f6d65087472616e736665720a74785f636f6e746578740375726c0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000020201090a02070653594d424f4c0a0205044e414d450a020c0b4445534352495054494f4e0a02040375726c030800000000000000000520000000000000000000000000000000000000000000000000000000000000000000020109010000000002190b0007000701070207030704110738000a0138010c020c030d0307050a012e11060b0138020b03070638030b0238040200\";\n\nconst getCoinTemplateSameNameAndSymbolByteCode = () =>\n  \"a11ceb0b060000000a01000c020c1e032a2d04570a05616307c401e70108ab0360068b044f0ada04050cdf04360007010d02060212021302140000020001020701000002010c01000102030c0100010404020005050700000a000100011105060100020808090102020b0c010100030e0501010c030f0e01010c04100a0b00050c030400010402070307050d040f02080007080400020b020108000b03010800010a02010805010900010b01010900010800070900020a020a020a020b01010805070804020b030109000b0201090001060804010504070b030109000305070804010b0301080002090005010b020108000d434f494e5f54454d504c4154450c436f696e4d65746164617461064f7074696f6e0b5472656173757279436170095478436f6e746578740355726c04636f696e0d636f696e5f74656d706c6174650f6372656174655f63757272656e63790b64756d6d795f6669656c6404696e6974116d696e745f616e645f7472616e73666572156e65775f756e736166655f66726f6d5f6279746573066f7074696f6e137075626c69635f73686172655f6f626a6563740f7075626c69635f7472616e736665720673656e64657204736f6d65087472616e736665720a74785f636f6e746578740375726c0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000020201090a02070653594d424f4c0a020c0b4445534352495054494f4e0a02040375726c030800000000000000000520000000000000000000000000000000000000000000000000000000000000000000020109010000000002190b0007000701070107020703110738000a0138010c020c030d0307040a012e11060b0138020b03070538030b0238040200\";\n\nconst Address = bcs.bytes(32).transform({\n  // To change the input type, you need to provide a type definition for the input\n  input: (val: string) => fromHEX(val),\n  output: (val) => toHEX(val),\n});\n\nconst updateDecimals = (modifiedByteCode: Uint8Array, decimals: number = 9) =>\n  template.update_constants(\n    modifiedByteCode,\n    bcs.u8().serialize(decimals).toBytes(),\n    bcs.u8().serialize(9).toBytes(),\n    \"U8\",\n  );\n\nconst updateSymbol = (modifiedByteCode: Uint8Array, symbol: string) =>\n  template.update_constants(\n    modifiedByteCode,\n    bcs.string().serialize(symbol.trim()).toBytes(),\n    bcs.string().serialize(\"SYMBOL\").toBytes(),\n    \"Vector(U8)\",\n  );\n\nconst updateName = (modifiedByteCode: Uint8Array, name: string) => {\n  return template.update_constants(\n    modifiedByteCode,\n    bcs.string().serialize(name.trim()).toBytes(),\n    bcs.string().serialize(\"NAME\").toBytes(),\n    \"Vector(U8)\",\n  );\n};\n\nconst updateDescription = (modifiedByteCode: Uint8Array, description: string) =>\n  template.update_constants(\n    modifiedByteCode,\n    bcs.string().serialize(description.trim()).toBytes(),\n    bcs.string().serialize(\"DESCRIPTION\").toBytes(),\n    \"Vector(U8)\",\n  );\n\nconst updateUrl = (modifiedByteCode: Uint8Array, url: string) =>\n  template.update_constants(\n    modifiedByteCode,\n    bcs.string().serialize(url).toBytes(),\n    bcs.string().serialize(\"url\").toBytes(),\n    \"Vector(U8)\",\n  );\n\nconst updateMintAmount = (modifiedByteCode: Uint8Array, supply: BigNumber) =>\n  template.update_constants(\n    modifiedByteCode,\n    bcs.u64().serialize(supply.toString()).toBytes(),\n    bcs.u64().serialize(0).toBytes(),\n    \"U64\",\n  );\n\nconst updateTreasuryCapRecipient = (modifiedByteCode: Uint8Array, recipient: string) =>\n  template.update_constants(\n    modifiedByteCode,\n    Address.serialize(recipient).toBytes(),\n    Address.serialize(normalizeSuiAddress(\"0x0\")).toBytes(),\n    \"Address\",\n  );\n\nexport const getBytecode = (info: ICreateTokenForm & { recipient: string }) => {\n  const isSameNameAndSymbol = info.symbol === info.name;\n  const templateByteCode = fromHEX(\n    isSameNameAndSymbol ? getCoinTemplateSameNameAndSymbolByteCode() : getCoinTemplateByteCode(),\n  );\n\n  const modifiedByteCode = template.update_identifiers(templateByteCode, {\n    COIN_TEMPLATE: info.symbol.toUpperCase().replaceAll(\" \", \"_\"),\n    coin_template: info.symbol.toLowerCase().replaceAll(\" \", \"_\"),\n  });\n\n  let updated = updateDecimals(modifiedByteCode, info.decimals);\n  if (isSameNameAndSymbol) {\n    updated = updateSymbol(updated, info.symbol);\n  } else {\n    updated = updateSymbol(updated, info.symbol);\n    updated = updateName(updated, info.name);\n  }\n\n  updated = updateSymbol(updated, info.symbol);\n  updated = updateName(updated, info.name);\n\n  updated = updateDescription(updated, info.description ?? \"\");\n  updated = updateUrl(updated, info.imageUrl ?? \"\");\n\n  const supply = BigNumber(info.totalSupply).times(BigNumber(10).pow(info.decimals || 9));\n\n  updated = updateMintAmount(updated, supply);\n  updated = updateTreasuryCapRecipient(updated, info.fixedSupply ? normalizeSuiAddress(\"0x0\") : info.recipient);\n\n  return updated;\n};\n","import BigNumber from \"bignumber.js\";\nimport { BASE_64_IMAGE_REGEXP, CREATE_COIN_VALIDATION_REGEXP, URL_REGEXP } from \"../../../../common/reg-exp\";\n\n/**\n * Validates the coin name to be a non-empty string.\n *\n * @param {string} coinName - The coin name to validate.\n * @return {boolean} - Returns true if the coin name is valid, otherwise false.\n */\nexport function validateCoinName(coinName: string): boolean {\n  return (\n    typeof coinName === \"string\" && coinName.trim() !== \"\" && CREATE_COIN_VALIDATION_REGEXP.COIN_NAME.test(coinName)\n  );\n}\n\n/**\n * Validates the coin symbol based on the specified pattern.\n *\n * @param {string} coinSymbol - The coin symbol to validate.\n * @return {boolean} - Returns true if the coin symbol is valid, otherwise false.\n */\nexport function validateCoinSymbol(coinSymbol: string): boolean {\n  const isCoinSymbolIsValid =\n    typeof coinSymbol === \"string\" && CREATE_COIN_VALIDATION_REGEXP.COIN_SYMBOL.test(coinSymbol);\n\n  return isCoinSymbolIsValid;\n}\n\n/**\n * Validates the coin description to be a string.\n *\n * @param {string} coinDescription - The coin description to validate.\n * @return {boolean} - Returns true if the coin description is a string, otherwise false.\n */\nexport function validateCoinDescription(coinDescription: string): boolean {\n  return typeof coinDescription === \"string\";\n}\n\n/**\n * Validates the coin decimals based on the specified pattern.\n *\n * @param {string} coinDecimals - The coin decimals to validate (as a string).\n * @return {boolean} - Returns true if the coin decimals are a valid integer, otherwise false.\n */\nexport function validateCoinDecimals(coinDecimals: string): boolean {\n  // Convert the string to an integer\n  const decimalsAsInt = parseInt(coinDecimals, 10);\n\n  // Check if the conversion is successful and perform the validations\n  return (\n    typeof decimalsAsInt === \"number\" &&\n    !isNaN(decimalsAsInt) &&\n    decimalsAsInt >= 0 &&\n    decimalsAsInt <= 11 &&\n    decimalsAsInt === Math.floor(decimalsAsInt)\n  );\n}\n\n/**\n * Calculate the maximum total supply based on decimals.\n *\n * @param {number} decimals - The number of decimals for the token.\n * @return {BigNumber} The maximum total supply.\n */\nexport function calculateMaxTotalSupply(decimals: string): BigNumber {\n  const pow = 19 - parseInt(decimals);\n  const output = new BigNumber(10).pow(pow).minus(1);\n\n  return output;\n}\n\n/**\n * Validates the total supply to be a string containing only numbers and not exceeding the specified maxTotalSupply.\n *\n * @param {string} totalSupply - The total supply to validate.\n * @param {number} decimals - The number of decimals for the token.\n * @return {boolean} - Returns true if the total supply is a string containing only numbers and\n * does not exceed or equal maxTotalSupply, otherwise false.\n */\nexport function validateTotalSupply(totalSupply: string, decimals: string): boolean {\n  if (typeof totalSupply !== \"string\" || !CREATE_COIN_VALIDATION_REGEXP.TOTAL_SUPPLY.test(totalSupply)) {\n    return false; // Return false if totalSupply is not a string containing only numbers\n  }\n\n  const totalSupplyBigNumber = new BigNumber(totalSupply);\n  const maxTotalSupply = calculateMaxTotalSupply(decimals);\n  const isTotalSupplyIsValid = totalSupplyBigNumber.isLessThanOrEqualTo(maxTotalSupply);\n\n  return isTotalSupplyIsValid;\n}\n\n/**\n * Validates a parameter intended for use as an image of a coin.\n *\n * @param {string} coinImage - The value to be validated as a coin image.\n * @return {boolean} Returns true if the coinImage is valid, otherwise false.\n *\n * @description\n * This function validates the `coinImage` parameter to ensure it meets the criteria for an acceptable coin image.\n * The validation process includes:\n * - Checking if the `coinImage` parameter is an empty string, which is allowed.\n * - Verifying if the `coinImage` parameter matches either a base64-encoded string or a valid URL format.\n */\nexport function validateCoinImage(coinImage: string): boolean {\n  return coinImage === \"\" || BASE_64_IMAGE_REGEXP.test(coinImage) || URL_REGEXP.test(coinImage);\n}\n","export const CREATE_COIN_VALIDATION_REGEXP = {\n  COIN_NAME: /^[a-zA-Z0-9\\s]+$/,\n  COIN_SYMBOL: /^[a-zA-Z0-9_]+$/,\n  TOTAL_SUPPLY: /^\\d+$/,\n};\n\nexport const BASE_64_IMAGE_REGEXP = /^data:image\\/(png|jpeg|jpg|gif);base64,([A-Za-z0-9+/]+={0,2})$/;\n\nexport const URL_REGEXP = /^(https?|ftp):\\/\\/[^\\s/$.?#].[^\\s]*$/i;\n","import { CoinStruct } from \"@mysten/sui.js/client\";\nimport { TransactionBlock } from \"@mysten/sui.js/transactions\";\nimport BigNumber from \"bignumber.js\";\nimport { NoRoutesError } from \"../errors/NoRoutesError\";\nimport { CetusSingleton } from \"../providers/cetus/cetus\";\nimport { SUI_DENOMINATOR, SWAP_GAS_BUDGET } from \"../providers/common\";\nimport { isSuiCoinType } from \"../providers/utils/isSuiCoinType\";\nimport { CoinManagerSingleton } from \"./coin/CoinManager\";\nimport { BestRouteData, IRouteManager, Provider, Providers, ProvidersToRouteDataMap } from \"./types\";\nimport { getFiltredProviders, getRouterMaps, tokenFromIsTokenTo } from \"./utils\";\nimport { TryCatchWrapperResult } from \"../providers/types\";\nimport { FeeManager } from \"./FeeManager\";\n\n/**\n * @class RouteManager\n * @implements {IRouteManager}\n * @description Manages routes for token swapping.\n */\nexport class RouteManager implements IRouteManager {\n  private static _instance: RouteManager;\n  private poolProviders: Providers;\n  private coinManager: CoinManagerSingleton;\n\n  /**\n   * @public\n   * @method getInstance\n   * @description Gets the singleton instance of RouteManager.\n   * @param {Providers} [providers] - The pool providers.\n   * @param {CoinManagerSingleton} [coinManager] - The coin manager instance.\n   * @return {RouteManager} The singleton instance of RouteManager.\n   * @throws {Error} Throws an error if providers or coinManager are not provided.\n   */\n  public static getInstance(providers?: Providers, coinManager?: CoinManagerSingleton): RouteManager {\n    if (!RouteManager._instance) {\n      if (providers === undefined) {\n        throw new Error(\"[RouteManager] Providers are required in arguments to create RouteManager instance.\");\n      }\n\n      if (coinManager === undefined) {\n        throw new Error(\"[RouteManager] CoinManager is required in arguments to create RouteManager instance.\");\n      }\n\n      const instance = new RouteManager(providers, coinManager);\n      RouteManager._instance = instance;\n    }\n\n    return RouteManager._instance;\n  }\n\n  /**\n   * @constructor\n   * @param {Providers} providers - The pool providers.\n   * @param {CoinManagerSingleton} coinManager - The coin manager instance.\n   */\n  private constructor(providers: Providers, coinManager: CoinManagerSingleton) {\n    this.poolProviders = providers;\n    this.coinManager = coinManager;\n  }\n\n  /**\n   * @public\n   * @method getBestRouteData\n   * @description Gets the best route data for token swapping.\n   * @param {Object} options - The options for getting the best route transaction.\n   * @param {string} options.tokenFrom - The token to swap from.\n   * @param {string} options.tokenTo - The token to swap to.\n   * @param {string} options.amount - The amount to swap.\n   * @param {number} options.slippagePercentage - The slippage percentage.\n   * @param {string} options.signerAddress - The address of the signer.\n   * @param {Providers} options.supportedProviders - List of supported providers\n   * which would be used in the finding best route data.\n   * @return {Promise<BestRouteData>} A promise that resolves to the best route data for token swapping.\n   * @throws {Error} Throws an error if there is no path for the specified tokens.\n   */\n  public async getBestRouteData({\n    tokenFrom,\n    tokenTo,\n    amount,\n    slippagePercentage,\n    signerAddress,\n    supportedProviders,\n    useCetusOnChainFallback = false,\n  }: {\n    tokenFrom: string;\n    tokenTo: string;\n    amount: string;\n    slippagePercentage: number;\n    signerAddress: string;\n    supportedProviders?: Providers;\n    useCetusOnChainFallback?: boolean;\n  }): Promise<BestRouteData> {\n    if (tokenFromIsTokenTo(tokenFrom, tokenTo)) {\n      throw new Error(\"[RouteManager] getBestRouteTransaction: tokenFrom is equal to tokenTo.\");\n    }\n\n    const amountAsNumber = Number(amount);\n    if (isNaN(amountAsNumber)) {\n      throw new Error(`[RouteManager] getBestRouteTransaction: amount ${amount} is invalid.`);\n    }\n\n    // Validate coins existance in provider\n    const coinsByProviderMap = this.coinManager.getCoinsByProviderMap();\n\n    const filtredProviders = getFiltredProviders({\n      tokenFrom,\n      tokenTo,\n      coinsByProviderMap,\n      poolProviders: this.poolProviders,\n      supportedProviders,\n    });\n    console.log(\n      \"filtredProviders:\",\n      filtredProviders.map((provider) => provider.providerName),\n    );\n\n    let providersByOutputAmountsResultMap: Map<bigint, string>;\n    let routesByProviderResultMap: ProvidersToRouteDataMap;\n    let outputAmounts: bigint[];\n\n    const { providersByOutputAmountsMap, routesByProviderMap } = await getRouterMaps({\n      filtredProviders,\n      tokenFrom,\n      tokenTo,\n      amount,\n      signerAddress,\n      slippagePercentage,\n    });\n\n    providersByOutputAmountsResultMap = providersByOutputAmountsMap;\n    routesByProviderResultMap = routesByProviderMap;\n    outputAmounts = Array.from(providersByOutputAmountsResultMap.keys());\n\n    const eachOutputAmountIs0: boolean = outputAmounts.every((amount) => amount === BigInt(0));\n\n    /**\n     * Tries to find Cetus route separately through graph traversal when Cetus exists in `filteredProviders`,\n     * because Cetus initially uses fetching off-chain API for finding route and route params, which works fast,\n     * but not reliable (timeouts).\n     * By default, we don't allow graph traversal search, because of it's slowness in implementation of Cetus SDK,\n     * but in case there's no other way to find the route, we use it as a fallback option.\n     * This feature initially designed to support trading on community created pools on Cetus, since in 90% of cases,\n     * Cetus off-chain API timeouts the request.\n     */\n    if (eachOutputAmountIs0) {\n      const cetus = filtredProviders.find((provider) => provider.providerName === \"Cetus\");\n\n      if (cetus === undefined || !useCetusOnChainFallback) {\n        throw new NoRoutesError(\n          `[RouteManager] There is no paths for coins \"${tokenFrom}\" and \"${tokenTo}\" (all outputAmounts = 0)`,\n        );\n      }\n\n      const cetusInstance = cetus as CetusSingleton;\n      const { cetusOutputAmount, providersByOutputAmountsMap, routesByProviderMap } =\n        await cetusInstance.getRouteDataWithGraph({\n          inputAmount: amount,\n          slippagePercentage,\n          coinTypeFrom: tokenFrom,\n          coinTypeTo: tokenTo,\n          // TODO: We might not need to specify signerAddress here, depends on internal Cetus smart-contract structure\n          publicKey: signerAddress,\n        });\n\n      providersByOutputAmountsResultMap = providersByOutputAmountsMap;\n      routesByProviderResultMap = routesByProviderMap;\n      outputAmounts = [cetusOutputAmount];\n    }\n\n    const maxOutputAmount: bigint = outputAmounts.reduce((max, currentValue) => {\n      return currentValue > max ? currentValue : max;\n    });\n    const providerWithMaxOutputAmount: string | undefined = providersByOutputAmountsResultMap.get(maxOutputAmount);\n\n    // log info >>>\n    let stringResult = \"{ \";\n    providersByOutputAmountsResultMap.forEach((value, key) => (stringResult += `${key}n => ${value}, `));\n    stringResult += \"}\";\n    console.log(\n      \"providersByOutputAmountsResultMap:\",\n      stringResult + \"; maxOutputAmount:\",\n      maxOutputAmount + \"n; providerWithMaxOutputAmount:\",\n      providerWithMaxOutputAmount,\n    );\n    // <<< log info\n\n    if (providerWithMaxOutputAmount === undefined) {\n      throw new Error(`[Route] Cannot find provider with output amount \"${maxOutputAmount}\".`);\n    }\n\n    const routeData = routesByProviderResultMap.get(providerWithMaxOutputAmount);\n\n    if (routeData === undefined) {\n      throw new Error(`[Route] Cannot find route data for provider \"${providerWithMaxOutputAmount}\".`);\n    }\n\n    const route = routeData.route;\n\n    if (route === null) {\n      throw new Error(`[Route] Cannot find route for provider \"${providerWithMaxOutputAmount}\".`);\n    }\n\n    const maxOutputProvider = routeData.provider;\n\n    return { maxOutputProvider, maxOutputAmount, route };\n  }\n\n  /**\n   * @public\n   * @method getBestRouteTransaction\n   * @description Gets the best route transaction for token swapping.\n   * @param {Object} options - The options for getting the best route transaction.\n   * @param {string} options.tokenFrom - The token to swap from.\n   * @param {string} options.tokenTo - The token to swap to.\n   * @param {string} options.amount - The amount to swap.\n   * @param {number} options.slippagePercentage - The slippage percentage.\n   * @param {string} options.signerAddress - The address of the signer.\n   * @param {object} options.fee - The fee in SUI that would be deducted from user's account\n   * @return {Promise<{ tx: TransactionBlock, outputAmount: bigint, providerName: string }>} A promise that resolves\n   * to the object with transaction block for the swap, calculated output amount and the name of the provider, making\n   * the swap.\n   * @throws {Error} Throws an error if there is no path for the specified tokens.\n   */\n  public async getBestRouteTransaction({\n    tokenFrom,\n    tokenTo,\n    amount,\n    slippagePercentage,\n    signerAddress,\n    fee,\n  }: {\n    tokenFrom: string;\n    tokenTo: string;\n    amount: string;\n    slippagePercentage: number;\n    signerAddress: string;\n    fee?: {\n      feeAmount: string;\n      feeCollectorAddress: string;\n      tokenFromCoinObjects?: CoinStruct[];\n      tokenFromDecimals?: number;\n    };\n  }): Promise<{ tx: TransactionBlock; outputAmount: bigint; providerName: string }> {\n    // Note: this works only for sui\n    const amountInCludingFees =\n      fee && isSuiCoinType(tokenFrom)\n        ? new BigNumber(amount).minus(new BigNumber(fee.feeAmount).dividedBy(SUI_DENOMINATOR)).toString()\n        : amount;\n\n    const { maxOutputProvider, route, maxOutputAmount } = await this.getBestRouteData({\n      tokenFrom,\n      tokenTo,\n      amount: amountInCludingFees,\n      slippagePercentage,\n      signerAddress,\n    });\n\n    const transaction = await maxOutputProvider.getSwapTransaction({\n      route,\n      publicKey: signerAddress,\n      slippagePercentage,\n    });\n\n    // This is the limitation because some of the providers\n    // doesn't set/calculate gas budger for their transactions properly.\n    // We can do the simulation on our side, but it will slowdown the swap\n    transaction.setGasBudget(SWAP_GAS_BUDGET);\n\n    // TODO: Remove that into the FeeManager\n    if (fee) {\n      const { feeAmount, feeCollectorAddress, tokenFromCoinObjects, tokenFromDecimals } = fee;\n\n      if (isSuiCoinType(tokenFrom)) {\n        const { tx } = await FeeManager.getFeeInSuiTransaction({\n          transaction,\n          fee: {\n            feeAmountInMIST: feeAmount,\n            feeCollectorAddress,\n          },\n        });\n        return { tx, outputAmount: maxOutputAmount, providerName: maxOutputProvider.providerName };\n        // This else is not expected to work since it's impossible to split and merge the same coin\n      } else if (!isSuiCoinType(tokenFrom) && tokenFromCoinObjects?.length && typeof tokenFromDecimals === \"number\") {\n        const { tx } = await FeeManager.getFeeInCoinTransaction({\n          transaction,\n          fee: {\n            feeAmount: feeAmount,\n            feeCollectorAddress,\n            allCoinObjectsList: tokenFromCoinObjects,\n          },\n        });\n        return { tx, outputAmount: maxOutputAmount, providerName: maxOutputProvider.providerName };\n      } else {\n        console.warn(\n          \"[getBestRouteTransaction] unexpected behaviour: params for fees object is not correctly provided\",\n        );\n\n        throw new Error(\"Unexpected params getBestRouteTransaction\");\n      }\n    }\n\n    return { tx: transaction, outputAmount: maxOutputAmount, providerName: maxOutputProvider.providerName };\n  }\n\n  /**\n   * @public\n   * @method getBestRouteTransactionForDCA\n   * @description Gets the best route transaction for token swapping for DCA.\n   * @param {Object} options - The options for getting the best route transaction.\n   * @param {string} options.tokenFrom - The token to swap from.\n   * @param {string} options.tokenTo - The token to swap to.\n   * @param {string} options.amount - The amount to swap.\n   * @param {number} options.slippagePercentage - The slippage percentage.\n   * @param {string} options.signerAddress - The address of the signer.\n   * @param {Providers} options.supportedProviders - List of supported providers\n   *\n   * @return {Promise<TransactionBlock>} A promise that resolves to the transaction block for the swap.\n   * @throws {Error} Throws an error if there is no path for the specified tokens.\n   */\n  public async getBestRouteTransactionForDCA({\n    tokenFrom,\n    tokenTo,\n    amount,\n    slippagePercentage,\n    signerAddress,\n    dcaObjectId,\n    dcaTradeGasCost,\n    supportedProviders,\n  }: {\n    tokenFrom: string;\n    tokenTo: string;\n    amount: string;\n    slippagePercentage: number;\n    signerAddress: string;\n    dcaObjectId: string;\n    dcaTradeGasCost: number;\n    supportedProviders?: Providers;\n  }): Promise<TransactionBlock> {\n    const { maxOutputProvider, route } = await this.getBestRouteData({\n      tokenFrom,\n      tokenTo,\n      amount,\n      slippagePercentage,\n      signerAddress,\n      supportedProviders,\n    });\n\n    const transaction = await maxOutputProvider.getSwapTransactionDoctored({\n      route,\n      publicKey: signerAddress,\n      slippagePercentage,\n    });\n\n    const doctoredForDCATransactionBlock = maxOutputProvider.buildDcaTxBlockAdapter(\n      transaction,\n      tokenFrom,\n      tokenTo,\n      dcaObjectId,\n      dcaTradeGasCost,\n    );\n\n    // TODO IMPORTANT: CHECK THAT ITS OK, COMMENTED FOR NOW (check that we do not need set gas budget for tx)\n\n    // This is the limitation because some of the providers\n    // doesn't set/calculate gas budger for their transactions properly.\n    // We can do the simulation on our side, but it will slowdown the swap\n    // transaction.setGasBudget(SWAP_GAS_BUDGET);\n\n    return doctoredForDCATransactionBlock;\n  }\n\n  /**\n   * @public\n   * @method getBestRouteTransactionForDCAByRouteData\n   * @description Gets the best route transaction for token swapping for DCA\n   * based on the provided `route` and `maxOutputProvider`.\n   */\n  public async getBestRouteTransactionForDCAByRouteData({\n    tokenFrom,\n    tokenTo,\n    slippagePercentage,\n    signerAddress,\n    dcaObjectId,\n    dcaTradeGasCost,\n    route,\n    maxOutputProvider,\n  }: {\n    tokenFrom: string;\n    tokenTo: string;\n    slippagePercentage: number;\n    signerAddress: string;\n    dcaObjectId: string;\n    dcaTradeGasCost: number;\n    route: TryCatchWrapperResult;\n    maxOutputProvider: Provider;\n  }): Promise<TransactionBlock> {\n    const transaction = await maxOutputProvider.getSwapTransactionDoctored({\n      route,\n      publicKey: signerAddress,\n      slippagePercentage,\n    });\n\n    const doctoredForDCATransactionBlock = maxOutputProvider.buildDcaTxBlockAdapter(\n      transaction,\n      tokenFrom,\n      tokenTo,\n      dcaObjectId,\n      dcaTradeGasCost,\n    );\n\n    // TODO: Check that we do not need to set gas budget limit for tx\n\n    return doctoredForDCATransactionBlock;\n  }\n}\n","/**\n * Custom error class representing an error when no routes are found.\n * @class\n * @extends Error\n */\nexport class NoRoutesError extends Error {\n  /**\n   * Creates an instance of NoRoutesError.\n   * @constructor\n   * @param {string} msg - The error message.\n   */\n  constructor(msg: string) {\n    super(msg);\n  }\n}\n","import { LONG_SUI_COIN_TYPE, SHORT_SUI_COIN_TYPE } from \"../common\";\n\n/**\n * Checks if a given coin type is a SUI coin type.\n *\n * @param {string} coinType - The coin type to check.\n * @return {boolean} Returns true if the coin type is a SUI coin type, otherwise false.\n */\nexport function isSuiCoinType(coinType: string) {\n  return coinType === LONG_SUI_COIN_TYPE || coinType === SHORT_SUI_COIN_TYPE;\n}\n","import { CoinStruct } from \"@mysten/sui.js/client\";\nimport { Ed25519Keypair } from \"@mysten/sui.js/keypairs/ed25519\";\nimport { normalizeSuiAddress } from \"@mysten/sui.js/utils\";\nimport {\n  CoinAssetData,\n  CommonCoinData,\n  CreateCoinExternalApiResType,\n  Provider,\n  Providers,\n  ProvidersToRouteDataMap,\n} from \"../managers/types\";\nimport { LONG_SUI_COIN_TYPE, SHORT_SUI_COIN_TYPE } from \"../providers/common\";\nimport { CommonPoolData } from \"../providers/types\";\nimport { hasPath } from \"../providers/utils/hasPath\";\nimport { tryCatchWrapper } from \"../providers/utils/tryCatchWrapper\";\nimport { CoinManagerSingleton } from \"./coin/CoinManager\";\nimport { WalletManagerSingleton } from \"./WalletManager\";\n\nexport const getFiltredProviders = ({\n  poolProviders,\n  coinsByProviderMap,\n  tokenFrom,\n  tokenTo,\n  supportedProviders,\n}: {\n  poolProviders: Providers;\n  coinsByProviderMap: Map<string, Map<string, CommonCoinData>>;\n  tokenFrom: string;\n  tokenTo: string;\n  supportedProviders?: Providers;\n}) => {\n  const tokenFromIsSui: boolean = tokenFrom === SHORT_SUI_COIN_TYPE || tokenFrom === LONG_SUI_COIN_TYPE;\n  const tokenToIsSui: boolean = tokenTo === SHORT_SUI_COIN_TYPE || tokenTo === LONG_SUI_COIN_TYPE;\n\n  const filtredProviders = poolProviders.filter((poolProvider: Provider) => {\n    const providerCoins = coinsByProviderMap.get(poolProvider.providerName);\n\n    if (!providerCoins) {\n      console.warn(`[getFiltredProviders] No coins found for such provider ${poolProvider.providerName}`);\n      return false;\n    }\n\n    // Check that provider is in supportedProviders\n    if (supportedProviders?.length) {\n      const isPoolProviderIsInSupportedProviders = supportedProviders.find((supportedProvider) =>\n        supportedProvider.providerName.includes(poolProvider.providerName),\n      );\n\n      if (!isPoolProviderIsInSupportedProviders) {\n        return false;\n      }\n    }\n\n    // Check that provider has one of the variants of SUI token\n    const providerCoinsHaveSui = providerCoins.has(SHORT_SUI_COIN_TYPE) || providerCoins.has(LONG_SUI_COIN_TYPE);\n    // Check if input tokenFrom/tokenTo is SUI\n    const tokenFromOrTokenToIsSui = tokenFromIsSui || tokenToIsSui;\n    // If SUI token is tokenTo, we return tokenFrom, and vice versa\n    const notSuiTokenInInputTokens: string = tokenFromIsSui ? tokenTo : tokenFrom;\n\n    if (tokenFromOrTokenToIsSui) {\n      // Provider tokens doesn't have SUI and doesn't have the second token in pair (tokenFrom/tokenTo)\n      const providerDoesntHaveAnyToken = !providerCoinsHaveSui || !providerCoins.has(notSuiTokenInInputTokens);\n\n      if (providerDoesntHaveAnyToken) {\n        return false;\n      }\n    } else {\n      // If no SUI token present in tokenFrom/tokenTo, just check that provider has both tokens\n      if (!providerCoins.has(tokenFrom) || !providerCoins.has(tokenTo)) {\n        return false;\n      }\n    }\n\n    // If provider doesn't support smart-routing, than we have to check that provider has direct path with both tokens\n    if (!poolProvider.isSmartRoutingAvailable) {\n      const paths: Map<string, CommonPoolData> = poolProvider.getPaths();\n\n      if (tokenFromOrTokenToIsSui) {\n        const providerHasNoPathWithShortSui = !hasPath(SHORT_SUI_COIN_TYPE, notSuiTokenInInputTokens, paths);\n        const providerHasNoPathWithLongSui = !hasPath(LONG_SUI_COIN_TYPE, notSuiTokenInInputTokens, paths);\n\n        if (providerHasNoPathWithShortSui && providerHasNoPathWithLongSui) {\n          return false;\n        }\n      } else {\n        const providerHasNoPathWithRegularCoins = !hasPath(tokenFrom, tokenTo, paths);\n\n        if (providerHasNoPathWithRegularCoins) {\n          return false;\n        }\n      }\n    }\n\n    return true;\n  });\n\n  return filtredProviders;\n};\n\nexport const getRouterMaps = async ({\n  filtredProviders,\n  tokenFrom,\n  tokenTo,\n  amount,\n  signerAddress,\n  slippagePercentage,\n}: {\n  filtredProviders: Providers;\n  tokenFrom: string;\n  tokenTo: string;\n  amount: string;\n  signerAddress: string;\n  slippagePercentage: number;\n}) => {\n  const routesByProviderMap: ProvidersToRouteDataMap = new Map();\n  const providersByOutputAmountsMap: Map<bigint, string> = new Map();\n\n  await Promise.all(\n    filtredProviders.map(async (provider: Provider) => {\n      console.time(\"provider: \" + provider.providerName);\n      const routeData = await tryCatchWrapper(provider.getRouteData.bind(provider), {\n        coinTypeFrom: tokenFrom,\n        coinTypeTo: tokenTo,\n        inputAmount: amount,\n        publicKey: signerAddress,\n        slippagePercentage,\n      });\n      const providerName: string = provider.providerName;\n\n      // In case route is not found or provider throw an error\n      if (routeData === null) {\n        routesByProviderMap.set(providerName, { provider, route: null });\n        providersByOutputAmountsMap.set(BigInt(0), providerName);\n      } else {\n        // In case route is found\n        routesByProviderMap.set(providerName, { provider, route: routeData.route });\n        providersByOutputAmountsMap.set(routeData.outputAmount, providerName);\n      }\n      console.timeEnd(\"provider: \" + provider.providerName);\n    }),\n  );\n\n  return { routesByProviderMap, providersByOutputAmountsMap };\n};\n\nexport const tokenFromIsTokenTo = (tokenFrom: string, tokenTo: string): boolean => {\n  const tokenFromIsSui: boolean = tokenFrom === SHORT_SUI_COIN_TYPE || tokenFrom === LONG_SUI_COIN_TYPE;\n  const tokenToIsSui: boolean = tokenTo === SHORT_SUI_COIN_TYPE || tokenTo === LONG_SUI_COIN_TYPE;\n  const tokensAreSui: boolean = tokenFromIsSui && tokenToIsSui;\n\n  return tokensAreSui || tokenFrom === tokenTo;\n};\n\nexport const getCoinsAssetsFromCoinObjects = async (\n  coinObjects: CoinStruct[],\n  coinManager: CoinManagerSingleton,\n): Promise<CoinAssetData[]> => {\n  return await coinObjects.reduce(async (allAssetsP: Promise<CoinAssetData[]>, coinData: CoinStruct) => {\n    const allAssets: CoinAssetData[] = await allAssetsP;\n\n    if (BigInt(coinData.balance) <= 0) {\n      return allAssets;\n    }\n\n    const rawCoinType = coinData.coinType;\n    const coinTypeAddress = rawCoinType.split(\"::\")[0];\n    const normalizedAddress = normalizeSuiAddress(coinTypeAddress);\n    const normalizedCoinType = rawCoinType.replace(coinTypeAddress, normalizedAddress);\n\n    const coinInAssets: CoinAssetData | undefined = allAssets.find(\n      (asset: CoinAssetData) => asset.type === normalizedCoinType,\n    );\n\n    if (coinInAssets) {\n      const currentBalance = BigInt(coinInAssets.balance);\n      const additionalBalance = BigInt(coinData.balance);\n      const newBalance: bigint = currentBalance + additionalBalance;\n      coinInAssets.balance = newBalance.toString();\n    } else {\n      const coin: CommonCoinData | null = await coinManager.getCoinByType2(normalizedCoinType);\n      const symbol = coin?.symbol?.trim();\n      const decimals = coin?.decimals ?? null;\n\n      if (!symbol) {\n        console.warn(`[getCoinsAssetsFromCoinObjects] no symbol found for coin ${normalizedCoinType}`);\n      }\n\n      if (!decimals) {\n        console.warn(`[getCoinsAssetsFromCoinObjects] no decimals found for coin ${normalizedCoinType}`);\n      }\n\n      allAssets.push({\n        symbol,\n        balance: coinData.balance,\n        type: normalizedCoinType,\n        decimals,\n        noDecimals: !coin,\n      });\n    }\n\n    return allAssets;\n  }, Promise.resolve([]));\n};\n\n/**\n * Validates whether the provided response object adheres to the expected structure for creating a coin.\n *\n * @param {unknown} res - The object to validate.\n * @return {CreateCoinExternalApiResType} True if the object has a valid structure for creating a coin, false otherwise.\n */\nexport function isValidResForCreateCoin(res: unknown): res is CreateCoinExternalApiResType {\n  return (\n    typeof res === \"object\" &&\n    res !== null &&\n    \"modules\" in res &&\n    \"dependencies\" in res &&\n    \"digest\" in res &&\n    Array.isArray(res.modules) &&\n    (res.modules.every((m: unknown) => typeof m === \"string\") ||\n      res.modules.every((m: unknown) => Array.isArray(m) && m.every((n: unknown) => typeof n === \"number\"))) &&\n    Array.isArray(res.dependencies) &&\n    res.dependencies.every((d: unknown) => typeof d === \"string\") &&\n    Array.isArray(res.digest) &&\n    res.digest.every((n: unknown) => typeof n === \"number\")\n  );\n}\n\n/**\n * @param {string} mnemonic Seed phrase of the wallet.\n * @return {string} Normilized mnemonic (trimmed & etc.).\n */\nexport function normalizeMnemonic(mnemonic: string): string {\n  return mnemonic\n    .trim()\n    .split(/\\s+/)\n    .map((part) => part.toLowerCase())\n    .join(\" \");\n}\n\nexport const isValidPrivateKey = (string: string): boolean => {\n  try {\n    const keypair = WalletManagerSingleton.getKeyPairFromPrivateKey(string);\n\n    return keypair instanceof Ed25519Keypair;\n  } catch (error) {\n    return false;\n  }\n};\n\nexport const isValidSeedPhrase = (string: string): boolean => {\n  try {\n    const normalized = normalizeMnemonic(string);\n    const keypair = Ed25519Keypair.deriveKeypair(normalized);\n\n    return keypair instanceof Ed25519Keypair;\n  } catch (error) {\n    return false;\n  }\n};\n","import { CommonPoolData } from \"../types\";\n\n/* eslint-disable require-jsdoc */\nexport function hasPath(coinA: string, coinB: string, pathMap: Map<string, CommonPoolData>): boolean {\n  const keyAB = `${coinA}-${coinB}`;\n  const keyBA = `${coinB}-${coinA}`;\n  return pathMap.has(keyAB) || pathMap.has(keyBA);\n}\n","export type AnyFunction = (...args: RouteParams[]) => any;\nexport type RouteParams = {\n  coinTypeFrom: string;\n  coinTypeTo: string;\n  inputAmount: string;\n  slippagePercentage: number;\n  publicKey: string;\n};\n\n/**\n * Wraps an asynchronous function in a try-catch block, logging any errors.\n *\n * @template T - The type of the wrapped function.\n * @param {T} callback - The asynchronous function to be wrapped.\n * @param {...Parameters<T>} args - The arguments to be passed to the asynchronous function.\n * @return {Promise<ReturnType<T> | null>} - A Promise that resolves to the result of the\n *   asynchronous function if successful, or null if an error occurs.\n */\nexport async function tryCatchWrapper<T extends AnyFunction>(\n  callback: T,\n  ...args: Parameters<T>\n): Promise<ReturnType<T> | null> {\n  try {\n    const result = (await callback(...args)) as ReturnType<T>;\n    return result;\n  } catch (error) {\n    // eslint-disable-next-line no-empty\n    if (error instanceof Error && error.message.includes(\"From/To coin is undefined\")) {\n      // Silently handle the specific error when \"From/To coin is undefined,\"\n      // as it may be expected in cases where CetusSingleton disables fallback\n      // due to the client passing 'useOnChainFallback' as false.\n      // This is necessary because fixing the broken fallback is not possible\n      // due to limitations in the Cetus SDK.\n    } else {\n      console.error(\"Error:\", error);\n    }\n\n    return null;\n  }\n}\n","import {\n  CoinBalance,\n  CoinStruct,\n  DevInspectResults,\n  GasCostSummary,\n  PaginatedCoins,\n  SuiClient,\n} from \"@mysten/sui.js/client\";\nimport { Ed25519Keypair } from \"@mysten/sui.js/keypairs/ed25519\";\nimport { TransactionBlock } from \"@mysten/sui.js/transactions\";\nimport { TransactionBlock as UpdatedTransactionBlock } from \"@mysten/sui.js-0.51.2/transactions\";\nimport { SUI_DECIMALS } from \"@mysten/sui.js/utils\";\nimport BigNumber from \"bignumber.js\";\nimport { SUI_DENOMINATOR, SWAP_GAS_BUDGET } from \"../providers/common\";\nimport { CoinManagerSingleton } from \"./coin/CoinManager\";\nimport { CoinAssetData, IWalletManager } from \"./types\";\nimport { getCoinsAssetsFromCoinObjects, normalizeMnemonic } from \"./utils\";\nimport { bech32 } from \"bech32\";\nimport { determineFormat } from \"./WalletManager.utils\";\nimport { TransactionResult } from \"../transactions/types\";\n\n/**\n * @class WalletManagerSingleton\n * @implements {IWalletManager}\n * @description Manages wallets and transactions related to wallets.\n */\nexport class WalletManagerSingleton implements IWalletManager {\n  private provider: SuiClient;\n  private coinManager: CoinManagerSingleton;\n  private static _instance: WalletManagerSingleton;\n\n  /**\n   * @constructor\n   * @param {SuiClient} provider - The SuiClient provider.\n   * @param {CoinManagerSingleton} coinManager - The coin manager instance.\n   */\n  private constructor(provider: SuiClient, coinManager: CoinManagerSingleton) {\n    this.provider = provider;\n    this.coinManager = coinManager;\n  }\n\n  /**\n   * @public\n   * @method getInstance\n   * @description Gets the singleton instance of WalletManager.\n   * @param {SuiClient} [provider] - The SuiClient provider.\n   * @param {CoinManagerSingleton} [coinManager] - The coin manager instance.\n   * @return {WalletManagerSingleton} The singleton instance of WalletManager.\n   * @throws {Error} Throws an error if provider or coinManager are not provided.\n   */\n  public static getInstance(provider?: SuiClient, coinManager?: CoinManagerSingleton): WalletManagerSingleton {\n    if (!WalletManagerSingleton._instance) {\n      if (provider === undefined) {\n        throw new Error(\"[Wallet] Provider is required in arguments to create WalletManager instance.\");\n      } else if (coinManager === undefined) {\n        throw new Error(\n          \"[Wallet] CoinManagerSingleton instance is required in arguments to create WalletManager instance.\",\n        );\n      }\n\n      const instance = new WalletManagerSingleton(provider, coinManager);\n      WalletManagerSingleton._instance = instance;\n    }\n\n    return WalletManagerSingleton._instance;\n  }\n  /**\n   * Generates a new Ed25519 key pair for a wallet, consisting of a public key and a private key.\n   * @return {{ publicKey: string, privateKey: string }} An object with the public, private key (in hexadecimal format).\n   */\n  public static generateWallet() {\n    const keypair = Ed25519Keypair.generate();\n    const publicKey = keypair.getPublicKey().toSuiAddress();\n    const privateKey = WalletManagerSingleton.getPrivateKeyFromKeyPair(keypair);\n\n    return { publicKey, privateKey };\n  }\n\n  /**\n   * Generates an Ed25519 key pair from a provided private key in hex or Bech32 format.\n   * @param {string} privateKey - The private key in hex or Bech32 format.\n   * @throws {Error} Throws an error if the provided privateKey is not in hex or Bech32 format.\n   * @return {Ed25519Keypair} An Ed25519 key pair.\n   */\n  public static getKeyPairFromPrivateKey(privateKey: string): Ed25519Keypair {\n    const format = determineFormat(privateKey);\n\n    switch (format) {\n      case \"hex\":\n        return WalletManagerSingleton.getKeyPairFromPrivateKeyHex(privateKey);\n      case \"bech32\":\n        return WalletManagerSingleton.getKeyPairFromPrivateKeyBech32(privateKey);\n      default:\n        throw new Error(\"[WalletManagerSingleton] Unsupported keypair format\");\n    }\n  }\n\n  /**\n   * Generates an Ed25519 key pair from a provided private key in hexadecimal format.\n   * @param {string} privateKeyHex - The private key in hexadecimal format.\n   * @return {Ed25519Keypair} An Ed25519 key pair.\n   */\n  public static getKeyPairFromPrivateKeyHex(privateKeyHex: string): Ed25519Keypair {\n    const keypair = Ed25519Keypair.fromSecretKey(Buffer.from(privateKeyHex, \"hex\"));\n\n    return keypair;\n  }\n\n  /**\n   * Generates an Ed25519 key pair from a provided private key in bech32 format.\n   * @param {string} privateKeyBech32 - The private key in bech32 format.\n   * @return {Ed25519Keypair} An Ed25519 key pair.\n   */\n  public static getKeyPairFromPrivateKeyBech32(privateKeyBech32: string): Ed25519Keypair {\n    const privateKeyConvertedFromBech32ToHex = WalletManagerSingleton.bech32ToHex(privateKeyBech32);\n    const keypair = Ed25519Keypair.fromSecretKey(Buffer.from(privateKeyConvertedFromBech32ToHex, \"hex\"));\n\n    return keypair;\n  }\n\n  /**\n   * Converts a Bech32 encoded address to its hexadecimal representation.\n   * @param {string} bech32Address - The Bech32 encoded address to convert.\n   * @return {string} The hexadecimal representation of the given Bech32 address.\n   */\n  public static bech32ToHex(bech32Address: string): string {\n    try {\n      // Decode the Bech32 address to obtain the words (data part)\n      const decoded = bech32.decode(bech32Address);\n\n      // Convert the words to a Buffer\n      const buffer = Buffer.from(bech32.fromWords(decoded.words));\n\n      // Convert to hexadecimal\n      let hex = buffer.toString(\"hex\");\n\n      // Remove the first two '00's from the prefix if present\n      if (hex.startsWith(\"00\")) {\n        hex = hex.substring(2);\n      }\n\n      // Convert the Buffer to a hex string\n      return hex;\n    } catch (error) {\n      console.error(\"Error converting Bech32 address to hex:\", error);\n      return \"\";\n    }\n  }\n\n  /**\n   * Retrieves the private key from the provided key pair.\n   *\n   * @param {Ed25519Keypair} keypair - The key pair containing the private key.\n   * @return {string} The private key in hexadecimal format.\n   */\n  public static getPrivateKeyFromKeyPair(keypair: Ed25519Keypair): string {\n    const privateKeyBase64 = keypair.export();\n    const privateKeyHex = Buffer.from(privateKeyBase64.privateKey, \"base64\").toString(\"hex\");\n\n    return privateKeyHex;\n  }\n\n  /**\n   * Generates an Ed25519 key pair from a provided mnemonic.\n   * @param {string} mnemonic - Seed phrase of the wallet.\n   * @return {Ed25519Keypair} An Ed25519 key pair.\n   */\n  public static getKeyPairFromMnemonic(mnemonic: string): Ed25519Keypair {\n    const normalized = normalizeMnemonic(mnemonic);\n    const keypair = Ed25519Keypair.deriveKeypair(normalized);\n\n    return keypair;\n  }\n\n  /**\n   * Retrieves a withdrawal transaction for SUI tokens.\n   *\n   * @return {Promise<TransactionBlock>} A Promise that resolves to a TransactionBlock.\n   */\n  public static async getWithdrawSuiTransaction({\n    address,\n    amount,\n  }: {\n    address: string;\n    amount: string;\n  }): Promise<TransactionBlock> {\n    const tx = new TransactionBlock();\n\n    const amountBigNumber = new BigNumber(amount);\n    const amountInMists: string = amountBigNumber.multipliedBy(SUI_DENOMINATOR).toString();\n    const [coin] = tx.splitCoins(tx.gas, [tx.pure(amountInMists)]);\n    tx.transferObjects([coin], tx.pure(address));\n\n    return tx;\n  }\n\n  /**\n   * @public\n   * @method getAvailableWithdrawSuiAmount\n   * @description Retrieves the available amount for withdrawing SUI tokens.\n   * @param {string} publicKey - The public key of the wallet.\n   * @return {Promise<{ availableAmount: string, totalGasFee: string }>} A promise that resolves to\n   * the available amount and total gas fee.\n   */\n  public async getAvailableWithdrawSuiAmount(\n    publicKey: string,\n  ): Promise<{ availableAmount: string; totalGasFee: string }> {\n    const tx = new TransactionBlock();\n    const AMOUNT_IN_SUI_MIST_TO_SIMULATE_WITHDRAW = 100;\n\n    const [coin] = tx.splitCoins(tx.gas, [tx.pure(AMOUNT_IN_SUI_MIST_TO_SIMULATE_WITHDRAW)]);\n    tx.transferObjects([coin], tx.pure(publicKey));\n\n    const simulationResult: DevInspectResults = await this.provider.devInspectTransactionBlock({\n      transactionBlock: tx,\n      sender: publicKey,\n    });\n    const { computationCost, storageCost, storageRebate }: GasCostSummary = simulationResult.effects.gasUsed;\n    const totalGasFee: string = new BigNumber(computationCost).plus(storageCost).minus(storageRebate).toString();\n    const suiBalance: string = await this.getSuiBalance(publicKey);\n    const availableAmount = new BigNumber(suiBalance)\n      .multipliedBy(SUI_DENOMINATOR)\n      .minus(totalGasFee)\n      .dividedBy(SUI_DENOMINATOR)\n      .toString();\n\n    return {\n      availableAmount,\n      totalGasFee,\n    };\n  }\n\n  /**\n   * @public\n   * @method getSuiBalance\n   * @description Retrieves the balance of SUI tokens for a wallet.\n   * @param {string} publicKey - The public key of the wallet.\n   * @return {Promise<string>} A promise that resolves to the balance of SUI tokens.\n   */\n  public async getSuiBalance(publicKey: string): Promise<string> {\n    const balance: CoinBalance = await this.provider.getBalance({ owner: publicKey });\n    const totalBalance = new BigNumber(balance.totalBalance);\n\n    return totalBalance.dividedBy(10 ** SUI_DECIMALS).toString();\n  }\n\n  /**\n   * @public\n   * @method getAvailableSuiBalance\n   * @description Retrieves the available balance of SUI tokens for a wallet.\n   * @param {string} publicKey - The public key of the wallet.\n   * @return {Promise<string>} A promise that resolves to the available balance of SUI tokens.\n   */\n  public async getAvailableSuiBalance(publicKey: string): Promise<string> {\n    const currentSuiBalance: string = await this.getSuiBalance(publicKey);\n    const suiBalanceWithDecimals = new BigNumber(currentSuiBalance).multipliedBy(10 ** SUI_DECIMALS);\n    const availableSuiBalance = suiBalanceWithDecimals.minus(SWAP_GAS_BUDGET);\n\n    if (availableSuiBalance.isLessThanOrEqualTo(0)) {\n      return \"0\";\n    }\n\n    return availableSuiBalance.dividedBy(10 ** SUI_DECIMALS).toString();\n  }\n\n  /**\n   * @public\n   * @method getAllCoinAssets\n   * @description Retrieves all coin assets associated with a wallet.\n   * @param {string} publicKey - The public key of the wallet.\n   * @return {Promise<CoinAssetData[]>} A promise that resolves to an array of coin asset data.\n   */\n  public async getAllCoinAssets(publicKey: string): Promise<CoinAssetData[]> {\n    // TODO: Move that to util method to avoid code duplication\n    // in `getAllCoinAssets` & `getCoinObjects`, e.g. something like getPaginatedObjects\n    const pageCapacity = 50;\n    const allObjects: CoinStruct[] = [];\n    let nextCursor: string | null | undefined = null;\n    let assets: PaginatedCoins = await this.provider.getAllCoins({\n      owner: publicKey,\n      limit: pageCapacity,\n      cursor: nextCursor,\n    });\n\n    // fetching and combining part\n    while (assets.hasNextPage) {\n      const coinObjects: CoinStruct[] = assets.data;\n      allObjects.push(...coinObjects);\n\n      nextCursor = assets.nextCursor;\n      assets = await this.provider.getAllCoins({\n        owner: publicKey,\n        limit: pageCapacity,\n        cursor: nextCursor,\n      });\n    }\n\n    // In case user has less tokens than `pageCapacity` (1 page only), we should put them into `allObjects`\n    const coinObjects: CoinStruct[] = assets.data;\n    allObjects.push(...coinObjects);\n\n    // reducing part\n    const coinAssets: CoinAssetData[] = await getCoinsAssetsFromCoinObjects(allObjects, this.coinManager);\n\n    // Converting balances with decimals\n    for (const asset of coinAssets) {\n      const decimals: number | null = asset.decimals;\n\n      // We don't need to convert balance if it hasn't decimals\n      if (decimals === null) {\n        continue;\n      }\n\n      const bigNumberBalance = new BigNumber(asset.balance);\n      asset.balance = bigNumberBalance.dividedBy(10 ** decimals).toString();\n    }\n\n    return coinAssets;\n  }\n\n  /**\n   * Note: this method is using an `UpdatedTransactionBlock`, that is a `TransactionBlock` from\n   * the @mysten/sui.js v0.51.2 package.\n   *\n   * @description Merges all the passed `coinObjects` into one object.\n   * @return {object} A transaction block, that contains the coins merge; a destination coin object id, into which all\n   * the other coin objects are merged; a transaction result, that is the result of the coins merge.\n   */\n  public static mergeAllCoinObjects({\n    coinObjects,\n    txb,\n  }: {\n    coinObjects: CoinStruct[];\n    txb?: UpdatedTransactionBlock;\n  }): {\n    tx: UpdatedTransactionBlock;\n    destinationObjectId: string;\n    txRes?: TransactionResult;\n  } {\n    if (coinObjects.length === 0) {\n      throw new Error(\"[mergeAllCoinObjects] Passed `coinObjects` are empty.\");\n    }\n\n    const tx = txb ?? new UpdatedTransactionBlock();\n\n    const objectIds = coinObjects.map((obj) => obj.coinObjectId);\n    const [destinationObjectId, ...sourceObjectIds] = objectIds;\n\n    if (sourceObjectIds.length === 0) {\n      return { tx, destinationObjectId };\n    }\n\n    const txRes = tx.mergeCoins(\n      tx.object(destinationObjectId),\n      sourceObjectIds.map((objId) => tx.object(objId)),\n    );\n\n    return { tx, txRes, destinationObjectId };\n  }\n}\n","import { bech32 } from \"bech32\";\n\n/**\n * Validates if the input string conforms to the Bech32 format.\n * Bech32 is a format for encoding Bitcoin addresses.\n * @param {string} input The string to validate.\n * @return {boolean} True if the input string is a valid Bech32 format, otherwise false.\n */\nexport function isValidBech32(input: string): boolean {\n  try {\n    // Attempt to decode the Bech32 string\n    bech32.decode(input);\n\n    // If decoding is successful, return true\n    return true;\n  } catch (error) {\n    // If decoding fails, return false and log a warning\n    if (error instanceof Error) {\n      console.warn(\"Invalid Bech32 format:\", error.message);\n    } else {\n      console.warn(\"Invalid Bech32 format:\", error);\n    }\n    return false;\n  }\n}\n\n/**\n * Validates if the input string is a valid hexadecimal string.\n * @param {string} input The string to validate.\n * @return {boolean} True if the input string is a valid hexadecimal string, otherwise false.\n */\nexport function isValidHex(input: string): boolean {\n  // Regular expression for hexadecimal string\n  const hexRegex = /^[0-9a-fA-F]+$/;\n\n  // Use match to check if the input matches the hexadecimal format\n  const matches = input.match(hexRegex);\n  const isValid = matches !== null;\n\n  return isValid;\n}\n\n/**\n * Determines the format of the input string (Bech32 or hexadecimal).\n * @param {string} input The string to check.\n * @return {string} The format of the input string ('bech32' or 'hex').\n * @throws {Error} If the input string does not match any format.\n */\nexport function determineFormat(input: string): \"bech32\" | \"hex\" {\n  if (isValidBech32(input)) {\n    return \"bech32\";\n  } else if (isValidHex(input)) {\n    return \"hex\";\n  } else {\n    throw new Error(\"Unrecognized format\");\n  }\n}\n","import { CoinStruct } from \"@mysten/sui.js/client\";\nimport { TransactionBlock } from \"@mysten/sui.js/transactions\";\nimport { GetTransactionType } from \"../transactions/types\";\nimport BigNumber from \"bignumber.js\";\n\n/**\n * @class FeeManager\n * @description Utility class for managing fees\n */\nexport class FeeManager {\n  /**\n   * Calculates the fee amount based on the fee percentage and amount.\n   * @param {Object} params - The parameters object.\n   * @param {string} params.feePercentage - The fee percentage should be provided as a percentage value\n   * (e.g., \"5%\" for a 5% fee).\n   * @param {string} params.amount - The amount as a string.\n   * @param {number} params.tokenDecimals - The decimals of `coinType`.\n   * @return {string} The calculated fee amount as a string.\n   */\n  public static calculateFeeAmountIn({\n    feePercentage,\n    amount,\n    tokenDecimals,\n  }: {\n    feePercentage: string;\n    amount: string;\n    tokenDecimals: number;\n  }): string {\n    const feePercentageBig = new BigNumber(feePercentage);\n    const amountBig = new BigNumber(amount);\n    const feeAmount = amountBig.times(feePercentageBig).dividedBy(100).toFixed(tokenDecimals);\n    const feeAmountInDecimals = new BigNumber(feeAmount).multipliedBy(10 ** tokenDecimals).toString();\n\n    return feeAmountInDecimals;\n  }\n\n  /**\n   * Calculates the net amount after deducting the fee.\n   * @param {Object} params - The parameters object.\n   * @param {string} params.feePercentage - The fee percentage should be provided as a percentage value\n   * (e.g., \"5%\" for a 5% fee).\n   * @param {string} params.amount - The amount as a string.\n   * @param {number} params.tokenDecimals - The decimals of `coinType`.\n   * @return {string} The net amount after deducting the fee.\n   */\n  public static calculateNetAmount({\n    feePercentage,\n    amount,\n    tokenDecimals,\n  }: {\n    feePercentage: string;\n    amount: string;\n    tokenDecimals: number;\n  }): string {\n    const feeAmountIn = FeeManager.calculateFeeAmountIn({\n      feePercentage,\n      amount,\n      tokenDecimals,\n    });\n\n    const amountRespectingFee = new BigNumber(amount)\n      .multipliedBy(10 ** tokenDecimals)\n      .minus(feeAmountIn)\n      .dividedBy(10 ** tokenDecimals)\n      .toString();\n\n    return amountRespectingFee;\n  }\n\n  /**\n   * @public\n   * @method getFeeInSuiTransaction\n   * @description Gets the transaction for deducting fees in SUI coin\n   * from `signer` and transfer it to the `feeCollectorAddress`, based on the specified `feeAmountInMIST`.\n   *\n   * @return {GetTransactionType}\n   * A promise that resolves to the transaction block and transaction result for the adding transaction.\n   */\n  public static async getFeeInSuiTransaction({\n    transaction,\n    fee: { feeAmountInMIST, feeCollectorAddress },\n  }: {\n    transaction?: TransactionBlock;\n    fee: { feeAmountInMIST: string; feeCollectorAddress: string };\n  }): GetTransactionType {\n    const tx = transaction ?? new TransactionBlock();\n    const [coin] = tx.splitCoins(tx.gas, [tx.pure(feeAmountInMIST)]);\n    const txRes = tx.transferObjects([coin], tx.pure(feeCollectorAddress));\n\n    return { tx, txRes };\n  }\n\n  /**\n   * @public\n   * @method getFeeInCoinTransaction\n   * @description Gets the transaction for deducting fees in any `coinType`\n   * from `signer` and transfer it to the `feeCollectorAddress`, based on the specified `feeAmount`.\n   *\n   * @return {GetTransactionType}\n   * A promise that resolves to the transaction block and transaction result for the adding transaction.\n   */\n  public static getFeeInCoinTransaction({\n    transaction,\n    fee: { feeAmount, feeCollectorAddress, allCoinObjectsList },\n  }: {\n    transaction?: TransactionBlock;\n    fee: { feeAmount: string; feeCollectorAddress: string; allCoinObjectsList: CoinStruct[] };\n  }) {\n    const tx = transaction ?? new TransactionBlock();\n\n    const sourceCoinObjectId = allCoinObjectsList[0].coinObjectId;\n    const isMergeCoinsRequired = allCoinObjectsList.length > 1;\n\n    if (isMergeCoinsRequired) {\n      console.warn(\"[getFeeInCoinTransaction] [isMergeCoinsRequired]\");\n      const coinObjectIdsToMerge = allCoinObjectsList.slice(1).map((el) => el.coinObjectId);\n\n      tx.mergeCoins(\n        tx.object(sourceCoinObjectId),\n        coinObjectIdsToMerge.map((el) => tx.object(el)),\n      );\n    }\n\n    const coinSplitTxResult = tx.splitCoins(tx.object(sourceCoinObjectId), [tx.pure(feeAmount)]);\n    const txRes = tx.transferObjects([coinSplitTxResult], tx.pure(feeCollectorAddress));\n\n    return { tx, txRes };\n  }\n}\n","/* eslint-disable require-jsdoc */\nimport { EventId, PaginatedEvents, SuiClient, SuiEvent } from \"@mysten/sui.js/client\";\nimport { TransactionBlock } from \"@mysten/sui.js/transactions\";\nimport { SUI_CLOCK_OBJECT_ID } from \"@mysten/sui.js/utils\";\nimport { MAX_BATCH_EVENTS_PER_QUERY_EVENTS_REQUEST } from \"../../providers/common\";\nimport { getAllObjects } from \"../../providers/utils/getAllObjects\";\nimport { GetTransactionType } from \"../../transactions/types\";\nimport { obj } from \"../../transactions/utils\";\nimport {\n  CreateDCAAddGasBudgetTransaction,\n  CreateDCADepositBaseTransactionArgs,\n  CreateDCAInitTransactionArgs,\n  DCACreateEventParsedJson,\n  DCAObject,\n  GetDCAAddGasBudgetTransactionArgs,\n  GetDCADepositBaseTransactionArgs,\n  GetDCAIncreaseOrdersRemainingTransactionArgs,\n  GetDCAInitTradeTransactionArgs,\n  GetDCAInitTransactionArgs,\n  GetDCAInitWithPriceParamsTransactionArgs,\n  GetDCARedeemFundsAndCloseTransactionArgs,\n  GetDCAResolveTradeTransactionArgs,\n  GetDCASetInactiveTransactionArgs,\n  GetDCASetReactivateAsOwnerTransactionArgs,\n  GetDCAWithdrawBaseTransactionArgs,\n  SuiEventDCACreate,\n} from \"./types\";\nimport { filterValidDCAObjects, getBaseQuoteCoinTypesFromDCAType, hasMinMaxPriceParams } from \"./utils\";\nimport BigNumber from \"bignumber.js\";\nimport { DCA_CONFIG } from \"./config\";\n\n/**\n * @class DCAManagerSingleton\n * @description\n * This class encapsulates the business logic for a Dollar Cost Averaging (DCA) smart contract.\n * Dollar Cost Averaging is a strategy for mitigating market volatility by regularly investing a fixed\n * amount of funds over time, regardless of the asset's current price.\n */\nexport class DCAManagerSingleton {\n  public static DCA_PACKAGE_ADDRESS = DCA_CONFIG.DCA_CONTRACT;\n  public static DCA_PACKAGE_ADDRESS_READ = DCA_CONFIG.DCA_CONTRACT_READ;\n  public static DCA_EVENT_TYPE = `${DCAManagerSingleton.DCA_PACKAGE_ADDRESS_READ}::dca::DCACreatedEvent`;\n  public static DCA_GAS_BUGET = 50_000_000;\n  public static DCA_MINIMUM_GAS_FUNDS_PER_TRADE = 25_000_000;\n  public static DCA_TRADE_FEE_BPS = DCA_CONFIG.DCA_TRADE_FEE_BPS;\n  public static DCA_TRADE_FEE_PERCENTAGE = new BigNumber(DCA_CONFIG.DCA_TRADE_FEE_BPS).dividedBy(100).toString();\n  public static DCA_DELEGETEE_ACCOUNT_ADDRESS = \"0x42dbd0fea6fefd7689d566287581724151b5327c08b76bdb9df108ca3b48d1d5\";\n  private static _instance: DCAManagerSingleton;\n  private provider: SuiClient;\n\n  /**\n   * Constructs a new instance of the SuiProvider class with the provided SUI provider URL.\n   *\n   * @private\n   * @constructor\n   * @param {string} suiProviderUrl - The URL of the SUI provider.\n   */\n  private constructor(suiProviderUrl: string) {\n    this.provider = new SuiClient({ url: suiProviderUrl });\n  }\n\n  /**\n   * @public\n   * @method getInstance\n   * @description Gets the singleton instance of DCAManagerSingleton.\n   * @param {string} [suiProviderUrl] - Url of SUI provider.\n   * @return {DCAManagerSingleton} The singleton instance of DCAManagerSingleton.\n   */\n  public static getInstance(suiProviderUrl?: string): DCAManagerSingleton {\n    if (!DCAManagerSingleton._instance) {\n      if (suiProviderUrl === undefined) {\n        throw new Error(\"[DCAManager] SUI provider url is required in arguments to create DCAManager instance.\");\n      }\n\n      const instance = new DCAManagerSingleton(suiProviderUrl);\n      DCAManagerSingleton._instance = instance;\n    }\n\n    return DCAManagerSingleton._instance;\n  }\n\n  public async getDCAEventsByPackage() {\n    // TODO: Move that logic into separate util (e.g. `fetchEventsByPackage`)\n    // TODO: Unify that method with `getDCAEventsByUser`\n    const allEvents: SuiEvent[] = [];\n    let nextCursor: EventId | undefined | null = null;\n    let events: PaginatedEvents = await this.provider.queryEvents({\n      query: { MoveEventType: DCAManagerSingleton.DCA_EVENT_TYPE },\n      limit: MAX_BATCH_EVENTS_PER_QUERY_EVENTS_REQUEST,\n      cursor: nextCursor,\n    });\n\n    // Fetching and combining part\n    while (events.hasNextPage) {\n      const userEvents: SuiEvent[] = events.data;\n      allEvents.push(...userEvents);\n\n      nextCursor = events.nextCursor;\n      events = await this.provider.queryEvents({\n        query: { MoveEventType: DCAManagerSingleton.DCA_EVENT_TYPE },\n        limit: MAX_BATCH_EVENTS_PER_QUERY_EVENTS_REQUEST,\n        cursor: nextCursor,\n      });\n    }\n\n    const userEvents: SuiEvent[] = events.data;\n    allEvents.push(...userEvents);\n\n    const createDCAEvents = allEvents.filter((event): event is SuiEventDCACreate =>\n      DCAManagerSingleton.isDCACreateEventParsedJson(event.parsedJson),\n    );\n\n    return createDCAEvents;\n  }\n\n  public async getDCAsByPackage(): Promise<DCAObject[]> {\n    const createDCAEventsByPackage = await this.getDCAEventsByPackage();\n    const DCAObjectIds = createDCAEventsByPackage.map((el) => el.parsedJson.id);\n\n    const DCAObjectsResponseData = await getAllObjects({\n      objectIds: DCAObjectIds,\n      provider: this.provider,\n      options: { showContent: true },\n    });\n\n    const DCAResponseDataFiltred = filterValidDCAObjects(DCAObjectsResponseData);\n    const dcaList = DCAResponseDataFiltred.map((el) => {\n      const { baseCoinType, quoteCoinType } = getBaseQuoteCoinTypesFromDCAType(el.data.content.type);\n\n      return {\n        ...el.data.content,\n        fields: {\n          ...el.data.content.fields,\n          base_coin_type: baseCoinType,\n          quote_coin_type: quoteCoinType,\n        },\n      };\n    });\n\n    return dcaList;\n  }\n\n  public async getDCAEventsByUser({ publicKey }: { publicKey: string }): Promise<SuiEventDCACreate[]> {\n    // TODO: Move that logic into separate util (e.g. `fetchEventsByUser`)\n    // TODO: Unify that method with `getDCAEventsByPackage`\n    const allEvents: SuiEvent[] = [];\n    let nextCursor: EventId | undefined | null = null;\n    let events: PaginatedEvents = await this.provider.queryEvents({\n      query: { Sender: publicKey },\n      limit: MAX_BATCH_EVENTS_PER_QUERY_EVENTS_REQUEST,\n      cursor: nextCursor,\n    });\n\n    // Fetching and combining part\n    while (events.hasNextPage) {\n      const userEvents: SuiEvent[] = events.data;\n      allEvents.push(...userEvents);\n\n      nextCursor = events.nextCursor;\n      events = await this.provider.queryEvents({\n        query: { Sender: publicKey },\n        limit: MAX_BATCH_EVENTS_PER_QUERY_EVENTS_REQUEST,\n        cursor: nextCursor,\n      });\n    }\n\n    const userEvents: SuiEvent[] = events.data;\n    allEvents.push(...userEvents);\n\n    const createDCAEvents = DCAManagerSingleton.getCreateDCAEventsFromUserEvents(allEvents).filter(\n      (event): event is SuiEventDCACreate => DCAManagerSingleton.isDCACreateEventParsedJson(event.parsedJson),\n    );\n\n    return createDCAEvents;\n  }\n\n  public async getDCAsByUserByStatus({\n    publicKey,\n  }: {\n    publicKey: string;\n  }): Promise<{ activeDCAs: DCAObject[]; deactivatedDCAs: DCAObject[] }> {\n    const dcaList = await this.getDCAsByUser({ publicKey });\n\n    const dcas = dcaList.reduce(\n      (acc: { activeDCAs: DCAObject[]; deactivatedDCAs: DCAObject[] }, el) => {\n        if (el.fields.active) {\n          acc.activeDCAs.push(el);\n        } else {\n          acc.deactivatedDCAs.push(el);\n        }\n\n        return acc;\n      },\n      {\n        activeDCAs: [],\n        deactivatedDCAs: [],\n      },\n    );\n\n    return dcas;\n  }\n\n  public async getDCAsByUser({ publicKey }: { publicKey: string }): Promise<DCAObject[]> {\n    const createDCAEventsByUser = await this.getDCAEventsByUser({ publicKey });\n    const DCAObjectIds = createDCAEventsByUser.map((el) => el.parsedJson.id);\n\n    const DCAObjectsResponseData = await getAllObjects({\n      objectIds: DCAObjectIds,\n      provider: this.provider,\n      options: { showContent: true },\n    });\n\n    const DCAResponseDataFiltred = filterValidDCAObjects(DCAObjectsResponseData);\n    const dcaList = DCAResponseDataFiltred.map((el) => {\n      const { baseCoinType, quoteCoinType } = getBaseQuoteCoinTypesFromDCAType(el.data.content.type);\n\n      return {\n        ...el.data.content,\n        fields: {\n          ...el.data.content.fields,\n          base_coin_type: baseCoinType,\n          quote_coin_type: quoteCoinType,\n        },\n      };\n    });\n\n    return dcaList;\n  }\n\n  public static isDCACreateEventParsedJson(obj: unknown): obj is DCACreateEventParsedJson {\n    return (\n      typeof obj === \"object\" &&\n      obj !== null &&\n      \"delegatee\" in obj &&\n      \"id\" in obj &&\n      \"owner\" in obj &&\n      typeof obj.delegatee === \"string\" &&\n      typeof obj.id === \"string\" &&\n      typeof obj.owner === \"string\"\n    );\n  }\n\n  public static getCreateDCAEventsFromUserEvents(userEvents: SuiEvent[]) {\n    return userEvents.filter((event) => event.type.includes(DCAManagerSingleton.DCA_EVENT_TYPE));\n  }\n\n  public static async createDCAInitTransaction({\n    allCoinObjectsList,\n    publicKey,\n\n    ...dcaParams\n  }: CreateDCAInitTransactionArgs) {\n    const tx = dcaParams.transaction ?? new TransactionBlock();\n\n    const DCA_ALL_SWAPS_GAS_BUGET_BN = new BigNumber(dcaParams.totalOrders).multipliedBy(\n      new BigNumber(DCAManagerSingleton.DCA_MINIMUM_GAS_FUNDS_PER_TRADE),\n    );\n\n    // Note: We relay that there is enough SUI funds on user's wallets for covering DCA_ALL_SWAPS_GAS_BUGET_BN\n    const [coin] = tx.splitCoins(tx.gas, [tx.pure(DCA_ALL_SWAPS_GAS_BUGET_BN)]);\n\n    // TODO: Unify the merge & split coins with all the rest of the methods\n    if (allCoinObjectsList.length === 0) {\n      throw new Error(\"No coin objects found for specific coin type\");\n    }\n\n    const sourceCoinObjectId = allCoinObjectsList[0].coinObjectId;\n    const isMergeCoinsRequired = allCoinObjectsList.length > 1;\n\n    if (isMergeCoinsRequired) {\n      console.warn(`[isMergeCoinsRequired] for ${dcaParams.baseCoinType}`);\n      const coinObjectIdsToMerge = allCoinObjectsList.slice(1).map((el) => el.coinObjectId);\n\n      tx.mergeCoins(\n        tx.object(sourceCoinObjectId),\n        coinObjectIdsToMerge.map((el) => tx.object(el)),\n      );\n    }\n\n    const coinSplitTxResult = tx.splitCoins(tx.object(sourceCoinObjectId), [\n      tx.pure(dcaParams.baseCoinAmountToDepositIntoDCA),\n    ]);\n\n    const result = hasMinMaxPriceParams(dcaParams)\n      ? DCAManagerSingleton.getDCAInitWithParamsTransaction({\n          ...dcaParams,\n          baseCoinAccount: coinSplitTxResult,\n          gasCoinAccount: coin,\n          transaction: tx,\n        })\n      : DCAManagerSingleton.getDCAInitTransaction({\n          ...dcaParams,\n          baseCoinAccount: coinSplitTxResult,\n          gasCoinAccount: coin,\n          transaction: tx,\n        });\n\n    const { tx: dcaTransaction, txRes: dcaTransactionRes } = await result;\n\n    dcaTransaction.transferObjects([coin], dcaTransaction.pure(publicKey));\n\n    return { tx: dcaTransaction, txRes: dcaTransactionRes };\n  }\n\n  public static async getDCAInitTransaction({\n    baseCoinType, // USDC\n    quoteCoinType, // SUI\n\n    baseCoinAccount, // 100 USDC\n    every, // each 10\n    timeScale, // minute\n    totalOrders, // 15 orders\n\n    gasCoinAccount,\n\n    transaction,\n  }: GetDCAInitTransactionArgs): GetTransactionType {\n    const tx = transaction ?? new TransactionBlock();\n\n    const txRes = tx.moveCall({\n      target: `${DCAManagerSingleton.DCA_PACKAGE_ADDRESS}::dca::init_account`,\n      typeArguments: [baseCoinType, quoteCoinType],\n      arguments: [\n        obj(tx, SUI_CLOCK_OBJECT_ID),\n        tx.pure(DCAManagerSingleton.DCA_DELEGETEE_ACCOUNT_ADDRESS, \"address\"),\n        obj(tx, baseCoinAccount),\n        tx.pure(every, \"u64\"),\n        tx.pure(totalOrders, \"u64\"),\n        tx.pure(timeScale, \"u8\"),\n        obj(tx, gasCoinAccount),\n      ],\n    });\n\n    tx.setGasBudget(DCAManagerSingleton.DCA_GAS_BUGET);\n\n    return { tx, txRes };\n  }\n\n  public static async getDCAInitWithParamsTransaction({\n    baseCoinType, // USDC\n    quoteCoinType, // SUI\n\n    minPrice, // 1.3\n    maxPrice, // 1.6\n    baseCoinAccount, // 100 USDC\n    every, // each 10\n    timeScale, // minute\n    totalOrders, // 15 orders\n\n    gasCoinAccount,\n\n    transaction,\n  }: GetDCAInitWithPriceParamsTransactionArgs): GetTransactionType {\n    const tx = transaction ?? new TransactionBlock();\n\n    const txRes = tx.moveCall({\n      target: `${DCAManagerSingleton.DCA_PACKAGE_ADDRESS}::dca::init_account_with_params`,\n      typeArguments: [baseCoinType, quoteCoinType],\n      arguments: [\n        obj(tx, SUI_CLOCK_OBJECT_ID),\n        tx.pure(DCAManagerSingleton.DCA_DELEGETEE_ACCOUNT_ADDRESS, \"address\"),\n        obj(tx, baseCoinAccount),\n        tx.pure(every, \"u64\"),\n        tx.pure(totalOrders, \"u64\"),\n        tx.pure(timeScale, \"u8\"),\n        obj(tx, gasCoinAccount),\n        tx.pure(minPrice, \"u64\"),\n        tx.pure(maxPrice, \"u64\"),\n      ],\n    });\n\n    tx.setGasBudget(DCAManagerSingleton.DCA_GAS_BUGET);\n\n    return { tx, txRes };\n  }\n\n  public static async createDCADepositBaseTransaction({\n    publicKey,\n    allCoinObjectsList,\n    ...dcaParams\n  }: CreateDCADepositBaseTransactionArgs) {\n    const tx = dcaParams.transaction ?? new TransactionBlock();\n\n    const DCA_ALL_SWAPS_GAS_BUGET_BN = new BigNumber(dcaParams.addOrdersCount).multipliedBy(\n      new BigNumber(DCAManagerSingleton.DCA_MINIMUM_GAS_FUNDS_PER_TRADE),\n    );\n\n    // Note: We relay that there is enough SUI funds on user's wallets for covering DCA_ALL_SWAPS_GAS_BUGET_BN\n    const [coin] = tx.splitCoins(tx.gas, [tx.pure(DCA_ALL_SWAPS_GAS_BUGET_BN)]);\n\n    // TODO: Unify the merge & split coins with all the rest of the methods\n    if (allCoinObjectsList.length === 0) {\n      throw new Error(\"No coin objects found for specific coin type\");\n    }\n\n    const sourceCoinObjectId = allCoinObjectsList[0].coinObjectId;\n    const isMergeCoinsRequired = allCoinObjectsList.length > 1;\n\n    if (isMergeCoinsRequired) {\n      console.warn(`[isMergeCoinsRequired] for ${dcaParams.baseCoinType}`);\n      const coinObjectIdsToMerge = allCoinObjectsList.slice(1).map((el) => el.coinObjectId);\n\n      tx.mergeCoins(\n        tx.object(sourceCoinObjectId),\n        coinObjectIdsToMerge.map((el) => tx.object(el)),\n      );\n    }\n\n    const coinSplitTxResult = tx.splitCoins(tx.object(sourceCoinObjectId), [\n      tx.pure(dcaParams.baseCoinAmountToDepositIntoDCA),\n    ]);\n\n    const { tx: dcaTransaction, txRes: dcaTransactionRes } = await DCAManagerSingleton.getDCADepositBaseTransaction({\n      ...dcaParams,\n      baseCoinAccount: coinSplitTxResult,\n      gasCoinAccount: coin,\n      transaction: tx,\n    });\n\n    dcaTransaction.transferObjects([coin], dcaTransaction.pure(publicKey));\n\n    return { tx: dcaTransaction, txRes: dcaTransactionRes };\n  }\n\n  public static async getDCADepositBaseTransaction({\n    dca,\n\n    baseCoinType,\n    quoteCoinType,\n\n    baseCoinAccount,\n    addOrdersCount = 0,\n\n    gasCoinAccount,\n\n    transaction,\n  }: GetDCADepositBaseTransactionArgs): GetTransactionType {\n    const tx = transaction ?? new TransactionBlock();\n\n    const txRes = tx.moveCall({\n      target: `${DCAManagerSingleton.DCA_PACKAGE_ADDRESS}::dca::deposit_input`,\n      typeArguments: [baseCoinType, quoteCoinType],\n      arguments: [obj(tx, dca), obj(tx, baseCoinAccount), tx.pure(addOrdersCount), obj(tx, gasCoinAccount)],\n    });\n\n    tx.setGasBudget(DCAManagerSingleton.DCA_GAS_BUGET);\n\n    return { tx, txRes };\n  }\n\n  public static async getDCAWithdrawBaseTransaction({\n    dca,\n\n    baseCoinType,\n    quoteCoinType,\n\n    baseCoinAmountToWithdrawFromDCA,\n    removeOrdersCount = 0,\n\n    transaction,\n  }: GetDCAWithdrawBaseTransactionArgs): GetTransactionType {\n    const tx = transaction ?? new TransactionBlock();\n\n    const txRes = tx.moveCall({\n      target: `${DCAManagerSingleton.DCA_PACKAGE_ADDRESS}::dca::withdraw_input`,\n      typeArguments: [baseCoinType, quoteCoinType],\n      arguments: [obj(tx, dca), tx.pure(baseCoinAmountToWithdrawFromDCA), tx.pure(removeOrdersCount)],\n    });\n\n    tx.setGasBudget(DCAManagerSingleton.DCA_GAS_BUGET);\n\n    return { tx, txRes };\n  }\n\n  public static async getDCAInitTradeTransaction({\n    dca,\n\n    baseCoinType,\n    quoteCoinType,\n\n    transaction,\n  }: GetDCAInitTradeTransactionArgs): GetTransactionType {\n    const tx = transaction ?? new TransactionBlock();\n\n    const txRes = tx.moveCall({\n      target: `${DCAManagerSingleton.DCA_PACKAGE_ADDRESS}::dca::init_trade`,\n      typeArguments: [baseCoinType, quoteCoinType],\n      arguments: [obj(tx, dca), obj(tx, SUI_CLOCK_OBJECT_ID)],\n    });\n\n    tx.setGasBudget(DCAManagerSingleton.DCA_GAS_BUGET);\n\n    return { tx, txRes };\n  }\n\n  public static async getDCAResolveTradeTransaction({\n    dca,\n\n    baseCoinType,\n    quoteCoinType,\n\n    transaction,\n\n    quoteAmount,\n    initTradePromise,\n  }: GetDCAResolveTradeTransactionArgs): GetTransactionType {\n    const tx = transaction ?? new TransactionBlock();\n\n    const txRes = tx.moveCall({\n      target: `${DCAManagerSingleton.DCA_PACKAGE_ADDRESS}::dca::resolve_trade`,\n      typeArguments: [baseCoinType, quoteCoinType],\n      arguments: [obj(tx, dca), obj(tx, quoteAmount), obj(tx, initTradePromise)],\n    });\n\n    tx.setGasBudget(DCAManagerSingleton.DCA_GAS_BUGET);\n\n    return { tx, txRes };\n  }\n\n  public static async getDCAIncreaseOrdersRemainingTransaction({\n    dca,\n    publicKey,\n    baseCoinType,\n    quoteCoinType,\n    transaction,\n    addOrdersCount,\n  }: GetDCAIncreaseOrdersRemainingTransactionArgs): GetTransactionType {\n    const tx = transaction ?? new TransactionBlock();\n\n    const DCA_ALL_SWAPS_GAS_BUGET_BN = new BigNumber(addOrdersCount).multipliedBy(\n      new BigNumber(DCAManagerSingleton.DCA_MINIMUM_GAS_FUNDS_PER_TRADE),\n    );\n\n    // Note: We relay that there is enough SUI funds on user's wallets for covering DCA_ALL_SWAPS_GAS_BUGET_BN\n    const [coin] = tx.splitCoins(tx.gas, [tx.pure(DCA_ALL_SWAPS_GAS_BUGET_BN)]);\n\n    const txRes = tx.moveCall({\n      target: `${DCAManagerSingleton.DCA_PACKAGE_ADDRESS}::dca::increase_remaining_orders`,\n      typeArguments: [baseCoinType, quoteCoinType],\n      arguments: [obj(tx, dca), obj(tx, coin), tx.pure(addOrdersCount)],\n    });\n\n    tx.transferObjects([coin], tx.pure(publicKey));\n\n    tx.setGasBudget(DCAManagerSingleton.DCA_GAS_BUGET);\n\n    return { tx, txRes };\n  }\n\n  /**\n   * Set DCA to inactive state, should be signed from either `delegatee` or an `owner` of DCA.\n   */\n  public static async getDCASetInactiveTransaction({\n    dca,\n    baseCoinType,\n    quoteCoinType,\n    transaction,\n  }: GetDCASetInactiveTransactionArgs): GetTransactionType {\n    const tx = transaction ?? new TransactionBlock();\n\n    const txRes = tx.moveCall({\n      target: `${DCAManagerSingleton.DCA_PACKAGE_ADDRESS}::dca::set_inactive`,\n      typeArguments: [baseCoinType, quoteCoinType],\n      arguments: [obj(tx, dca)],\n    });\n\n    tx.setGasBudget(DCAManagerSingleton.DCA_GAS_BUGET);\n\n    return { tx, txRes };\n  }\n\n  /**\n   * Set DCA to inactive state, should be signed only from an `owner` of DCA.\n   */\n  public static async getDCAReactivateAsOwnerTransaction({\n    dca,\n    baseCoinType,\n    quoteCoinType,\n    transaction,\n  }: GetDCASetReactivateAsOwnerTransactionArgs): GetTransactionType {\n    const tx = transaction ?? new TransactionBlock();\n\n    const txRes = tx.moveCall({\n      target: `${DCAManagerSingleton.DCA_PACKAGE_ADDRESS}::dca::reactivate_as_owner`,\n      typeArguments: [baseCoinType, quoteCoinType],\n      arguments: [obj(tx, dca)],\n    });\n\n    tx.setGasBudget(DCAManagerSingleton.DCA_GAS_BUGET);\n\n    return { tx, txRes };\n  }\n\n  /**\n   * Retrieves DCA transaction which would redeem funds in DCA and close DCA.\n   * @comment This method is a work in progress and is not functioning correctly at the moment\n   * (because SUI doesn't support deletion of shared or immutable objects at the moment).\n   * It suppose to work from 1.20 version of SUI mainnet\n   */\n  public static async getDCARedeemFundsAndCloseTransaction({\n    dca,\n    baseCoinType,\n    quoteCoinType,\n    transaction,\n  }: GetDCARedeemFundsAndCloseTransactionArgs): GetTransactionType {\n    const tx = transaction ?? new TransactionBlock();\n\n    const txRes = tx.moveCall({\n      target: `${DCAManagerSingleton.DCA_PACKAGE_ADDRESS}::dca::redeem_funds_and_close`,\n      typeArguments: [baseCoinType, quoteCoinType],\n      arguments: [obj(tx, dca)],\n    });\n\n    tx.setGasBudget(DCAManagerSingleton.DCA_GAS_BUGET);\n\n    return { tx, txRes };\n  }\n\n  public static async createDCAAddGasBudgetTransaction({ ...dcaParams }: CreateDCAAddGasBudgetTransaction) {\n    const tx = dcaParams.transaction ?? new TransactionBlock();\n\n    // Note: We relay that there is enough SUI funds on user's wallets for covering DCA_ALL_SWAPS_GAS_BUGET_BN\n    const [coin] = tx.splitCoins(tx.gas, [tx.pure(dcaParams.gasAmountToAdd)]);\n\n    const { tx: dcaTransaction, txRes: dcaTransactionRes } = await DCAManagerSingleton.getDCAAddGasBudgetTransaction({\n      ...dcaParams,\n      gasCoinAccount: coin,\n      transaction: tx,\n    });\n\n    return { tx: dcaTransaction, txRes: dcaTransactionRes };\n  }\n\n  public static async getDCAAddGasBudgetTransaction({\n    dca,\n    baseCoinType,\n    quoteCoinType,\n\n    transaction,\n\n    gasCoinAccount,\n  }: GetDCAAddGasBudgetTransactionArgs): GetTransactionType {\n    const tx = transaction ?? new TransactionBlock();\n\n    const txRes = tx.moveCall({\n      target: `${DCAManagerSingleton.DCA_PACKAGE_ADDRESS}::dca::add_gas_budget`,\n      typeArguments: [baseCoinType, quoteCoinType],\n      arguments: [obj(tx, dca), obj(tx, gasCoinAccount)],\n    });\n\n    tx.setGasBudget(DCAManagerSingleton.DCA_GAS_BUGET);\n\n    return { tx, txRes };\n  }\n}\n","// https://stackoverflow.com/a/10456644\nexport const splitBy = <T>(list: T[], chunkSize: number): T[][] => {\n  const result: T[][] = [];\n  for (let i = 0; i < list.length; i += chunkSize) {\n    result.push(list.slice(i, i + chunkSize));\n  }\n\n  return result;\n};\n","import { MultiGetObjectsParams, SuiClient } from \"@mysten/sui.js/client\";\nimport { splitBy } from \"./splitBy\";\nimport { MAX_BATCH_OBJECTS_PER_GET_OBJECT_REQUEST } from \"../common\";\n\n/**\n * Retrieves objects from the SuiClient based on provided objectIds, respecting limitations.\n * @throws {Error} If any error occurs during the retrieval process.\n * @description\n * The function fetches objects from SuiClient based on the provided objectIds.\n * It respects the limitation of `multiGetObjects` (50 objectIds per request) by\n * splitting the requests into chunks. Additionally, it handles the caveat of\n * duplicate objectIds in the same request by using a Set structure to ensure\n * uniqueness before making the requests.\n */\nexport async function getAllObjects({\n  objectIds,\n  provider,\n  options,\n}: {\n  objectIds: string[];\n  provider: SuiClient;\n  options?: MultiGetObjectsParams[\"options\"];\n}) {\n  const allIds = new Set<string>(objectIds);\n  const toFetch = Array.from(allIds);\n  const chunks = splitBy(toFetch, MAX_BATCH_OBJECTS_PER_GET_OBJECT_REQUEST);\n\n  const result = await Promise.all(\n    chunks.map((ids) =>\n      provider.multiGetObjects({\n        ids,\n        options,\n      }),\n    ),\n  );\n\n  const flatResult = result.flat();\n\n  return flatResult;\n}\n","/* eslint-disable require-jsdoc */\n\nimport { TransactionArgument, TransactionBlock } from \"@mysten/sui.js/transactions\";\nimport { GenericArg, ObjectArg } from \"./types\";\n\nexport function isTransactionArgument(arg: GenericArg): arg is TransactionArgument {\n  if (!arg || typeof arg !== \"object\" || Array.isArray(arg)) {\n    return false;\n  }\n\n  return \"kind\" in arg;\n}\n\nexport function obj(tx: TransactionBlock, arg: ObjectArg) {\n  return isTransactionArgument(arg) ? arg : tx.object(arg);\n}\n","export const DCA_CONFIG = {\n  DCA_TRADE_FEE_BPS: 5,\n  DCA_CONTRACT: \"0x3ed0a2079006bdc14688b0b99129dd5fcf9ebda3042db1a58b5347b8bf542c40\",\n  DCA_CONTRACT_READ: \"0x89b1372fa44ac2312a3876d83612d1dc9d298af332a42a153913558332a564d0\",\n};\n","/* eslint-disable require-jsdoc */\n\nimport { MoveStruct, SuiParsedData, SuiObjectResponse } from \"@mysten/sui.js/client\";\nimport { DCAContent, DCAContentFields, DCAResponse } from \"./types\";\nimport { TOKEN_ADDRESS_BASE_REGEX } from \"../../providers/common\";\nimport { Argument } from \"./txBlock\";\nimport { DCA_CONFIG } from \"./config\";\n\n// eslint-disable-next-line\nexport function feeAmount(amount: number): number {\n  const scaledFee = Math.floor((amount * 1_000_000 * DCA_CONFIG.DCA_TRADE_FEE_BPS) / 10_000);\n\n  return scaledFee / 1_000_000;\n}\n\nexport function isValidDCAFields(fields: MoveStruct): fields is DCAContentFields {\n  const expectedKeys: (keyof DCAContentFields)[] = [\n    \"active\",\n    \"input_balance\",\n    \"delegatee\",\n    \"every\",\n    \"gas_budget\",\n    \"id\",\n    \"last_time_ms\",\n    \"owner\",\n    \"remaining_orders\",\n    \"split_allocation\",\n    \"start_time_ms\",\n    \"time_scale\",\n    \"trade_params\",\n  ];\n\n  return (\n    expectedKeys.every((key) => key in fields) &&\n    // the \"active\" in fields is the ts-check bypass for MoveStruct type\n    \"active\" in fields &&\n    typeof fields.active === \"boolean\" &&\n    typeof fields.input_balance === \"string\" &&\n    typeof fields.delegatee === \"string\" &&\n    typeof fields.every === \"string\" &&\n    typeof fields.gas_budget === \"string\" &&\n    typeof fields.id === \"object\" && // Assuming id is always an object\n    typeof fields.last_time_ms === \"string\" &&\n    typeof fields.owner === \"string\" &&\n    typeof fields.remaining_orders === \"string\" &&\n    typeof fields.split_allocation === \"string\" &&\n    typeof fields.start_time_ms === \"string\" &&\n    typeof fields.time_scale === \"number\" &&\n    typeof fields.trade_params === \"object\" &&\n    fields.trade_params !== null &&\n    \"type\" in fields.trade_params &&\n    \"fields\" in fields.trade_params &&\n    typeof fields.trade_params.fields === \"object\" &&\n    fields.trade_params.fields !== null &&\n    \"max_price\" in fields.trade_params.fields &&\n    \"min_price\" in fields.trade_params.fields &&\n    typeof fields.trade_params.type === \"string\" &&\n    typeof fields.trade_params.fields === \"object\" &&\n    (typeof fields.trade_params.fields.max_price === \"string\" || fields.trade_params.fields.max_price === null) &&\n    (typeof fields.trade_params.fields.min_price === \"string\" || fields.trade_params.fields.min_price === null)\n  );\n}\n\nexport function isDCAContent(data: SuiParsedData | null): data is DCAContent {\n  return (\n    !!data &&\n    data.dataType === \"moveObject\" &&\n    typeof data.type === \"string\" &&\n    typeof data.hasPublicTransfer === \"boolean\" &&\n    isValidDCAFields(data.fields)\n  );\n}\n\nexport function isValidDCAObjectResponse(obj: SuiObjectResponse): obj is DCAResponse {\n  return !!obj.data?.content && isDCAContent(obj.data.content);\n}\n\nexport function filterValidDCAObjects(dcaList: SuiObjectResponse[]): DCAResponse[] {\n  return dcaList.filter(isValidDCAObjectResponse);\n}\n\n// TODO: Add test for the util function, since it does use regex\n/**\n * Extracts base and quote coin types from the input DCA type string.\n *\n * @param {string} dcaTypeString - The input DCA type string.\n * @return {{ baseCoinType: string, quoteCoinType: string }} An object containing the base and quote coin types.\n * @throws {Error} Throws an error if the input string does not match the expected format.\n */\nexport function getBaseQuoteCoinTypesFromDCAType(dcaTypeString: string): {\n  baseCoinType: string;\n  quoteCoinType: string;\n} {\n  const regex = new RegExp(`DCA<(${TOKEN_ADDRESS_BASE_REGEX.source}).*(${TOKEN_ADDRESS_BASE_REGEX.source})>`);\n  const match = dcaTypeString.match(regex);\n\n  if (!match) {\n    throw new Error(\"Invalid DCA type string format\");\n  }\n\n  const [baseCoinType, quoteCoinType] = match.slice(1, 3);\n\n  return {\n    baseCoinType,\n    quoteCoinType,\n  };\n}\n\nexport function hasMinMaxPriceParams(params: {\n  minPrice?: string;\n  maxPrice?: string;\n}): params is { minPrice: string; maxPrice: string } {\n  return params.minPrice !== undefined && params.maxPrice !== undefined;\n}\n\nexport const fromArgument = (arg: Argument, idx: number) => {\n  // console.log(`Processing argument at index ${idx}:`, arg);\n\n  return {\n    kind: arg.kind,\n    value: arg.value,\n    type: arg.type,\n    index: idx,\n  };\n};\n","import { CoinStruct, SuiEvent, SuiObjectData, SuiObjectResponse } from \"@mysten/sui.js/client\";\nimport { TransactionBlock } from \"@mysten/sui.js/transactions\";\nimport { ObjectArg, TransactionResult } from \"../../transactions/types\";\n\nexport enum DCATimescale {\n  Seconds = 0,\n  Minutes = 1,\n  Hours = 2,\n  Days = 3,\n  Weeks = 4,\n  Months = 5,\n}\n\nexport type GetDCAInitTransactionArgs = {\n  baseCoinType: string;\n  quoteCoinType: string;\n\n  timeScale: DCATimescale;\n  every: number;\n  baseCoinAccount: ObjectArg;\n  totalOrders: number;\n\n  gasCoinAccount: ObjectArg;\n\n  transaction?: TransactionBlock;\n};\n\nexport type GetDCAInitWithPriceParamsTransactionArgs = {\n  minPrice: string;\n  maxPrice: string;\n} & GetDCAInitTransactionArgs;\n\nexport type CreateDCAInitTransactionArgs = Omit<\n  Omit<GetDCAInitTransactionArgs, \"baseCoinAccount\">,\n  \"gasCoinAccount\"\n> & {\n  publicKey: string;\n  baseCoinAmountToDepositIntoDCA: string;\n  allCoinObjectsList: CoinStruct[];\n  minPrice?: string;\n  maxPrice?: string;\n};\n\nexport interface GetDCADepositBaseTransactionArgs {\n  dca: ObjectArg;\n  baseCoinType: string;\n  quoteCoinType: string;\n  baseCoinAccount: ObjectArg;\n  addOrdersCount: number;\n\n  gasCoinAccount: ObjectArg;\n\n  transaction?: TransactionBlock;\n}\n\nexport type CreateDCADepositBaseTransactionArgs = Omit<\n  Omit<GetDCADepositBaseTransactionArgs, \"baseCoinAccount\">,\n  \"gasCoinAccount\"\n> & {\n  publicKey: string;\n  baseCoinAmountToDepositIntoDCA: string;\n  allCoinObjectsList: CoinStruct[];\n};\n\nexport interface GetDCAWithdrawBaseTransactionArgs {\n  dca: ObjectArg;\n\n  baseCoinType: string;\n  quoteCoinType: string;\n\n  baseCoinAmountToWithdrawFromDCA: string;\n  removeOrdersCount?: number;\n\n  transaction?: TransactionBlock;\n}\n\nexport interface GetDCAInitTradeTransactionArgs {\n  dca: ObjectArg;\n  baseCoinType: string;\n  quoteCoinType: string;\n\n  transaction?: TransactionBlock;\n}\n\nexport interface GetDCAResolveTradeTransactionArgs {\n  dca: ObjectArg;\n\n  baseCoinType: string;\n  quoteCoinType: string;\n\n  transaction?: TransactionBlock;\n\n  quoteAmount: string;\n  initTradePromise: TransactionResult;\n}\n\nexport interface GetDCAIncreaseOrdersRemainingTransactionArgs {\n  publicKey: string;\n  dca: ObjectArg;\n\n  baseCoinType: string;\n  quoteCoinType: string;\n\n  transaction?: TransactionBlock;\n  addOrdersCount: number;\n}\n\nexport interface GetDCASetInactiveTransactionArgs {\n  dca: ObjectArg;\n\n  baseCoinType: string;\n  quoteCoinType: string;\n\n  transaction?: TransactionBlock;\n}\n\nexport type GetDCASetReactivateAsOwnerTransactionArgs = GetDCASetInactiveTransactionArgs;\nexport type GetDCARedeemFundsAndCloseTransactionArgs = GetDCASetInactiveTransactionArgs;\n\nexport type GetDCAAddGasBudgetTransactionArgs = { gasCoinAccount: ObjectArg } & GetDCASetInactiveTransactionArgs;\nexport type CreateDCAAddGasBudgetTransaction = {\n  gasAmountToAdd: string;\n} & Omit<GetDCAAddGasBudgetTransactionArgs, \"gasCoinAccount\">;\n\nexport type DCACreateEventParsedJson = {\n  delegatee: string;\n  id: string;\n  owner: string;\n};\n\n// Extend SuiEvent to include your specific parsedJson type\nexport interface SuiEventDCACreate extends SuiEvent {\n  parsedJson: DCACreateEventParsedJson;\n}\n\nexport interface DCAContent {\n  dataType: \"moveObject\";\n  type: string;\n  hasPublicTransfer: boolean;\n  fields: DCAContentFields;\n}\n\nexport type DCAContentFields = {\n  active: boolean;\n  input_balance: string;\n  delegatee: string;\n  every: string;\n  gas_budget: string;\n  id: { id: string };\n  last_time_ms: string;\n  owner: string;\n  remaining_orders: string;\n  split_allocation: string;\n  start_time_ms: string;\n  time_scale: number;\n  trade_params: {\n    type: string;\n    fields: {\n      max_price: string | null;\n      min_price: string | null;\n    };\n  };\n};\n\nexport interface DCAObject extends DCAContent {\n  fields: DCAContentFields & {\n    base_coin_type: string;\n    quote_coin_type: string;\n  };\n}\n\nexport interface DCAResponseData extends SuiObjectData {\n  content: DCAContent;\n}\n\nexport interface DCAResponse extends SuiObjectResponse {\n  data: DCAResponseData;\n}\n","/* eslint-disable require-jsdoc */\nimport { SuiClient } from \"@mysten/sui.js/client\";\nimport { Keypair, SignatureWithBytes } from \"@mysten/sui.js/cryptography\";\nimport { TransactionBlock } from \"@mysten/sui.js/transactions\";\nimport { verifyPersonalMessage } from \"@mysten/sui.js/verify\";\nimport { ObjectArg } from \"../../transactions/types\";\nimport { obj } from \"../../transactions/utils\";\nimport { BoostedClaimCapType, DecodedAmount, hexStringToByteArray, isBoostedClaimCap } from \"./utils\";\nimport BigNumber from \"bignumber.js\";\nimport { SUI_DENOMINATOR } from \"../..\";\nimport { getAllOwnedObjects } from \"../../providers/utils/getAllOwnedObjects\";\nimport { bcs } from \"@mysten/sui.js/bcs\";\nimport { SUI_CLOCK_OBJECT_ID } from \"@mysten/sui.js/utils\";\n\n/**\n * @class RefundManagerSingleton\n * @description\n * This class encapsulates the business logic for a Refund smart contract.\n */\nexport class RefundManagerSingleton {\n  public static SIMLATION_ACCOUNT_ADDRESS = \"0xca9711c3de3ef474209ebd920b894e4d374ff09e210bc31cbd2d266f7bff90ca\";\n  public static REFUND_PACKAGE_ADDRESS = \"0x2843d7add326ac31e71c75954b79a059aa13456946d26422a9fd20f75e06b468\";\n  public static REFUND_PACKAGE_ADDRESS_READ = \"\";\n  public static REFUND_POOL_OBJECT_ID = \"0x82544a2f83c6ed1c1092d4b0e92837e2c3bd983228dd6529da632070b6657a97\";\n  public static REFUND_POOL_PUBLISHER_OBJECT_ID = \"0xf3f6708de5137be44e2dde8a2fd33e7ebd64398d55312414c7b0e3309367e378\";\n  public static REFUND_BOOSTED_CLAIM_CAP_STRUCT_TYPE_NAME = \"BoostedClaimCap\";\n  public static REFUND_MODULE_NAME = \"refund\";\n  public static REFUND_BOOSTED_MODULE_NAME = \"booster\";\n  // eslint-disable-next-line max-len\n  public static BOOSTER_OBJECT_TYPE = `${RefundManagerSingleton.REFUND_PACKAGE_ADDRESS}::${RefundManagerSingleton.REFUND_BOOSTED_MODULE_NAME}::${this.REFUND_BOOSTED_CLAIM_CAP_STRUCT_TYPE_NAME}`;\n\n  public static REFUND_GAS_BUGET = 50_000_000;\n  public static REFUND_GAS_BUDGET_ADDRESS_ADDITION = 1_000_000_000;\n\n  private static _instance: RefundManagerSingleton;\n  private provider: SuiClient;\n\n  /**\n   * Constructs a new instance of the SuiProvider class with the provided SUI provider URL.\n   *\n   * @private\n   * @constructor\n   * @param {string} suiProviderUrl - The URL of the SUI provider.\n   */\n  private constructor(suiProviderUrl: string) {\n    this.provider = new SuiClient({ url: suiProviderUrl });\n  }\n\n  /**\n   * @public\n   * @method getInstance\n   * @description Gets the singleton instance of RefundManagerSingleton.\n   * @param {string} [suiProviderUrl] - Url of SUI provider.\n   * @return {RefundManagerSingleton} The singleton instance of RefundManagerSingleton.\n   */\n  public static getInstance(suiProviderUrl?: string): RefundManagerSingleton {\n    if (!RefundManagerSingleton._instance) {\n      if (suiProviderUrl === undefined) {\n        throw new Error(\"[DCAManager] SUI provider url is required in arguments to create DCAManager instance.\");\n      }\n\n      const instance = new RefundManagerSingleton(suiProviderUrl);\n      RefundManagerSingleton._instance = instance;\n    }\n\n    return RefundManagerSingleton._instance;\n  }\n\n  public static getAddAddressesTransaction({\n    publisherObjectId,\n    poolObjectId,\n    addressesList,\n    amountsList,\n\n    transaction,\n  }: {\n    publisherObjectId: ObjectArg;\n    poolObjectId: ObjectArg;\n    addressesList: string[];\n    amountsList: string[];\n\n    transaction?: TransactionBlock;\n  }) {\n    const tx = transaction ?? new TransactionBlock();\n\n    const txRes = tx.moveCall({\n      target: `${RefundManagerSingleton.REFUND_PACKAGE_ADDRESS}::refund::add_addresses`,\n      typeArguments: [],\n      arguments: [obj(tx, publisherObjectId), obj(tx, poolObjectId), tx.pure(addressesList), tx.pure(amountsList)],\n    });\n\n    tx.setGasBudget(RefundManagerSingleton.REFUND_GAS_BUDGET_ADDRESS_ADDITION);\n\n    return { tx, txRes };\n  }\n\n  public static getClaimRefundTransaction({\n    poolObjectId,\n    clock = SUI_CLOCK_OBJECT_ID,\n    transaction,\n  }: {\n    poolObjectId: ObjectArg;\n    clock?: ObjectArg;\n    transaction?: TransactionBlock;\n  }) {\n    const tx = transaction ?? new TransactionBlock();\n\n    const txRes = tx.moveCall({\n      target: `${RefundManagerSingleton.REFUND_PACKAGE_ADDRESS}::refund::claim_refund`,\n      typeArguments: [],\n      arguments: [obj(tx, poolObjectId), obj(tx, clock)],\n    });\n\n    tx.setGasBudget(RefundManagerSingleton.REFUND_GAS_BUGET);\n\n    return { tx, txRes };\n  }\n\n  public static startFundingPhase({\n    publisherObjectId,\n    poolObjectId,\n    timeoutMilliseconds,\n    clock,\n\n    transaction,\n  }: {\n    publisherObjectId: ObjectArg;\n    poolObjectId: ObjectArg;\n    timeoutMilliseconds: number;\n    clock: ObjectArg;\n\n    transaction?: TransactionBlock;\n  }) {\n    const tx = transaction ?? new TransactionBlock();\n\n    const txRes = tx.moveCall({\n      target: `${RefundManagerSingleton.REFUND_PACKAGE_ADDRESS}::refund::start_funding_phase`,\n      typeArguments: [],\n      arguments: [obj(tx, publisherObjectId), obj(tx, poolObjectId), tx.pure(timeoutMilliseconds), obj(tx, clock)],\n    });\n\n    tx.setGasBudget(RefundManagerSingleton.REFUND_GAS_BUGET);\n\n    return { tx, txRes };\n  }\n\n  public static startClaimPhase({\n    poolObjectId,\n    clock = SUI_CLOCK_OBJECT_ID,\n\n    transaction,\n  }: {\n    poolObjectId: ObjectArg;\n    clock?: ObjectArg;\n\n    transaction?: TransactionBlock;\n  }) {\n    const tx = transaction ?? new TransactionBlock();\n\n    const txRes = tx.moveCall({\n      target: `${RefundManagerSingleton.REFUND_PACKAGE_ADDRESS}::refund::start_claim_phase`,\n      typeArguments: [],\n      arguments: [obj(tx, poolObjectId), obj(tx, clock)],\n    });\n\n    tx.setGasBudget(RefundManagerSingleton.REFUND_GAS_BUGET);\n\n    return { tx, txRes };\n  }\n\n  public static startReclaimPhase({\n    poolObjectId,\n    clock,\n\n    transaction,\n  }: {\n    poolObjectId: ObjectArg;\n    clock: ObjectArg;\n\n    transaction?: TransactionBlock;\n  }) {\n    const tx = transaction ?? new TransactionBlock();\n\n    const txRes = tx.moveCall({\n      target: `${RefundManagerSingleton.REFUND_PACKAGE_ADDRESS}::refund::start_reclaim_phase`,\n      typeArguments: [],\n      arguments: [obj(tx, poolObjectId), obj(tx, clock)],\n    });\n\n    tx.setGasBudget(RefundManagerSingleton.REFUND_GAS_BUGET);\n\n    return { tx, txRes };\n  }\n\n  public async getCurrentRefundPhase({\n    poolObjectId,\n    transaction,\n  }: {\n    poolObjectId: string;\n    transaction?: TransactionBlock;\n  }) {\n    const tx = transaction ?? new TransactionBlock();\n\n    const txRes = tx.moveCall({\n      target: `${RefundManagerSingleton.REFUND_PACKAGE_ADDRESS}::refund::phase`,\n      typeArguments: [],\n      arguments: [obj(tx, poolObjectId)],\n    });\n\n    tx.setGasBudget(RefundManagerSingleton.REFUND_GAS_BUGET);\n\n    const res = await this.provider.devInspectTransactionBlock({\n      sender: RefundManagerSingleton.SIMLATION_ACCOUNT_ADDRESS,\n      transactionBlock: tx,\n    });\n\n    if (!res.results) {\n      throw new Error(\"No results found for the request phase request\");\n    }\n\n    const returnValues = res.results[0].returnValues;\n\n    if (!returnValues) {\n      throw new Error(\"Return values are undefined\");\n    }\n\n    const phase = returnValues[0][0][0];\n\n    return phase;\n  }\n\n  public async getUnclaimedAddressesList({\n    poolObjectId,\n    transaction,\n  }: {\n    poolObjectId: string;\n    transaction?: TransactionBlock;\n  }) {\n    const tx = transaction ?? new TransactionBlock();\n\n    const txRes = tx.moveCall({\n      target: `${RefundManagerSingleton.REFUND_PACKAGE_ADDRESS}::refund::unclaimed`,\n      typeArguments: [],\n      arguments: [obj(tx, poolObjectId)],\n    });\n\n    tx.setGasBudget(RefundManagerSingleton.REFUND_GAS_BUGET);\n\n    const res = await this.provider.devInspectTransactionBlock({\n      sender: RefundManagerSingleton.SIMLATION_ACCOUNT_ADDRESS,\n      transactionBlock: tx,\n    });\n\n    if (!res.results) {\n      throw new Error(\"No results found for the request phase request\");\n    }\n\n    const returnValues = res.results[0].returnValues;\n\n    if (!returnValues) {\n      throw new Error(\"Return values are undefined\");\n    }\n\n    const table = returnValues[0][0];\n\n    return table;\n  }\n\n  public async getClaimAmountNormal({\n    poolObjectId,\n    affectedAddress,\n  }: {\n    poolObjectId: string;\n    affectedAddress: string;\n  }) {\n    const tx = new TransactionBlock();\n\n    const txRes = tx.moveCall({\n      target: `${RefundManagerSingleton.REFUND_PACKAGE_ADDRESS}::refund::amount_to_claim`,\n      typeArguments: [],\n      arguments: [obj(tx, poolObjectId), tx.pure(affectedAddress)],\n    });\n\n    tx.setGasBudget(RefundManagerSingleton.REFUND_GAS_BUGET);\n\n    const res = await this.provider.devInspectTransactionBlock({\n      sender: RefundManagerSingleton.SIMLATION_ACCOUNT_ADDRESS,\n      transactionBlock: tx,\n    });\n\n    if (!res.results) {\n      throw new Error(\"No results found for the request phase request\");\n    }\n\n    const returnValues = res.results[0].returnValues;\n\n    if (!returnValues) {\n      throw new Error(\"Return values are undefined\");\n    }\n\n    const rawAmountBytes = returnValues[0][0];\n    const decoded: DecodedAmount = bcs.de(\"Option<u64>\", new Uint8Array(rawAmountBytes));\n    let amount: string;\n\n    if (\"Some\" in decoded && decoded.Some) {\n      amount = decoded.Some;\n    } else if (\"None\" in decoded && decoded.None === true) {\n      amount = \"0\"; // Use \"0\" if decoded.None is true\n    } else {\n      throw new Error(\"Decoded amount has an invalid shape\");\n    }\n\n    const amountInMist = amount.toString();\n    const amountInSui = new BigNumber(amount).div(SUI_DENOMINATOR).toString();\n\n    return { mist: amountInMist, sui: amountInSui };\n  }\n\n  public async getClaimAmountBoosted({\n    poolObjectId,\n    affectedAddress,\n  }: {\n    poolObjectId: string;\n    affectedAddress: string;\n  }) {\n    const tx = new TransactionBlock();\n\n    const txRes = tx.moveCall({\n      target: `${RefundManagerSingleton.REFUND_PACKAGE_ADDRESS}::refund::amount_to_claim_boosted`,\n      typeArguments: [],\n      arguments: [obj(tx, poolObjectId), tx.pure(affectedAddress)],\n    });\n\n    tx.setGasBudget(RefundManagerSingleton.REFUND_GAS_BUGET);\n\n    const res = await this.provider.devInspectTransactionBlock({\n      sender: RefundManagerSingleton.SIMLATION_ACCOUNT_ADDRESS,\n      transactionBlock: tx,\n    });\n\n    if (!res.results) {\n      throw new Error(\"No results found for the request phase request\");\n    }\n\n    const returnValues = res.results[0].returnValues;\n\n    if (!returnValues) {\n      throw new Error(\"Return values are undefined\");\n    }\n\n    const rawAmountBytes = returnValues[0][0];\n    const decoded: DecodedAmount = bcs.de(\"Option<u64>\", new Uint8Array(rawAmountBytes));\n    let amount: string;\n\n    if (\"Some\" in decoded && decoded.Some) {\n      amount = decoded.Some;\n    } else if (\"None\" in decoded && decoded.None === true) {\n      amount = \"0\"; // Use \"0\" if decoded.None is true\n    } else {\n      throw new Error(\"Decoded amount has an invalid shape\");\n    }\n\n    const amountInMist = amount.toString();\n    const amountInSui = new BigNumber(amount).div(SUI_DENOMINATOR).toString();\n\n    return { mist: amountInMist, sui: amountInSui };\n  }\n\n  public async getClaimAmount({ poolObjectId, affectedAddress }: { poolObjectId: string; affectedAddress: string }) {\n    const [normalRefund, boostedRefund] = await Promise.all([\n      this.getClaimAmountNormal({ poolObjectId, affectedAddress }),\n      this.getClaimAmountBoosted({ poolObjectId, affectedAddress }),\n    ]);\n\n    return { normalRefund, boostedRefund };\n  }\n\n  public async getBoostedClaimCap({ ownerAddress, newAddress }: { ownerAddress: string; newAddress: string }): Promise<{\n    boostedClaimCapObjectId: string | null;\n    isAnyBoostedClaimCapExists: boolean;\n    boostedClaimCapNotAssociatedWithNewAddressObjectId: string | null;\n  }> {\n    const allBoostedClaimCapObjects = await getAllOwnedObjects({\n      provider: this.provider,\n      options: {\n        owner: ownerAddress,\n        // TODO: Check for correctness\n        // Because this might not work in case of upgraded package id, so as a solution,\n        // we need to use another filter, which would allow to fetch `BoostedClaimCap` for multiple package addresses\n        filter: { StructType: RefundManagerSingleton.BOOSTER_OBJECT_TYPE },\n        options: {\n          showContent: true,\n          showType: true,\n        },\n      },\n    });\n\n    const allBoostedClaimCapListRaw = allBoostedClaimCapObjects as unknown;\n\n    if (!Array.isArray(allBoostedClaimCapListRaw)) {\n      throw new Error(\"[getBoostedClaimCap] Wrong shape returned for get boosted claim cap request\");\n    }\n\n    const listOfObjectClaimCaps = allBoostedClaimCapListRaw.filter((el): el is BoostedClaimCapType =>\n      isBoostedClaimCap(el),\n    );\n\n    // We should make sure that boosted claim cap is related to the new address that was provided\n    // Otherwise, ignoring the new address, we'll return the boosted claim cap\n    // which might not be related to the client\n    const boostedClaimCapsAssociatedWithNewAddress = listOfObjectClaimCaps.filter(\n      (el) => el.data.content.fields.new_address === newAddress,\n    );\n\n    //\n    const boostedClaimCapsNotAssociatedWithNewAddress = listOfObjectClaimCaps.filter(\n      (el) => el.data.content.fields.new_address !== newAddress,\n    );\n\n    const isAnyBoostedClaimCapExists =\n      listOfObjectClaimCaps.length > 0 || boostedClaimCapsAssociatedWithNewAddress.length > 0;\n\n    // We can pick any of the associated with the user and new address boosted claim cap\n    const boostedClaimCapObject = boostedClaimCapsAssociatedWithNewAddress[0];\n\n    const boostedClaimCapNotAssociatedWithNewAddress = boostedClaimCapsNotAssociatedWithNewAddress[0];\n\n    // We should return related to new address\n    return {\n      boostedClaimCapObjectId: boostedClaimCapObject?.data?.objectId ?? null,\n      isAnyBoostedClaimCapExists,\n      boostedClaimCapNotAssociatedWithNewAddressObjectId:\n        boostedClaimCapNotAssociatedWithNewAddress?.data?.objectId ?? null,\n    };\n  }\n\n  public static getReturnBoosterCapTransaction({\n    transaction,\n    boostedClaimCap,\n    poolObjectId,\n  }: {\n    transaction?: TransactionBlock;\n    boostedClaimCap: ObjectArg;\n    poolObjectId: ObjectArg;\n  }) {\n    const tx = transaction ?? new TransactionBlock();\n\n    const txRes = tx.moveCall({\n      target: `${RefundManagerSingleton.REFUND_PACKAGE_ADDRESS}::booster::return_booster_cap`,\n      typeArguments: [],\n      arguments: [obj(tx, boostedClaimCap), obj(tx, poolObjectId)],\n    });\n\n    tx.setGasBudget(RefundManagerSingleton.REFUND_GAS_BUGET);\n\n    return { tx, txRes };\n  }\n\n  public static getReclaimFundsTransaction({ poolObjectId }: { poolObjectId: ObjectArg }) {\n    const tx = new TransactionBlock();\n\n    const txRes = tx.moveCall({\n      target: `${RefundManagerSingleton.REFUND_PACKAGE_ADDRESS}::refund::reclaim_funds`,\n      typeArguments: [],\n      arguments: [obj(tx, poolObjectId)],\n    });\n\n    tx.setGasBudget(RefundManagerSingleton.REFUND_GAS_BUGET);\n\n    return { tx, txRes };\n  }\n\n  public static getAllowBoostedClaim({\n    publisherObjectId,\n    poolObjectId,\n    affectedAddress,\n    newAddress,\n\n    transaction,\n  }: {\n    publisherObjectId: string;\n    poolObjectId: string;\n    affectedAddress: string;\n    newAddress: string;\n\n    transaction?: TransactionBlock;\n  }) {\n    const tx = transaction ?? new TransactionBlock();\n\n    const txRes = tx.moveCall({\n      target: `${RefundManagerSingleton.REFUND_PACKAGE_ADDRESS}::booster::allow_boosted_claim`,\n      typeArguments: [],\n      arguments: [obj(tx, publisherObjectId), obj(tx, poolObjectId), tx.pure(affectedAddress), tx.pure(newAddress)],\n    });\n\n    tx.setGasBudget(RefundManagerSingleton.REFUND_GAS_BUGET);\n\n    return { tx, txRes };\n  }\n\n  public static getClaimRefundBoostedTransaction({\n    boostedClaimCap,\n    poolObjectId,\n    clock = SUI_CLOCK_OBJECT_ID,\n    userRinbotRefundDestinationAddress,\n\n    transaction,\n  }: {\n    boostedClaimCap: ObjectArg;\n    poolObjectId: ObjectArg;\n    clock?: ObjectArg;\n    userRinbotRefundDestinationAddress: ObjectArg;\n\n    transaction?: TransactionBlock;\n  }) {\n    const tx = transaction ?? new TransactionBlock();\n\n    const txRes = tx.moveCall({\n      target: `${RefundManagerSingleton.REFUND_PACKAGE_ADDRESS}::booster::claim_refund_boosted`,\n      typeArguments: [],\n      arguments: [\n        obj(tx, boostedClaimCap),\n        obj(tx, poolObjectId),\n        tx.pure(userRinbotRefundDestinationAddress),\n        obj(tx, clock),\n      ],\n    });\n\n    tx.setGasBudget(RefundManagerSingleton.REFUND_GAS_BUGET);\n\n    return { tx, txRes };\n  }\n\n  public static getMessageForBoostedRefund({\n    poolObjectId,\n    affectedAddress,\n    newAddress,\n  }: {\n    poolObjectId: string;\n    affectedAddress: string;\n    newAddress: string;\n  }) {\n    // Convert string values to hexadecimal buffers inline\n    const affectedAddressBytes = hexStringToByteArray(affectedAddress);\n    const newAddressBytes = hexStringToByteArray(newAddress);\n    const poolIdBytes = hexStringToByteArray(poolObjectId);\n\n    // Construct the message by concatenating the byte arrays\n    const msg = new Uint8Array(affectedAddressBytes.length + newAddressBytes.length + poolIdBytes.length);\n    msg.set(affectedAddressBytes, 0);\n    msg.set(newAddressBytes, affectedAddressBytes.length);\n    msg.set(poolIdBytes, affectedAddressBytes.length + newAddressBytes.length);\n\n    return { bytes: msg, hex: Buffer.from(msg).toString(\"hex\") };\n  }\n\n  public static async signMessageSignatureForBoostedRefund({\n    keypair,\n    poolObjectId,\n    affectedAddress,\n    newAddress,\n  }: {\n    keypair: Keypair;\n    poolObjectId: string;\n    affectedAddress: string;\n    newAddress: string;\n  }): Promise<SignatureWithBytes> {\n    const message = RefundManagerSingleton.getMessageForBoostedRefund({ poolObjectId, affectedAddress, newAddress });\n    const signedMessage = await keypair.signPersonalMessage(message.bytes);\n\n    return signedMessage;\n  }\n\n  /*\n  @throws an error in case signature is not valid\n  */\n  public static async verifySignedMessageForBoostedRefund({\n    poolObjectId,\n    affectedAddress,\n    newAddress,\n\n    signedMessageSignature,\n  }: {\n    poolObjectId: string;\n    newAddress: string;\n    affectedAddress: string;\n\n    signedMessageSignature: string;\n  }) {\n    const targetMessage = RefundManagerSingleton.getMessageForBoostedRefund({\n      poolObjectId,\n      affectedAddress,\n      newAddress,\n    });\n\n    const signedPublicKey = await verifyPersonalMessage(targetMessage.bytes, signedMessageSignature);\n\n    if (affectedAddress !== signedPublicKey.toSuiAddress()) {\n      throw new Error(\"Affected address is different from the signer of the message\");\n    }\n\n    return true;\n  }\n}\n","/**\n * Converts a hexadecimal string to a Uint8Array.\n *\n * @param {string} hexString - The hexadecimal string to convert.\n * @return {Uint8Array} - The resulting byte array.\n */\nexport function hexStringToByteArray(hexString: string): Uint8Array {\n  // Remove the \"0x\" prefix if present\n  const normalizedHexString = hexString.startsWith(\"0x\") ? hexString.substring(2) : hexString;\n\n  const byteArray = new Uint8Array(normalizedHexString.length / 2);\n  for (let i = 0; i < normalizedHexString.length; i += 2) {\n    byteArray[i / 2] = parseInt(normalizedHexString.substring(i, i + 2), 16);\n  }\n  return byteArray;\n}\n\nexport type DecodedAmount = { Some?: string } | { None?: boolean };\n\nexport type BoostedClaimCapType = {\n  data: {\n    objectId: string;\n    content: {\n      dataType: string;\n      type: string;\n      hasPublicTransfer: boolean;\n      fields: {\n        id: { id: string };\n        new_address: string;\n      };\n    };\n  };\n};\n\nexport enum RefundPoolPhase {\n  AddressAddition = 1, // Phase for adding addresses\n  Funding = 2, // Phase for funding\n  Claim = 3, // Phase for claiming refunds\n  Reclaim = 4, // Phase for reclaiming refunds\n}\n\n// eslint-disable-next-line require-jsdoc\nexport function isBoostedClaimCap(obj: unknown): obj is BoostedClaimCapType {\n  if (typeof obj !== \"object\" || obj === null) {\n    return false;\n  }\n\n  if (!(\"data\" in obj) || !obj.data || typeof obj.data !== \"object\") {\n    return false;\n  }\n\n  const objectData = obj.data;\n\n  if (!(\"objectId\" in objectData) || typeof objectData.objectId !== \"string\") {\n    return false;\n  }\n\n  if (!(\"content\" in objectData) || objectData.content === null || typeof objectData.content !== \"object\") {\n    return false;\n  }\n\n  const content = objectData.content;\n\n  return (\n    \"dataType\" in content &&\n    \"type\" in content &&\n    \"fields\" in content &&\n    typeof content.fields === \"object\" &&\n    content.fields !== null &&\n    \"id\" in content.fields &&\n    typeof content.dataType === \"string\" &&\n    typeof content.type === \"string\" &&\n    typeof content.fields.id === \"object\" &&\n    content.fields.id !== null &&\n    \"id\" in content.fields.id &&\n    typeof content.fields.id.id === \"string\" &&\n    \"new_address\" in content.fields &&\n    typeof content.fields.new_address === \"string\"\n  );\n}\n","import { GetOwnedObjectsParams, PaginatedObjectsResponse, SuiClient, SuiObjectResponse } from \"@mysten/sui.js/client\";\n\n/**\n * Retrieves all objects owned from the SuiClient based on provided owner address, respecting limitations.\n * @throws {Error} If any error occurs during the retrieval process.\n * @description\n * The function fetches objects from SuiClient based on the provided owner address.\n * It respects the limitation of `getOwnedObjects` (50 objectIds per request) by\n * splitting the requests into chunks.\n */\nexport async function getAllOwnedObjects({\n  provider,\n  options,\n}: {\n  provider: SuiClient;\n  options: GetOwnedObjectsParams;\n}) {\n  const allOwnedObjects: SuiObjectResponse[] = [];\n  let nextCursor: string | undefined | null = null;\n  let objects: PaginatedObjectsResponse = await provider.getOwnedObjects(options);\n\n  // Fetching and combining part\n  while (objects.hasNextPage) {\n    const userObjects: SuiObjectResponse[] = objects.data;\n    allOwnedObjects.push(...userObjects);\n\n    nextCursor = objects.nextCursor;\n    objects = await provider.getOwnedObjects({\n      ...options,\n      cursor: nextCursor,\n    });\n  }\n\n  const userObjects: SuiObjectResponse[] = objects.data;\n  allOwnedObjects.push(...userObjects);\n\n  return allOwnedObjects;\n}\n","/**\n * Convert slippage from percentage to absolute value.\n *\n * @param {number} slippagePercentage - The slippage percentage to be converted.\n * @return {number} Returns the absolute slippage value as a decimal between 0 and 1.\n * @throws {Error} Throws an error if the slippage is not correct or if it's not a number.\n\n * @example\n * const slippagePercentage = 50;\n * const absoluteSlippage = convertSlippage(slippagePercentage);\n * console.log(\"Absolute slippage:\", absoluteSlippage); // 0.5\n */\nexport function convertSlippage(slippagePercentage: number): number {\n  if (typeof slippagePercentage !== \"number\" || isNaN(slippagePercentage)) {\n    throw new Error(\"Slippage percentage must be a valid number.\");\n  }\n\n  if (slippagePercentage < 0 || slippagePercentage >= 100) {\n    throw new Error(\"Slippage percentage must be between 0 (inclusive) and 100 (exclusive).\");\n  }\n\n  const absoluteSlippage = slippagePercentage / 100;\n  return absoluteSlippage;\n}\n","import BigNumber from \"bignumber.js\";\n\n/**\n * Convert an amount in raw (float format) to BN string format based on the specified decimal points.\n *\n * @param {string} amount - The amount in raw (float format).\n * @param {number} decimals - The number of decimal points for the currency.\n * @return {number} Returns the amount in BN string format.\n * @throws {Error} Throws an error if the resulting amount is not a BN string or provided decimals is not valid.\n * @example\n * const SUI_DECIMALS = 9;\n * const amountInRaw = '123.456789';\n * const amountInBNFormat = convertToBNFormat(amountInRaw, SUI_DECIMALS);\n * console.log(\"Amount in BN format:\", amountInBNFormat); // 123456789000\n */\nexport function convertToBNFormat(amount: string, decimals: number): string {\n  if (decimals < 0) {\n    throw new Error(\"Decimal points must be a non-negative integer.\");\n  }\n\n  if (!Number.isInteger(decimals)) {\n    throw new Error(\"Decimal points must be an integer.\");\n  }\n\n  const bnAmount = new BigNumber(amount).multipliedBy(10 ** decimals);\n\n  if (isNaN(bnAmount.toNumber())) {\n    throw new Error(`Invalid decimal conversion: Decimals ${decimals} is not correct for the given token.`);\n  }\n\n  return bnAmount.toString();\n}\n","import { TOKEN_ADDRESS_BASE_REGEX } from \"../common\";\n\nconst tokenAddressRegex = new RegExp(`^${TOKEN_ADDRESS_BASE_REGEX.source}$`);\n\nexport type TokenAddress = `0x${string}::${string}::${string}`;\n\n/**\n * Checks if a string has the format of a valid token address.\n *\n * @param {string} str - The input string to be validated.\n * @return {boolean} Returns true if the input string has the valid token address format.\n * @throws {TypeError} Throws a type error if the input string is not a valid token address.\n * @example\n * const validAddress: TokenAddress = \"0x06864a6f921804860930db6ddbe2e16acdf8504495ea7481637a1c8b9a8fe54b::sui::SUI\";\n * if (isValidTokenAddress(validAddress)) {\n *   console.log(\"Valid token address:\", validAddress);\n * } else {\n *   console.log(\"Invalid token address\");\n * }\n */\nexport function isValidTokenAddress(str: string): str is TokenAddress {\n  return tokenAddressRegex.test(str);\n}\n","import { LONG_SUI_COIN_TYPE } from \"../common\";\n\n/**\n * Ensures a SUI address is in its canonical form.\n * @param {string} address - The address to normalize.\n * @return {string} The canonical form of the address.\n */\nexport function normalizeSuiCoinType(address: string): string {\n  // If the address is already in its canonical form, just return it. Else return canonical one.\n  if (address === LONG_SUI_COIN_TYPE) {\n    return address;\n  } else {\n    return LONG_SUI_COIN_TYPE;\n  }\n}\n","import { SuiClient, SuiClientOptions } from \"@mysten/sui.js/client\";\n\nexport const getSuiProvider = (suiProviderOptions: SuiClientOptions) => {\n  const provider = new SuiClient(suiProviderOptions);\n\n  return provider;\n};\n","import BigNumber from \"bignumber.js\";\n\n/**\n * Checks if the provided amount is a valid token amount.\n * @param {Object} params - The parameters object.\n * @param {string} params.amount - The amount to be validated as a string.\n * @param {string} params.maxAvailableAmount - The maximum allowed token amount as a string.\n * @param {string} params.minAvailableAmount - The minimum allowed token amount as a string.\n * @param {number} params.decimals - The number of decimals for precision in conversion.\n * @return {{ isValid: boolean, reason: string }} An object with isValid boolean and reason string.\n */\nexport const isValidTokenAmount = ({\n  amount,\n  maxAvailableAmount,\n  decimals,\n  minAvailableAmount = \"0\",\n}: {\n  amount: string;\n  maxAvailableAmount: string;\n  decimals: number;\n  minAvailableAmount?: string;\n}): { isValid: boolean; reason: string } => {\n  // Convert maxAvailableAmount and minAvailableAmount to BigNumber\n  const maxAvailableAmountBigInt = new BigNumber(maxAvailableAmount).times(10 ** decimals);\n  const minAvailableAmountBigInt = new BigNumber(minAvailableAmount).times(10 ** decimals);\n\n  // Convert amount to BigNumber and multiply by decimals\n  const amountNumber = new BigNumber(amount).times(10 ** decimals);\n\n  // Check if the amount is a valid number, including NaN\n  if (isNaN(amountNumber.toNumber())) {\n    return { isValid: false, reason: \"Amount must be a valid number.\" };\n  }\n\n  // Check if the amount is non-negative\n  if (amountNumber.isLessThanOrEqualTo(0)) {\n    return { isValid: false, reason: \"Amount must be a positive value.\" };\n  }\n\n  // Check if the amount does not exceed the minimum available amount\n  if (amountNumber.isLessThan(minAvailableAmountBigInt)) {\n    return { isValid: false, reason: \"Amount exceeds the minimum available amount.\" };\n  }\n\n  // Check if the amount does not exceed the maximum available amount\n  if (amountNumber.isGreaterThan(maxAvailableAmountBigInt)) {\n    return { isValid: false, reason: \"Amount exceeds the maximum available amount.\" };\n  }\n\n  // The amount is valid\n  return { isValid: true, reason: \"Valid amount.\" };\n};\n","import { TransactionBlock } from \"@mysten/sui.js/transactions\";\n\nexport const transactionFromSerializedTransaction = (serializedTransaction: string) => {\n  const txBlock = new TransactionBlock(TransactionBlock.from(serializedTransaction));\n\n  return txBlock;\n};\n","/* eslint-disable new-cap */\nimport { SuiTransactionBlockResponse } from \"@mysten/sui.js/client\";\nimport { TransactionBlock } from \"@mysten/sui.js/transactions\";\nimport { Aftermath, CoinMetadaWithInfo, Pool, RouterCompleteTradeRoute } from \"aftermath-ts-sdk\";\nimport BigNumber from \"bignumber.js\";\nimport { EventEmitter } from \"../../emitters/EventEmitter\";\nimport { CoinManagerSingleton } from \"../../managers/coin/CoinManager\";\nimport { CoinAssetData, CommonCoinData, UpdatedCoinsCache } from \"../../managers/types\";\nimport { InMemoryStorageSingleton } from \"../../storages/InMemoryStorage\";\nimport { Storage } from \"../../storages/types\";\nimport { getCoinsAndPathsCaches } from \"../../storages/utils/getCoinsAndPathsCaches\";\nimport { storeCaches } from \"../../storages/utils/storeCaches\";\nimport { exitHandlerWrapper } from \"../common\";\nimport { CacheOptions, CoinsCache, CommonPoolData, IPoolProvider, PathsCache } from \"../types\";\nimport { convertSlippage } from \"../utils/convertSlippage\";\nimport { getCoinInfoFromCache } from \"../utils/getCoinInfoFromCache\";\nimport { removeDecimalPart } from \"../utils/removeDecimalPart\";\nimport { getCreatePoolCapIdAndLpCoinType, getPoolObjectIdFromTransactionResult } from \"./create-pool-utils\";\nimport {\n  AftermathOptions,\n  CreateLpCoinInput,\n  CreatePoolInput,\n  GetWeightsInput,\n  OwnedPoolInfo,\n  SmartOutputAmountData,\n} from \"./types\";\nimport {\n  getOwnedPoolInfosFromPools,\n  getPathMapAndCoinTypesSet,\n  isApiResponseValid,\n  isCoinMetadaWithInfoApiResponseValid,\n} from \"./utils\";\n\n/**\n * @class AftermathSingleton\n * @extends EventEmitter\n * @implements {IPoolProvider<AftermathSingleton>}\n * @description Singleton class for Aftermath.\n *\n * Note: If using `lazyLoading: true` with any storage configuration in a serverless/cloud functions environment,\n * be aware that each invocation of your cloud function will start cache population from scratch.\n * This may lead to unexpected behavior when using different SDK methods. To avoid this and minimize the time\n * for cache population, consider using `lazyLoading: false` along with passing a persistent\n * storage adapter (external, e.g., Redis or any kind of DB) to the ProviderSingleton.\n */\nexport class AftermathSingleton extends EventEmitter implements IPoolProvider<AftermathSingleton> {\n  private static _instance: AftermathSingleton | undefined;\n  public static AFTERMATH_POOL_URL = \"https://aftermath.finance/pools\";\n  public isSmartRoutingAvailable = true;\n  public providerName = \"Aftermath\";\n  public aftermathSdk: Aftermath;\n  public poolsCache: Pool[] = [];\n  public pathsCache: PathsCache = new Map();\n  public coinsCache: CoinsCache = new Map();\n  private cacheOptions: CacheOptions;\n  private intervalId: NodeJS.Timeout | undefined;\n  private storage: Storage;\n\n  /**\n   * @constructor\n   * @param {Omit<AftermathOptions, \"lazyLoading\">} options - Options for AftermathSingleton.\n   */\n  private constructor(options: Omit<AftermathOptions, \"lazyLoading\">) {\n    super();\n    this.aftermathSdk = new Aftermath(\"MAINNET\");\n    const { updateIntervally = true, ...restCacheOptions } = options.cacheOptions;\n    this.cacheOptions = { updateIntervally, ...restCacheOptions };\n    this.storage = options.cacheOptions.storage ?? InMemoryStorageSingleton.getInstance();\n  }\n\n  /**\n   * @static\n   * @method getInstance\n   * @async\n   * @param {AftermathOptions} [options] - Options for AftermathSingleton instance.\n   * @return {Promise<AftermathSingleton>}\n   * @throws Error if options are not provided.\n   */\n  public static async getInstance(options?: AftermathOptions): Promise<AftermathSingleton> {\n    if (!AftermathSingleton._instance) {\n      if (options === undefined) {\n        throw new Error(\"[Aftermath] Options are required in arguments to create instance.\");\n      }\n\n      const { cacheOptions, lazyLoading = true } = options;\n\n      const instance = new AftermathSingleton({ cacheOptions });\n      lazyLoading ? instance.init() : await instance.init();\n      AftermathSingleton._instance = instance;\n    }\n\n    return AftermathSingleton._instance;\n  }\n\n  /**\n   * @private\n   * @method init\n   * @description Initializes the AftermathSingleton instance.\n   * @return {Promise<void>}\n   */\n  private async init() {\n    console.debug(`[${this.providerName}] Singleton initiating.`);\n    await this.fillCacheFromStorage();\n    await this.updateCaches();\n    this.cacheOptions.updateIntervally && this.updateCachesIntervally();\n\n    this.bufferEvent(\"cachesUpdate\", this.getCoins());\n  }\n\n  /**\n   * Fills the cache from storage asynchronously.\n   *\n   * @private\n   * @return {Promise<void>} A promise that resolves when the cache is filled from storage.\n   */\n  private async fillCacheFromStorage(): Promise<void> {\n    try {\n      const { coinsCache, pathsCache } = await getCoinsAndPathsCaches({\n        storage: this.storage,\n        provider: this.providerName,\n        updateCacheInterval: this.cacheOptions.updateIntervalInMs,\n      });\n\n      this.coinsCache = coinsCache;\n      this.pathsCache = pathsCache;\n    } catch (error) {\n      console.error(`[${this.providerName}] fillCacheFromStorage failed:`, error);\n    }\n  }\n\n  /**\n   * Checks if the storage cache is empty.\n   *\n   * @private\n   * @return {boolean} True if the storage cache is empty, false otherwise.\n   */\n  private isStorageCacheEmpty() {\n    const isCacheEmpty = this.coinsCache.size === 0 || this.pathsCache.size === 0;\n\n    return isCacheEmpty;\n  }\n\n  /**\n   * @private\n   * @method updateCaches\n   * @description Updates caches.\n   * @return {Promise<void>}\n   */\n  private async updateCaches({ force }: { force: boolean } = { force: false }): Promise<void> {\n    const isCacheEmpty = this.isStorageCacheEmpty();\n\n    if (isCacheEmpty || force) {\n      try {\n        await this.updatePoolsCache();\n        await this.updatePathsAndCoinsCache();\n        this.emit(\"cachesUpdate\", this.getCoins());\n\n        await storeCaches({\n          provider: this.providerName,\n          storage: this.storage,\n          coinsCache: this.getCoins(),\n          pathsCache: this.getPaths(),\n        });\n\n        console.debug(\"[Aftermath] Caches are updated and stored.\");\n      } catch (error) {\n        console.error(\"[Aftermath] Caches update failed:\", error);\n      }\n    }\n  }\n\n  /**\n   * @private\n   * @method updateCachesIntervally\n   * @description Updates caches periodically.\n   * @return {void}\n   */\n  private updateCachesIntervally(): void {\n    let isUpdatingCurrently = false;\n    this.intervalId = setInterval(async () => {\n      try {\n        if (isUpdatingCurrently) {\n          return;\n        }\n        isUpdatingCurrently = true;\n        await this.updateCaches({ force: true });\n      } finally {\n        isUpdatingCurrently = false;\n      }\n    }, this.cacheOptions.updateIntervalInMs);\n\n    exitHandlerWrapper({ intervalId: this.intervalId, providerName: this.providerName });\n  }\n\n  /**\n   * @private\n   * @method updatePoolsCache\n   * @description Updates pools cache.\n   * @return {Promise<void>}\n   */\n  private async updatePoolsCache(): Promise<void> {\n    const poolsInstance = this.aftermathSdk.Pools();\n    const pools: Pool[] = await poolsInstance.getAllPools();\n    const isValidPoolsResponse = isApiResponseValid(pools);\n\n    if (!isValidPoolsResponse) {\n      console.error(\"[Aftermath] Pools response:\", pools);\n      throw new Error(\"Pools response from API is not valid\");\n    }\n\n    this.poolsCache = pools;\n  }\n\n  /**\n   * @private\n   * @method updatePathsAndCoinsCache\n   * @description Updates paths and coins cache.\n   * @return {Promise<void>}\n   */\n  private async updatePathsAndCoinsCache(): Promise<void> {\n    const { pathMap, coinTypesSet } = getPathMapAndCoinTypesSet(this.poolsCache);\n    this.pathsCache = pathMap;\n\n    await Promise.all(\n      Array.from(coinTypesSet.values()).map(async (coinType: string) => {\n        try {\n          const coin = this.aftermathSdk.Coin();\n          const metadata: CoinMetadaWithInfo = await coin.getCoinMetadata(coinType);\n\n          const isValidCoinMetadataResponse = isCoinMetadaWithInfoApiResponseValid(metadata);\n\n          if (isValidCoinMetadataResponse) {\n            this.coinsCache.set(coinType, { symbol: metadata.symbol, type: coinType, decimals: metadata.decimals });\n          }\n        } catch (error) {\n          console.error(`[Aftermath] Error while fetching metadata about coin ${coinType}:`, error);\n        }\n      }),\n    );\n  }\n\n  /**\n   * @public\n   * @method getPool\n   * @description Gets the pool with the specified coin types.\n   * @param {string} coinTypeA - Coin type A.\n   * @param {string} coinTypeB - Coin type B.\n   * @return {Pool} The pool object.\n   */\n  public getPool(coinTypeA: string, coinTypeB: string): Pool {\n    const pool: Pool | undefined = this.poolsCache.find(\n      (pool: Pool) =>\n        Object.keys(pool.pool.coins).includes(coinTypeA) && Object.keys(pool.pool.coins).includes(coinTypeB),\n    );\n\n    if (!pool) {\n      throw new Error(`[Aftermath] Cannot find pool with coinTypeA \"${coinTypeA}\" and coinTypeB \"${coinTypeB}\".`);\n    }\n\n    return pool;\n  }\n\n  /**\n   * @public\n   * @method getPools\n   * @description Gets all pools.\n   * @return {Pool[]} Array of pools.\n   */\n  public getPools(): Pool[] {\n    return this.poolsCache;\n  }\n\n  /**\n   * @public\n   * @method getCoins\n   * @description Gets the updated coins cache.\n   * @return {UpdatedCoinsCache} Updated coins cache.\n   */\n  public getCoins(): UpdatedCoinsCache {\n    const allCoins: CommonCoinData[] = Array.from(this.coinsCache.values());\n    return { provider: this.providerName, data: allCoins };\n  }\n\n  /**\n   * @public\n   * @method getPaths\n   * @description Gets the paths cache.\n   * @return {Map<string, CommonPoolData>} Paths cache.\n   */\n  public getPaths(): Map<string, CommonPoolData> {\n    return this.pathsCache;\n  }\n\n  /**\n   * @public\n   * @method getRouteData\n   * @description Gets route data.\n   * @param {Object} params - Parameters for route data.\n   * @param {string} params.coinTypeFrom - Coin type from.\n   * @param {string} params.coinTypeTo - Coin type to.\n   * @param {string} params.inputAmount - Input amount.\n   * @return {Promise<{ outputAmount: bigint, route: RouterCompleteTradeRoute }>} Route data.\n   */\n  public async getRouteData({\n    coinTypeFrom,\n    coinTypeTo,\n    inputAmount,\n  }: {\n    coinTypeFrom: string;\n    coinTypeTo: string;\n    inputAmount: string;\n    slippagePercentage: number;\n    publicKey: string;\n  }) {\n    const { outputAmount, route } = await this.getSmartOutputAmountData(coinTypeFrom, coinTypeTo, inputAmount);\n\n    return { outputAmount, route };\n  }\n\n  /**\n   * @public\n   * @method getDirectOutputAmount\n   * @description Calculates the direct output amount for a given input amount and coin types.\n   * @param {Pool} pool - The pool object.\n   * @param {string} inputAmount - The input amount.\n   * @param {string} coinTypeFrom - The coin type from.\n   * @param {string} coinTypeTo - The coin type to.\n   * @return {bigint} The direct output amount.\n   */\n  public getDirectOutputAmount(pool: Pool, inputAmount: string, coinTypeFrom: string, coinTypeTo: string): bigint {\n    const coinFromDecimals: number | undefined = pool.pool.coins[coinTypeFrom].decimals;\n\n    if (coinFromDecimals === undefined) {\n      throw new Error(`[Aftermath] Coin with type \"${coinTypeFrom}\" has no decimals.`);\n    }\n\n    const coinInAmountBigNumber = new BigNumber(inputAmount).multipliedBy(10 ** coinFromDecimals);\n    const coinInAmount = BigInt(coinInAmountBigNumber.toString());\n    const outputAmount: bigint = pool.getTradeAmountOut({\n      coinInAmount,\n      coinInType: coinTypeFrom,\n      coinOutType: coinTypeTo,\n    });\n\n    return outputAmount;\n  }\n\n  /**\n   * @private\n   * @method getSmartOutputAmountData\n   * @description Retrieves smart output amount data for the given coin types and input amount.\n   * @param {string} coinTypeFrom - The coin type from.\n   * @param {string} coinTypeTo - The coin type to.\n   * @param {string} inputAmount - The input amount.\n   * @return {Promise<SmartOutputAmountData>} A Promise that resolves to smart output amount data.\n   */\n  private async getSmartOutputAmountData(\n    coinTypeFrom: string,\n    coinTypeTo: string,\n    inputAmount: string,\n  ): Promise<SmartOutputAmountData> {\n    const coinTypeFromInfo: CommonCoinData | undefined = getCoinInfoFromCache(coinTypeFrom, this.coinsCache);\n\n    if (coinTypeFromInfo === undefined) {\n      throw new Error(`[Aftermath] Cannot find info about coin \"${coinTypeFrom}\".`);\n    }\n\n    const inputCoinDecimals: number = coinTypeFromInfo.decimals;\n    const inputAmountWithDecimalsBigNumber = new BigNumber(inputAmount).multipliedBy(10 ** inputCoinDecimals);\n    // We do removing the decimal part in case client send number with more decimal part\n    // than this particular token has decimal places allowed (`inputCoinDecimals`)\n    // That's prevent situation when casting\n    // BigNumber to BigInt fails with error (\"Cannot convert 183763562.1 to a BigInt\")\n    const inputAmountWithoutExceededDecimalPart = removeDecimalPart(inputAmountWithDecimalsBigNumber);\n    const inputAmountWithDecimals = BigInt(inputAmountWithoutExceededDecimalPart.toString());\n\n    const routerInstance = this.aftermathSdk.Router();\n    const route: RouterCompleteTradeRoute = await routerInstance.getCompleteTradeRouteGivenAmountIn({\n      coinInType: coinTypeFrom,\n      coinOutType: coinTypeTo,\n      coinInAmount: inputAmountWithDecimals,\n    });\n\n    const smartOutputAmount: bigint = route.coinOut.amount;\n\n    return { outputAmount: smartOutputAmount, route };\n  }\n\n  /**\n   * @public\n   * @method getSwapTransaction\n   * @description Retrieves the swap transaction for the given route and public key.\n   * @param {RouterCompleteTradeRoute} route - The complete trade route.\n   * @param {string} publicKey - The public key.\n   * @param {number} [slippagePercentage=10] - The slippage percentage.\n   * @return {Promise<TransactionBlock>} A Promise that resolves to the swap transaction.\n   */\n  public async getSwapTransaction({\n    route,\n    publicKey,\n    slippagePercentage = 10,\n  }: {\n    route: RouterCompleteTradeRoute;\n    publicKey: string;\n    slippagePercentage: number;\n  }): Promise<TransactionBlock> {\n    const absoluteSlippage: number = convertSlippage(slippagePercentage);\n\n    const routerInstance = this.aftermathSdk.Router();\n    const modernTxBlock = await routerInstance.getTransactionForCompleteTradeRoute({\n      walletAddress: publicKey,\n      completeRoute: route,\n      slippage: absoluteSlippage,\n    });\n\n    const txBlock = new TransactionBlock(TransactionBlock.from(modernTxBlock.serialize()));\n\n    return txBlock;\n  }\n\n  /**\n   * Gets a transaction block for swapping tokens based on provided swap data.\n   *\n   * Note: This method is not implemented yet.\n   *\n   * @public\n   * @async\n   * @param {SwapRequiredData} swapRequiredData - The required data for the swap.\n   * @param {string} publicKey - The public key of the user.\n   * @param {number} [slippagePercentage=10] - The slippage percentage.\n   * @return {Promise<TransactionBlock>} A Promise that resolves to a TransactionBlock.\n   */\n  public async getSwapTransactionDoctored({\n    route,\n    publicKey,\n    slippagePercentage = 10,\n  }: {\n    route: RouterCompleteTradeRoute;\n    publicKey: string;\n    slippagePercentage: number;\n  }): Promise<TransactionBlock> {\n    throw new Error(`[${this.providerName}] getSwapTransactionDoctored method not implemented`);\n  }\n\n  /**\n   * Retrieves a transaction block for creating an LP coin.\n   *\n   * @public\n   * @static\n   * @param {CreateLpCoinInput} input - The input parameters for creating the LP coin transaction.\n   * @param {string} input.publicKey - The public key associated with the wallet.\n   * @param {number} input.lpCoinDecimals - The number of decimal places for the LP coin.\n   * @return {Promise<TransactionBlock>} A promise that resolves to a transaction block representing the\n   * creation of the LP coin.\n   */\n  public static async getCreateLpCoinTransaction({\n    publicKey,\n    lpCoinDecimals,\n  }: CreateLpCoinInput): Promise<TransactionBlock> {\n    const sdk = new Aftermath(\"MAINNET\");\n    const pools = sdk.Pools();\n    const createLpCoinTransaction = await pools.getPublishLpCoinTransaction({\n      walletAddress: publicKey,\n      lpCoinDecimals: lpCoinDecimals,\n    });\n\n    return new TransactionBlock(TransactionBlock.from(createLpCoinTransaction.serialize()));\n  }\n\n  /**\n   * Retrieves a transaction block for creating a liquidity pool.\n   *\n   * LIMITATION: If client created pool and now wants to create one more with the same coins and the same amounts,\n   * creation will be FAILED. At least one amount must be different from the amount from the existing pool.\n   *\n   * @public\n   * @static\n   * @param {CreatePoolInput} input - The input parameters for creating the pool transaction.\n   * @param {string} input.publicKey - The public key associated with the wallet.\n   * @param {any} input.createLpCoinTransactionResult - The result of the create LP coin transaction.\n   * @param {CoinMetadata} input.lpCoinMetadata - The metadata of the LP coin.\n   * @param {Record<string, CoinMetadata>} input.coinsInfo - Information about the coins involved in the pool.\n   * @param {string} input.poolName - The name of the pool.\n   * @return {Promise<TransactionBlock>} A promise that resolves to a transaction block representing the creation\n   * of the liquidity pool.\n   */\n  public static async getCreatePoolTransaction({\n    publicKey,\n    createLpCoinTransactionResult,\n    lpCoinMetadata,\n    coinsInfo,\n    poolName,\n  }: CreatePoolInput): Promise<TransactionBlock> {\n    const sdk = new Aftermath(\"MAINNET\");\n    const { lpCoinType, createPoolCapId } = getCreatePoolCapIdAndLpCoinType(createLpCoinTransactionResult);\n    const pools = sdk.Pools();\n    const createPoolTransaction = await pools.getCreatePoolTransaction({\n      coinsInfo: Object.values(coinsInfo),\n      createPoolCapId,\n      lpCoinType,\n      lpCoinMetadata,\n      walletAddress: publicKey,\n      // TODO: Implement stable pools creation\n      poolFlatness: 0,\n      poolName,\n      respectDecimals: false,\n      isSponsoredTx: false,\n    });\n\n    return new TransactionBlock(TransactionBlock.from(createPoolTransaction.serialize()));\n  }\n\n  /**\n   * Generates the URL for accessing a liquidity pool based on the result of a create pool transaction.\n   *\n   * @public\n   * @static\n   * @param {SuiTransactionBlockResponse} createPoolTransactionResult - The result of the create pool transaction.\n   * @return {string} The URL for accessing the liquidity pool.\n   */\n  public static getPoolUrl(createPoolTransactionResult: SuiTransactionBlockResponse) {\n    const poolObjectId = getPoolObjectIdFromTransactionResult(createPoolTransactionResult);\n\n    return `${this.AFTERMATH_POOL_URL}/${poolObjectId}`;\n  }\n\n  /**\n   * Retrieves weights for two coins based on their amounts and current prices.\n   *\n   * @public\n   * @static\n   * @param {GetWeightsInput} coinsInfo - Information about the coins and their amounts.\n   * @return {Promise<{ weightA: number, weightB: number }>} A promise that resolves to an object\n   * containing weights for the two coins.\n   */\n  public static async getWeights(coinsInfo: GetWeightsInput): Promise<{ weightA: number; weightB: number }> {\n    const sdk = new Aftermath(\"MAINNET\");\n\n    const { type: coinTypeA, amount: amountA } = coinsInfo.coinA;\n    const { type: coinTypeB, amount: amountB } = coinsInfo.coinB;\n\n    const prices = sdk.Prices();\n    const priceA: number = await prices.getCoinPrice({ coin: coinTypeA });\n    const priceB: number = await prices.getCoinPrice({ coin: coinTypeB });\n\n    // If either of the prices is undefined, further calculations could be unpredictable,\n    // hence returning equal weights of 0.5 for both coins.\n    if (priceA === -1 || priceB === -1) {\n      return { weightA: 0.5, weightB: 0.5 };\n    }\n\n    const usdAmountA = new BigNumber(amountA).multipliedBy(priceA);\n    const usdAmountB = new BigNumber(amountB).multipliedBy(priceB);\n    const usdSum: BigNumber = usdAmountA.plus(usdAmountB);\n\n    let weightA = new BigNumber(usdAmountA.dividedBy(usdSum).toFixed(4));\n    let weightB = new BigNumber(usdAmountB.dividedBy(usdSum).toFixed(4));\n\n    // If the sum of weights is not equal to 1, then the remainder needed to reach 1 is added\n    // to the smaller weight to ensure their combined value equals 1.\n    if (weightA.plus(weightB) !== new BigNumber(1)) {\n      const remainder = new BigNumber(new BigNumber(1).minus(weightA).minus(weightB).toFixed(4));\n\n      if (weightA > weightB) {\n        weightB = weightB.plus(remainder);\n      } else {\n        weightA = weightA.plus(remainder);\n      }\n    }\n\n    return { weightA: weightA.toNumber(), weightB: weightB.toNumber() };\n  }\n\n  /**\n   * Retrieves the maximum and minimum amount of the second coin based on the amount of the first coin.\n   *\n   * NOTE: This method will be used only when both coins have a price retrievable from the API. If at least\n   * one coin lacks a price, it is pointless to limit the amounts of the coins.\n   *\n   * @public\n   * @static\n   * @param {Object} options - The options object.\n   * @param {string} options.coinTypeA - The type of the first coin.\n   * @param {string} options.amountA - The amount of the first coin.\n   * @param {string} options.coinTypeB - The type of the second coin.\n   * @param {number} options.decimalsB - The number of decimal places for the second coin.\n   * @return {Promise<{ minAmountB: string, maxAmountB: string }>} A promise that resolves to an object containing\n   * the minimum and maximum amount of the second coin.\n   */\n  public static async getMaxAndMinSecondCoinAmount({\n    coinTypeA,\n    amountA,\n    coinTypeB,\n    decimalsB,\n  }: {\n    coinTypeA: string;\n    amountA: string;\n    coinTypeB: string;\n    decimalsB: number;\n  }): Promise<{ minAmountB: string; maxAmountB: string }> {\n    const sdk = new Aftermath(\"MAINNET\");\n    const minWeightB = 0.05;\n    const maxWeightB = 0.95;\n\n    const prices = sdk.Prices();\n    const priceA: number = await prices.getCoinPrice({ coin: coinTypeA });\n    const priceB: number = await prices.getCoinPrice({ coin: coinTypeB });\n\n    const usdAmountA = new BigNumber(amountA).multipliedBy(priceA);\n    const minUsdAmountB = new BigNumber(minWeightB)\n      .multipliedBy(usdAmountA)\n      .dividedBy(new BigNumber(1).minus(minWeightB));\n    const maxUsdAmountB = new BigNumber(maxWeightB)\n      .multipliedBy(usdAmountA)\n      .dividedBy(new BigNumber(1).minus(maxWeightB));\n\n    const minAmountB = minUsdAmountB.dividedBy(priceB).toFixed(decimalsB);\n    const maxAmountB = maxUsdAmountB.dividedBy(priceB).toFixed(decimalsB);\n\n    return { minAmountB, maxAmountB };\n  }\n\n  /**\n   * Checks if a coin has a price retrievable from the API.\n   *\n   * @public\n   * @static\n   * @param {string} coinType - The type of the coin to check for price availability.\n   * @return {Promise<boolean>} A promise that resolves to true if the coin has a price retrievable from the\n   * API, otherwise false.\n   */\n  public static async coinHasPrice(coinType: string): Promise<boolean> {\n    const sdk = new Aftermath(\"MAINNET\");\n    const prices = sdk.Prices();\n    const price: number = await prices.getCoinPrice({ coin: coinType });\n\n    return price !== -1;\n  }\n\n  /**\n   * Retrieves information about owned pools.\n   *\n   * @public\n   * @static\n   * @param {CoinAssetData[]} allAssets - An array of all available coin asset data.\n   * @param {CoinManagerSingleton} coinManager - The coin manager instance.\n   * @return {Promise<OwnedPoolInfo[]>} A promise that resolves to an array of information about owned pools.\n   */\n  public static async getOwnedPoolsInfo(\n    allAssets: CoinAssetData[],\n    coinManager: CoinManagerSingleton,\n  ): Promise<OwnedPoolInfo[]> {\n    const lpCoinTypePart = \"af_lp::AF_LP\";\n    const sdk = new Aftermath(\"MAINNET\");\n    const poolsSdk = sdk.Pools();\n\n    const lpCoins: CoinAssetData[] = allAssets.filter((asset) => asset.type.includes(lpCoinTypePart));\n    const poolObjectIdsRaw = (await Promise.all(\n      lpCoins.map((lpCoin) => poolsSdk.getPoolObjectIdForLpCoinType({ lpCoinType: lpCoin.type }))\n    )).flat();\n    const poolObjectIds: string[] = poolObjectIdsRaw.filter((el): el is string => el !== undefined);\n    const pools: Pool[] = await poolsSdk.getPools({ objectIds: poolObjectIds });\n    await Promise.all(pools.map((pool) => pool.getStats()));\n\n    const ownedPoolInfos: OwnedPoolInfo[] = await getOwnedPoolInfosFromPools(pools, coinManager);\n\n    return ownedPoolInfos;\n  }\n\n  /**\n   * Removes the current instance of AftermathSingleton.\n   *\n   * Disclaimer: While this method in this class is marked as public, it is strongly discouraged\n   * to use it directly unless you are certain about the behavior.\n   */\n  public static removeInstance() {\n    AftermathSingleton._instance = undefined;\n  }\n\n  public buildDcaTxBlockAdapter = () => {\n    throw new Error(\"Not implemented\");\n  };\n}\n","import { UpdateCoinsCacheHandler, UpdatedCoinsCache } from \"../managers/types\";\n\n/**\n * @class EventEmitter\n * @description A simple event emitter implementation.\n */\nexport class EventEmitter {\n  private events: Record<string, UpdateCoinsCacheHandler[]> = {};\n  private buffer: { eventName: string; data: UpdatedCoinsCache }[] = [];\n\n  /**\n   * @public\n   * @method on\n   * @description Adds a callback function to an event.\n   * @param {string} eventName - The name of the event.\n   * @param {UpdateCoinsCacheHandler} callback - The callback function to be executed when the event is emitted.\n   */\n  on(eventName: string, callback: UpdateCoinsCacheHandler) {\n    if (!this.events[eventName]) {\n      this.events[eventName] = [];\n    }\n    this.events[eventName].push(callback);\n  }\n\n  /**\n   * @public\n   * @method emit\n   * @description Emits an event and executes all registered callback functions.\n   * @param {string} eventName - The name of the event to be emitted.\n   * @param {UpdatedCoinsCache} arg - The data to be passed to the event handlers.\n   */\n  emit(eventName: string, arg: UpdatedCoinsCache) {\n    if (this.events[eventName]) {\n      this.events[eventName].forEach((callback) => callback(arg));\n    }\n  }\n\n  /**\n   * @public\n   * @method bufferEvent\n   * @description Buffers an event to be emitted later.\n   * @param {string} eventName - The name of the event to be buffered.\n   * @param {UpdatedCoinsCache} data - The data associated with the event.\n   */\n  bufferEvent(eventName: string, data: UpdatedCoinsCache) {\n    this.buffer.push({ eventName, data });\n  }\n\n  /**\n   * @public\n   * @method flushBuffer\n   * @description Flushes the buffered events and emits them.\n   */\n  flushBuffer() {\n    this.buffer.forEach(({ eventName, data }) => this.emit(eventName, data));\n    this.buffer = [];\n  }\n\n  /**\n   * @public\n   * @method getEvents\n   * @description Returns the record of events and their corresponding handlers.\n   * @return {Record<string, UpdateCoinsCacheHandler[]>} The record of events and handlers.\n   */\n  public getEvents() {\n    return this.events;\n  }\n\n  /**\n   * @public\n   * @method getBuffer\n   * @description Returns the buffer containing buffered events.\n   * @return {{ eventName: string, data: UpdatedCoinsCache }[]} The buffer containing buffered events.\n   */\n  public getBuffer() {\n    return this.buffer;\n  }\n}\n","/* eslint-disable @typescript-eslint/no-unused-vars */\nimport { GetCacheParams, IStorage, SetCacheParams, StorageValue } from \"./types\";\n\n/**\n * Default in-memory storage implementation.\n * You may extend this class or provide your own storage implementation as needed.\n *\n * Disclaimer: While the methods in this class are marked as public,\n * it is strongly discouraged to use them directly unless you are certain\n * about their behavior. For typical SDK usage, consider interacting with\n * the SDK's public API instead of directly using the methods of this class.\n * External usage may lead to unintended behavior and issues.\n */\nexport class InMemoryStorageSingleton implements IStorage {\n  private static _instance: InMemoryStorageSingleton;\n\n  /**\n   * Private constructor for the singleton pattern.\n   */\n  private constructor() {\n    // Additional initialization if needed.\n  }\n\n  /**\n   * Gets the instance of the InMemoryStorageSingleton.\n   * @return {InMemoryStorageSingleton} - The singleton instance.\n   */\n  public static getInstance(): InMemoryStorageSingleton {\n    if (!InMemoryStorageSingleton._instance) {\n      console.warn(`\n      Warning: InMemoryStorageSingleton is being used as a placeholder. While it's safe to use for basic scenarios,\n      note that no prefilling data from cache storage will occur. Consider providing your own storage implementation\n      for more advanced use cases.\n    `);\n      const instance = new InMemoryStorageSingleton();\n      InMemoryStorageSingleton._instance = instance;\n    }\n\n    return InMemoryStorageSingleton._instance;\n  }\n\n  /**\n   * Placeholder for setCache method. Implement your custom logic if needed.\n   * @param {SetCacheParams} params - SetCacheParams object containing key and value.\n   * @return {Promise<void>} - A promise that resolves once the cache is set.\n   */\n  public async setCache(params: SetCacheParams): Promise<void> {\n    // Placeholder. Implement your custom logic if needed.\n  }\n\n  /**\n   * Placeholder for getCache method. Implement your custom logic if needed.\n   * @param {GetCacheParams} params - GetCacheParams object containing the key.\n   * @return {Promise<StorageValue>} - A promise that resolves to the retrieved StorageValue.\n   */\n  public async getCache(params: GetCacheParams): Promise<StorageValue> {\n    // Placeholder. Implement your custom logic if needed.\n    return null;\n  }\n}\n","import { createClient } from \"redis\";\nimport { CommonCoinData } from \"../managers/types\";\nimport { ShortCoinMetadata } from \"../providers/flowx/types\";\nimport { ShortPoolData } from \"../providers/turbos/types\";\nimport { CommonPoolData } from \"../providers/types\";\nimport { InMemoryStorageSingleton } from \"./InMemoryStorage\";\nimport { RedisStorageSingleton } from \"./RedisStorage\";\nimport { CetusPathForStorage } from \"../providers/cetus/types\";\n\nexport type Storage = InMemoryStorageSingleton | RedisStorageSingleton;\n\nexport interface IStorage {\n  setCache(params: SetCacheParams): Promise<void>;\n  getCache(params: GetCacheParams): Promise<StorageValue>;\n}\n\nexport type GetCacheParams = {\n  provider: string;\n  property: StorageProperty;\n};\n\nexport type SetCacheParams = GetCacheParams & {\n  value: StorageValue;\n};\n\nexport enum StorageProperty {\n  Coins = \"coins\",\n  Paths = \"paths\",\n  Pools = \"pools\",\n  CoinsMetadata = \"coinsMetadata\",\n  CetusPaths = \"cetusPaths\",\n}\n\nexport type StorageValue =\n  | { value: CommonCoinData[]; timestamp: string }\n  | { value: CommonPoolData[]; timestamp: string }\n  | { value: ShortCoinMetadata[]; timestamp: string }\n  | { value: ShortPoolData[]; timestamp: string }\n  | { value: CetusPathForStorage[]; timestamp: string }\n  | null;\n\nexport type RedisStorageClient = ReturnType<typeof createClient>;\n","/* eslint-disable require-jsdoc */\n\nimport { CommonCoinData } from \"../../managers/types\";\nimport { CetusPathForStorage } from \"../../providers/cetus/types\";\nimport { ShortCoinMetadata } from \"../../providers/flowx/types\";\nimport { ShortPoolData } from \"../../providers/turbos/types\";\nimport { CommonPoolData } from \"../../providers/types\";\nimport { StorageValue } from \"../types\";\n\nexport function isStorageValue(data: unknown): data is StorageValue {\n  return (\n    typeof data === \"object\" &&\n    data !== null &&\n    \"timestamp\" in data &&\n    \"value\" in data &&\n    (isCommonCoinDataArray(data.value) ||\n      isCommonPoolDataArray(data.value) ||\n      isShortCoinMetadataArray(data.value) ||\n      isShortPoolDataArray(data.value))\n  );\n}\n\nexport function isCommonCoinDataArray(data: unknown): data is CommonCoinData[] {\n  return Array.isArray(data) && data.every((item) => isCommonCoinData(item));\n}\n\nexport function isCommonCoinData(data: unknown): data is CommonCoinData {\n  return (\n    typeof data === \"object\" &&\n    data !== null &&\n    \"type\" in data &&\n    typeof (data as CommonCoinData).type === \"string\" &&\n    \"decimals\" in data &&\n    typeof (data as CommonCoinData).decimals === \"number\" &&\n    ((data as CommonCoinData).symbol === undefined || typeof (data as CommonCoinData).symbol === \"string\")\n  );\n}\n\nexport function isCommonPoolDataArray(data: unknown): data is CommonPoolData[] {\n  return (\n    Array.isArray(data) &&\n    data.every(\n      (item) =>\n        typeof item === \"object\" &&\n        item !== null &&\n        \"base\" in item &&\n        typeof (item as CommonPoolData).base === \"string\" &&\n        \"quote\" in item &&\n        typeof (item as CommonPoolData).quote === \"string\",\n    )\n  );\n}\n\nexport function isShortCoinMetadataArray(data: unknown): data is ShortCoinMetadata[] {\n  return (\n    Array.isArray(data) &&\n    data.every(\n      (item) =>\n        typeof item === \"object\" &&\n        item !== null &&\n        \"decimals\" in item &&\n        typeof (item as ShortCoinMetadata).decimals === \"number\" &&\n        \"type\" in item &&\n        typeof (item as ShortCoinMetadata).type === \"string\",\n    )\n  );\n}\n\nexport function isShortPoolDataArray(data: unknown): data is ShortPoolData[] {\n  return (\n    Array.isArray(data) &&\n    data.every(\n      (item) =>\n        typeof item === \"object\" &&\n        item !== null &&\n        \"poolId\" in item &&\n        typeof (item as ShortPoolData).poolId === \"string\" &&\n        \"coinTypeA\" in item &&\n        typeof (item as ShortPoolData).coinTypeA === \"string\" &&\n        \"coinTypeB\" in item &&\n        typeof (item as ShortPoolData).coinTypeB === \"string\",\n    )\n  );\n}\n\nexport function isCetusPathForStorageArray(data: unknown): data is CetusPathForStorage[] {\n  if (!Array.isArray(data)) return false;\n\n  return data.every(\n    (item) =>\n      typeof item === \"object\" &&\n      item !== null &&\n      \"base\" in item &&\n      typeof (item as CetusPathForStorage).base === \"string\" &&\n      \"quote\" in item &&\n      typeof (item as CetusPathForStorage).quote === \"string\" &&\n      \"addressMap\" in item &&\n      Array.isArray((item as CetusPathForStorage).addressMap) &&\n      (item as CetusPathForStorage).addressMap.every(\n        (pair) =>\n          Array.isArray(pair) && pair.length === 2 && typeof pair[0] === \"number\" && typeof pair[1] === \"string\",\n      ),\n  );\n}\n","import { CommonCoinData } from \"../../managers/types\";\nimport { Storage, StorageProperty, StorageValue } from \"../types\";\nimport { isCommonCoinDataArray } from \"./typeguards\";\n\n/**\n * Returns coins cache from storage. If cache is not up to date, empty map is returned.\n */\nexport const getCoinsCache = async ({\n  storage,\n  provider,\n  updateCacheInterval,\n}: {\n  storage: Storage;\n  provider: string;\n  updateCacheInterval: number;\n}): Promise<Map<string, CommonCoinData>> => {\n  let coinsCache: Map<string, CommonCoinData> = new Map();\n\n  const coins: StorageValue = await storage.getCache({\n    provider,\n    property: StorageProperty.Coins,\n  });\n\n  if (isCommonCoinDataArray(coins?.value)) {\n    const timestamp = parseInt(coins.timestamp);\n    const cacheIsUpToDate = timestamp + updateCacheInterval > Date.now();\n\n    if (cacheIsUpToDate) {\n      coinsCache = coins.value.reduce((cache: Map<string, CommonCoinData>, coin: CommonCoinData) => {\n        cache.set(coin.type, coin);\n        return cache;\n      }, new Map());\n    } else {\n      console.warn(`[getCoinsCache] ${provider} coins cache is not up to date.`);\n    }\n  } else if (coins === null) {\n    console.warn(`[getCoinsCache] ${provider} Received empty coins from strorage, coins === null `);\n  } else {\n    const stringifiedCoin: string = JSON.stringify(coins.value[0]);\n    throw new Error(\n      `[${provider}] prefillCaches: coins from storage are not (CommonCoinData[] or null). ` +\n        `Example of coin: ${stringifiedCoin}`,\n    );\n  }\n\n  return coinsCache;\n};\n","import { CommonPoolData } from \"../../providers/types\";\nimport { Storage, StorageProperty, StorageValue } from \"../types\";\nimport { isCommonPoolDataArray } from \"./typeguards\";\n\n/**\n * Returns paths cache from storage. If cache is not up to date, empty map is returned.\n */\nexport const getPathsCache = async ({\n  storage,\n  provider,\n  updateCacheInterval,\n}: {\n  storage: Storage;\n  provider: string;\n  updateCacheInterval: number;\n}): Promise<Map<string, CommonPoolData>> => {\n  let pathsCache: Map<string, CommonPoolData> = new Map();\n\n  const paths: StorageValue = await storage.getCache({\n    provider,\n    property: StorageProperty.Paths,\n  });\n\n  if (isCommonPoolDataArray(paths?.value)) {\n    const timestamp = parseInt(paths.timestamp);\n    const cacheIsUpToDate = timestamp + updateCacheInterval > Date.now();\n\n    if (cacheIsUpToDate) {\n      pathsCache = paths.value.reduce((cache: Map<string, CommonPoolData>, path: CommonPoolData) => {\n        const key = `${path.base}-${path.quote}`;\n        cache.set(key, path);\n        return cache;\n      }, new Map());\n    } else {\n      console.warn(`[getPathsCache] ${provider} paths cache is not up to date.`);\n    }\n  } else if (paths === null) {\n    console.warn(`[getPathsCache] ${provider} Received empty paths from strorage, paths === null `);\n  } else {\n    const stringifiedPath: string = JSON.stringify(paths.value[0]);\n    throw new Error(\n      `[${provider}] prefillCaches: paths from storage are not (CommonPoolData[] or null). ` +\n        `Example of path: ${stringifiedPath}`,\n    );\n  }\n\n  return pathsCache;\n};\n","import { CommonCoinData } from \"../../managers/types\";\nimport { CommonPoolData } from \"../../providers/types\";\nimport { Storage } from \"../types\";\nimport { getCoinsCache } from \"./getCoinsCache\";\nimport { getPathsCache } from \"./getPathsCache\";\n\n/**\n * Returns coins and paths caches from storage. If cache is not up to date, empty map is returned.\n */\nexport const getCoinsAndPathsCaches = async ({\n  storage,\n  provider,\n  updateCacheInterval,\n}: {\n  storage: Storage;\n  provider: string;\n  updateCacheInterval: number;\n}): Promise<{\n  coinsCache: Map<string, CommonCoinData>;\n  pathsCache: Map<string, CommonPoolData>;\n}> => {\n  const coinsCache = await getCoinsCache({ storage, provider, updateCacheInterval });\n  const pathsCache = await getPathsCache({ storage, provider, updateCacheInterval });\n\n  return { coinsCache, pathsCache };\n};\n","/* eslint-disable require-jsdoc */\n\nimport { CommonCoinData, Provider } from \"../../managers/types\";\nimport { Storage, StorageProperty } from \"../types\";\nimport { ShortCoinMetadata } from \"../../providers/flowx/types\";\nimport { ShortPoolData } from \"../../providers/turbos/types\";\nimport { CommonPoolData } from \"../../providers/types\";\n\nexport async function storeCaches({\n  provider,\n  storage,\n  coinsCache,\n  pathsCache,\n  coinsMetadataCache,\n  poolsCache,\n}: {\n  provider: string;\n  storage: Storage;\n  coinsCache: ReturnType<Provider[\"getCoins\"]>;\n  // TODO: Put it into separate store method to avoid usage from different class\n  pathsCache?: ReturnType<Provider[\"getPaths\"]>;\n  coinsMetadataCache?: ShortCoinMetadata[];\n  poolsCache?: ShortPoolData[];\n}): Promise<void> {\n  try {\n    const { data: coins }: { data: CommonCoinData[] } = coinsCache;\n    const timestamp = Date.now().toString();\n\n    await storage.setCache({\n      provider,\n      property: StorageProperty.Coins,\n      value: { value: coins, timestamp },\n    });\n\n    if (pathsCache !== undefined) {\n      const paths: CommonPoolData[] = Array.from(pathsCache.values());\n\n      await storage.setCache({\n        provider,\n        property: StorageProperty.Paths,\n        value: { value: paths, timestamp },\n      });\n    }\n\n    coinsMetadataCache !== undefined &&\n      (await storage.setCache({\n        provider,\n        property: StorageProperty.CoinsMetadata,\n        value: { value: coinsMetadataCache, timestamp },\n      }));\n    poolsCache !== undefined &&\n      (await storage.setCache({\n        provider,\n        property: StorageProperty.Pools,\n        value: { value: poolsCache, timestamp },\n      }));\n  } catch (error) {\n    console.error(`[storeCaches] error for params: provider ${provider} `, error);\n\n    throw error;\n  }\n}\n","/* eslint-disable require-jsdoc */\nimport { CommonCoinData } from \"../../managers/types\";\nimport { LONG_SUI_COIN_TYPE, SHORT_SUI_COIN_TYPE } from \"../common\";\nimport { CoinsCache } from \"../types\";\n\nexport function getCoinInfoFromCache(coinType: string, coinsCache: CoinsCache): CommonCoinData | undefined {\n  const coinIsSui: boolean = coinType === SHORT_SUI_COIN_TYPE || coinType === LONG_SUI_COIN_TYPE;\n  const coinTypeInfo = coinIsSui\n    ? coinsCache.get(LONG_SUI_COIN_TYPE) || coinsCache.get(SHORT_SUI_COIN_TYPE)\n    : coinsCache.get(coinType);\n\n  return coinTypeInfo;\n}\n","import BigNumber from \"bignumber.js\";\n\n/**\n * Removes the decimal part of a BigNumber if present.\n * @param {BigNumber} input - The input BigNumber representing a number.\n * @return {BigNumber} - The BigNumber without the decimal part.\n * @throws {Error} - Throws an error if the input is not in a valid numeric format.\n\n * @example\n * // Example 1: Input with a decimal part\n * const result1 = removeDecimalPart(new BigNumber(\"123.45\"));\n * console.log(result1.toString()); // Outputs: \"123\"\n * // Outputs: Warning - Decimal part of input (123.45) has been stripped.\n *\n * @example\n * // Example 2: Input without a decimal part\n * const result2 = removeDecimalPart(new BigNumber(\"678\"));\n * console.log(result2.toString()); // Outputs: \"678\"\n * // Outputs: No warning since there is no decimal part.\n */\nexport function removeDecimalPart(input: BigNumber): BigNumber {\n  if (isNaN(input.toNumber())) {\n    throw new Error(\"Invalid numeric format: Resulting BigNumber is NaN.\");\n  }\n\n  const inputStr = input.toString();\n  const decimalIndex = inputStr.indexOf(\".\");\n\n  if (decimalIndex !== -1) {\n    const strippedDecimal = inputStr.substring(0, decimalIndex);\n    const decimalPart = inputStr.substring(decimalIndex + 1);\n    console.warn(`Decimal part (${decimalPart}) of input (${inputStr}) has been stripped.`);\n\n    return new BigNumber(strippedDecimal);\n  }\n\n  return input;\n}\n","export const fixedOneN = 1000000000000000000;\n","/* eslint-disable require-jsdoc */\n\nimport { SuiTransactionBlockResponse } from \"@mysten/sui.js/client\";\nimport { fixedOneN } from \"./constants\";\nimport { GetLpCoinDecimalsInput } from \"./types\";\n\nexport function getCreatePoolCapIdAndLpCoinType(createLpCoinTransactionResult: SuiTransactionBlockResponse): {\n  createPoolCapId: string;\n  lpCoinType: string;\n} {\n  const requiredObjectTypePart = \"CreatePoolCap\";\n  const objectChanges = createLpCoinTransactionResult.objectChanges;\n\n  if (objectChanges === null || objectChanges === undefined) {\n    throw new Error(\n      \"[getCreatePoolCapIdAndLpCoinType] object changes are null or \" +\n        `undefined for transaction ${createLpCoinTransactionResult.digest}`,\n    );\n  }\n\n  const createdObjectChanges = objectChanges.filter((change) => change.type === \"created\");\n\n  if (createdObjectChanges.length === 0) {\n    throw new Error(\n      \"[getCreatePoolCapIdAndLpCoinType] there is no created object changes \" +\n        `for transaction ${createLpCoinTransactionResult.digest}`,\n    );\n  }\n\n  const requiredObjectChange = createdObjectChanges.find(\n    (change) => change.type === \"created\" && change.objectType.includes(requiredObjectTypePart),\n  );\n\n  if (requiredObjectChange === undefined) {\n    throw new Error(\n      `[getCreatePoolCapIdAndLpCoinType] there is no object change with \"${requiredObjectTypePart}\" ` +\n        `for transaction ${createLpCoinTransactionResult.digest}`,\n    );\n  }\n\n  const matches = requiredObjectChange.type === \"created\" && requiredObjectChange.objectType.match(/<([^>]*)>/);\n\n  if (matches && matches[1]) {\n    const lpCoinType = matches[1];\n    const createPoolCapId = requiredObjectChange.objectId;\n\n    return { lpCoinType, createPoolCapId };\n  } else {\n    throw new Error(\n      \"[getCreatePoolCapIdAndLpCoinType] could find enough matches to get lpCoinType \" +\n        `from object changes.\\nrequiredObjectChange: ${JSON.stringify(requiredObjectChange)}\\n` +\n        `matches: ${JSON.stringify(matches)}`,\n    );\n  }\n}\n\nexport function getPoolObjectIdFromTransactionResult(createPoolTransactionResult: SuiTransactionBlockResponse) {\n  const requiredObjectTypePart = \"pool::Pool\";\n  const objectChanges = createPoolTransactionResult.objectChanges;\n\n  if (objectChanges === null || objectChanges === undefined) {\n    throw new Error(\n      \"[getPoolObjectIdFromTransactionResult] object changes are null or \" +\n        `undefined for transaction ${createPoolTransactionResult.digest}`,\n    );\n  }\n\n  const createdObjectChanges = objectChanges.filter((change) => change.type === \"created\");\n\n  if (createdObjectChanges.length === 0) {\n    throw new Error(\n      \"[getPoolObjectIdFromTransactionResult] there is no created object changes \" +\n        `for transaction ${createPoolTransactionResult.digest}`,\n    );\n  }\n\n  const requiredObjectChange = createdObjectChanges.find(\n    (change) => change.type === \"created\" && change.objectType.includes(requiredObjectTypePart),\n  );\n\n  if (requiredObjectChange === undefined) {\n    throw new Error(\n      `[getPoolObjectIdFromTransactionResult] there is no object change with \"${requiredObjectTypePart}\" ` +\n        `for transaction ${createPoolTransactionResult.digest}`,\n    );\n  }\n\n  // ts check\n  if (requiredObjectChange.type === \"created\") {\n    return requiredObjectChange.objectId;\n  } else {\n    throw new Error(\"[getPoolObjectIdFromTransactionResult] requiredObjectChange.type is not 'created'.\");\n  }\n}\n\nexport function numberToFixedBigInt(number: number) {\n  return BigInt(Math.floor(number * fixedOneN));\n}\n\nexport function getLpCoinDecimals(coinsInfo: GetLpCoinDecimalsInput): number {\n  const { decimals: decimalsA, weight: weightA } = coinsInfo.coinA;\n  const { decimals: decimalsB, weight: weightB } = coinsInfo.coinB;\n\n  const weightABigInt: bigint = numberToFixedBigInt(weightA);\n  const weightBBigInt: bigint = numberToFixedBigInt(weightB);\n\n  const mulResA: bigint = weightABigInt * BigInt(decimalsA);\n  const mulResB: bigint = weightBBigInt * BigInt(decimalsB);\n\n  const sumRes: bigint = mulResA + mulResB;\n  const divRes: bigint = sumRes / BigInt(fixedOneN);\n  const lpCoinDecimals = Number(divRes);\n\n  return lpCoinDecimals;\n}\n","/* eslint-disable require-jsdoc */\n\nimport { CoinMetadata } from \"@mysten/sui.js/client\";\nimport { CoinMetadaWithInfo, Pool, PoolCoin, PoolCoins, PoolObject, PoolStats, SuiNetwork } from \"aftermath-ts-sdk\";\nimport BigNumber from \"bignumber.js\";\nimport { CoinManagerSingleton } from \"../../managers/coin/CoinManager\";\nimport { CommonPoolData } from \"../types\";\nimport { OwnedPoolCoinInfo, OwnedPoolInfo } from \"./types\";\n\nexport const getPathMapAndCoinTypesSet = (\n  pools: Pool[],\n): {\n  pathMap: Map<string, CommonPoolData>;\n  coinTypesSet: Set<string>;\n} => {\n  const pathMap: Map<string, CommonPoolData> = new Map();\n  const coinTypesSet: Set<string> = new Set();\n\n  pools.forEach((pool: Pool) => {\n    const coinTypes: string[] = Object.keys(pool.pool.coins);\n    const base: string = coinTypes[0];\n    const quote: string = coinTypes[1];\n\n    // Fill pathMap\n    const commonPoolData: CommonPoolData = {\n      base,\n      quote,\n    };\n    const poolKey = `${base}-${quote}`;\n    pathMap.set(poolKey, commonPoolData);\n\n    // Fill coinTypeSet\n    coinTypesSet.add(base);\n    coinTypesSet.add(quote);\n  });\n\n  return { pathMap, coinTypesSet };\n};\n\nexport async function getOwnedPoolInfosFromPools(\n  pools: Pool[],\n  coinManager: CoinManagerSingleton,\n): Promise<OwnedPoolInfo[]> {\n  return await Promise.all(\n    pools.map(async (pool) => {\n      const coinTypes: string[] = Object.keys(pool.pool.coins);\n      const coins: OwnedPoolCoinInfo[] = await Promise.all(\n        coinTypes.map(async (type) => {\n          const coinInfo = pool.pool.coins[type];\n          const coinInfoFromStorage = await coinManager.getCoinByType2(type);\n          const decimals = coinInfo.decimals ?? coinInfoFromStorage?.decimals ?? 0;\n          const balance = new BigNumber(coinInfo.balance.toString()).dividedBy(10 ** decimals).toString();\n\n          return {\n            type,\n            balance,\n            symbol: coinInfoFromStorage?.symbol,\n          };\n        }),\n      );\n\n      return {\n        name: pool.pool.name,\n        apr: pool.stats?.apr.toString() ?? \"0\",\n        fees: pool.stats?.fees.toString() ?? \"0\",\n        tvl: pool.stats?.tvl.toString() ?? \"0\",\n        volume: pool.stats?.volume.toString() ?? \"0\",\n        poolObjectId: pool.pool.objectId,\n        coins,\n      };\n    }),\n  );\n}\n\nexport function isApiResponseValid(pools: Pool[]): pools is Pool[] {\n  return pools !== undefined && Array.isArray(pools) && pools.length > 0 && pools.every(isPoolValid);\n}\n\nexport function isPoolObjectValid(poolObject: PoolObject): boolean {\n  return (\n    typeof poolObject.name === \"string\" &&\n    typeof poolObject.creator === \"string\" &&\n    typeof poolObject.lpCoinType === \"string\" &&\n    typeof poolObject.lpCoinSupply === \"bigint\" &&\n    typeof poolObject.illiquidLpCoinSupply === \"bigint\" &&\n    typeof poolObject.flatness === \"bigint\" &&\n    isPoolCoinsValid(poolObject.coins) &&\n    typeof poolObject.lpCoinDecimals === \"number\"\n  );\n}\n\nexport function isPoolCoinsValid(poolCoins: PoolCoins): boolean {\n  return Object.values(poolCoins).every(isPoolCoinValid);\n}\n\nexport function isPoolCoinValid(poolCoin: PoolCoin): boolean {\n  return (\n    typeof poolCoin.weight === \"bigint\" &&\n    typeof poolCoin.balance === \"bigint\" &&\n    typeof poolCoin.tradeFeeIn === \"bigint\" &&\n    typeof poolCoin.tradeFeeOut === \"bigint\" &&\n    typeof poolCoin.depositFee === \"bigint\" &&\n    typeof poolCoin.withdrawFee === \"bigint\" &&\n    typeof poolCoin.decimalsScalar === \"bigint\" &&\n    typeof poolCoin.normalizedBalance === \"bigint\" &&\n    (typeof poolCoin.decimals === \"number\" || poolCoin.decimals === undefined)\n  );\n}\n\nexport function isPoolValid(pool: Pool): boolean {\n  return (\n    isPoolObjectValid(pool.pool) &&\n    (pool.network === undefined || isSuiNetworkValid(pool.network)) &&\n    (pool.stats === undefined || isPoolStatsValid(pool.stats))\n  );\n}\n\nexport function isSuiNetworkValid(suiNetwork: SuiNetwork): boolean {\n  return [\"DEVNET\", \"TESTNET\", \"LOCAL\", \"MAINNET\"].includes(suiNetwork);\n}\n\nexport function isPoolStatsValid(poolStats: PoolStats): boolean {\n  return (\n    typeof poolStats.volume === \"number\" &&\n    typeof poolStats.tvl === \"number\" &&\n    Array.isArray(poolStats.supplyPerLps) &&\n    poolStats.supplyPerLps.every((supply) => typeof supply === \"number\") &&\n    typeof poolStats.lpPrice === \"number\" &&\n    typeof poolStats.fees === \"number\" &&\n    typeof poolStats.apr === \"number\"\n  );\n}\n\nexport function isCoinMetadaWithInfoApiResponseValid(metadata: CoinMetadaWithInfo): metadata is CoinMetadaWithInfo {\n  return metadata !== undefined && isCoinMetadaWithInfoValid(metadata);\n}\n\nexport function isCoinMetadataValid(coinMetadata: CoinMetadata): boolean {\n  return (\n    typeof coinMetadata.decimals === \"number\" &&\n    typeof coinMetadata.description === \"string\" &&\n    (typeof coinMetadata.iconUrl === \"string\" || coinMetadata.iconUrl === null) &&\n    (typeof coinMetadata.id === \"string\" || coinMetadata.id === null) &&\n    typeof coinMetadata.name === \"string\" &&\n    typeof coinMetadata.symbol === \"string\"\n  );\n}\n\nexport function isCoinMetadaWithInfoValid(coinMetadaWithInfo: CoinMetadaWithInfo): boolean {\n  return (\n    isCoinMetadataValid(coinMetadaWithInfo) &&\n    (typeof coinMetadaWithInfo.isGenerated === \"boolean\" || coinMetadaWithInfo.isGenerated === undefined)\n  );\n}\n","import CetusClmmSDK, {\n  AddLiquidityFixTokenParams,\n  AggregatorResult,\n  ClmmPoolUtil,\n  PathLink,\n  Pool,\n  SdkOptions,\n  TickMath,\n  TransactionUtil,\n  d,\n  isSortedSymbols,\n} from \"@cetusprotocol/cetus-sui-clmm-sdk\";\nimport { EventId, PaginatedEvents, SuiClient, SuiEvent } from \"@mysten/sui.js/client\";\nimport { TransactionBlock } from \"@mysten/sui.js/transactions\";\nimport { normalizeSuiAddress } from \"@mysten/sui.js/utils\";\nimport BigNumber from \"bignumber.js\";\nimport BN from \"bn.js\";\nimport { EventEmitter } from \"../../emitters/EventEmitter\";\nimport { NoRoutesError } from \"../../errors/NoRoutesError\";\nimport { CoinManagerSingleton } from \"../../managers/coin/CoinManager\";\nimport { CommonCoinData, ProvidersToRouteDataMap, UpdatedCoinsCache } from \"../../managers/types\";\nimport { InMemoryStorageSingleton } from \"../../storages/InMemoryStorage\";\nimport { Storage } from \"../../storages/types\";\nimport { getCetusPathsCache } from \"../../storages/utils/getCetusPathsCache\";\nimport { getCoinsCache } from \"../../storages/utils/getCoinsCache\";\nimport { storeCaches } from \"../../storages/utils/storeCaches\";\nimport { storeCetusPathsCache } from \"../../storages/utils/storeCetusPathsCache\";\nimport { LONG_SUI_COIN_TYPE, MAX_BATCH_EVENTS_PER_QUERY_EVENTS_REQUEST, exitHandlerWrapper } from \"../common\";\nimport { CacheOptions, CoinsCache, IPoolProvider } from \"../types\";\nimport { convertSlippage } from \"../utils/convertSlippage\";\nimport { getCoinInfoFromCache } from \"../utils/getCoinInfoFromCache\";\nimport { isSuiCoinType } from \"../utils/isSuiCoinType\";\nimport { removeDecimalPart } from \"../utils/removeDecimalPart\";\nimport { CENTRALIZED_POOLS_INFO_ENDPOINT } from \"./config\";\nimport { CetusOptions, CetusOwnedPool, CoinMap, CoinNodeWithSymbol, LPList } from \"./types\";\nimport {\n  getCoinMapFromCoinsCache,\n  getCoinsAndPathsCachesFromMaps,\n  getMockedAssets,\n  getPoolsDataFromApiData,\n  isApiResponseValid,\n  isCetusCreatePoolEventParsedJson,\n} from \"./utils\";\nimport { buildDcaTxBlock } from \"../../managers/dca/adapters/cetusAdapter\";\nimport { fetchBestRoute } from \"./forked\";\n\n/**\n * @class CetusSingleton\n * @extends EventEmitter\n * @implements {IPoolProvider<CetusSingleton>}\n * @description Singleton class for Cetus.\n *\n * Note: If using `lazyLoading: true` with any storage configuration in a serverless/cloud functions environment,\n * be aware that each invocation of your cloud function will start cache population from scratch.\n * This may lead to unexpected behavior when using different SDK methods. To avoid this and minimize the time\n * for cache population, consider using `lazyLoading: false` along with passing a persistent\n * storage adapter (external, e.g., Redis or any kind of DB) to the ProviderSingleton.\n */\nexport class CetusSingleton extends EventEmitter implements IPoolProvider<CetusSingleton> {\n  private static _instance: CetusSingleton | undefined;\n  public providerName = \"Cetus\";\n  public isSmartRoutingAvailable = true;\n  public cetusSdk: CetusClmmSDK;\n\n  public poolsCache: LPList[] = [];\n  public pathsCache: Map<string, PathLink> = new Map();\n  public coinsCache: CoinsCache = new Map();\n  // The `cetusCoinsCache` is workaround property to make it compatible with the Cetus SDK interface\n  private cetusCoinsCache: CoinMap = new Map();\n  private cacheOptions: CacheOptions;\n  private useOnChainFallback = false;\n  private intervalId: NodeJS.Timeout | undefined;\n  private proxy: string | undefined;\n  private storage: Storage;\n  private cetusSDKConfig: SdkOptions;\n\n  /**\n   * @constructor\n   * @param {Omit<CetusOptions, \"lazyLoading\">} options - The options for CetusSingleton.\n   */\n  private constructor(options: Omit<CetusOptions, \"lazyLoading\">) {\n    super();\n    this.cetusSDKConfig = {\n      fullRpcUrl: options.suiProviderUrl,\n      simulationAccount: { address: options.simulationAccount || \"\" },\n      ...options.sdkOptions,\n    };\n    this.cetusSdk = new CetusClmmSDK(this.cetusSDKConfig);\n\n    const { updateIntervally = true, ...restCacheOptions } = options.cacheOptions;\n    this.cacheOptions = { updateIntervally, ...restCacheOptions };\n    this.proxy = options.proxy;\n    this.storage = options.cacheOptions.storage ?? InMemoryStorageSingleton.getInstance();\n  }\n\n  /**\n   * @public\n   * @method getInstance\n   * @description Gets the singleton instance of CetusSingleton.\n   * @param {CetusOptions} [options] - Options for CetusSingleton.\n   * @return {Promise<CetusSingleton>} The singleton instance of CetusSingleton.\n   */\n  public static async getInstance(options?: CetusOptions): Promise<CetusSingleton> {\n    if (!CetusSingleton._instance) {\n      if (options === undefined) {\n        throw new Error(\"[Cetus] Options are required in arguments to create instance.\");\n      }\n\n      const { sdkOptions, cacheOptions, lazyLoading = true, suiProviderUrl, proxy, simulationAccount } = options;\n\n      const instance = new CetusSingleton({ sdkOptions, cacheOptions, suiProviderUrl, proxy, simulationAccount });\n      lazyLoading ? instance.init() : await instance.init();\n      CetusSingleton._instance = instance;\n    }\n\n    return CetusSingleton._instance;\n  }\n\n  /**\n   * @private\n   * @method init\n   * @description Initializes the CetusSingleton instance.\n   * @return {Promise<void>} A Promise that resolves when initialization is complete.\n   */\n  private async init() {\n    console.debug(`[${this.providerName}] Singleton initiating.`);\n\n    await this.fillCacheFromStorage();\n    await this.updateCaches();\n    this.cacheOptions.updateIntervally && this.updateCachesIntervally();\n\n    this.bufferEvent(\"cachesUpdate\", this.getCoins());\n  }\n\n  /**\n   * Fills the cache from storage asynchronously.\n   *\n   * @private\n   * @return {Promise<void>} A promise that resolves when the cache is filled from storage.\n   */\n  private async fillCacheFromStorage(): Promise<void> {\n    try {\n      const coinsCache = await getCoinsCache({\n        storage: this.storage,\n        provider: this.providerName,\n        updateCacheInterval: this.cacheOptions.updateIntervalInMs,\n      });\n      const pathsCache = await getCetusPathsCache({\n        storage: this.storage,\n        provider: this.providerName,\n        updateCacheInterval: this.cacheOptions.updateIntervalInMs,\n      });\n\n      this.coinsCache = coinsCache;\n      this.pathsCache = pathsCache;\n\n      const coinMap = getCoinMapFromCoinsCache(this.coinsCache);\n      this.cetusCoinsCache = coinMap;\n    } catch (error) {\n      console.error(`[${this.providerName}] fillCacheFromStorage failed:`, error);\n    }\n  }\n\n  /**\n   * Checks if the storage cache is empty.\n   *\n   * @private\n   * @return {boolean} True if the storage cache is empty, false otherwise.\n   */\n  private isStorageCacheEmpty() {\n    const isCacheEmpty = this.coinsCache.size === 0 || this.pathsCache.size === 0;\n\n    return isCacheEmpty;\n  }\n\n  /**\n   * @private\n   * @method updateCaches\n   * @description Updates the caches for pools, paths, and coins.\n   * @return {Promise<void>} A Promise that resolves when caches are updated.\n   */\n  private async updateCaches({ force }: { force: boolean } = { force: false }): Promise<void> {\n    const isCacheEmpty = this.isStorageCacheEmpty();\n\n    if (isCacheEmpty || force) {\n      try {\n        await this.updatePoolsCache();\n        this.updatePathsAndCoinsCache();\n        this.useOnChainFallback && this.updateGraph();\n        this.emit(\"cachesUpdate\", this.getCoins());\n\n        await storeCaches({\n          provider: this.providerName,\n          storage: this.storage,\n          coinsCache: this.getCoins(),\n        });\n\n        await storeCetusPathsCache({ provider: this.providerName, pathsCache: this.getPaths(), storage: this.storage });\n\n        console.debug(\"[Cetus] Caches are updated and stored.\");\n      } catch (error) {\n        console.error(\"[Cetus] Caches update failed:\", error);\n      }\n    }\n  }\n\n  /**\n   * @private\n   * @method updateCachesIntervally\n   * @description Updates the caches at regular intervals.\n   * @return {void}\n   */\n  private updateCachesIntervally(): void {\n    let isUpdatingCurrently = false;\n    this.intervalId = setInterval(async () => {\n      try {\n        if (isUpdatingCurrently) {\n          return;\n        }\n        isUpdatingCurrently = true;\n        await this.updateCaches({ force: true });\n      } finally {\n        isUpdatingCurrently = false;\n      }\n    }, this.cacheOptions.updateIntervalInMs);\n\n    exitHandlerWrapper({ intervalId: this.intervalId, providerName: this.providerName });\n  }\n\n  /**\n   * @private\n   * @method updatePoolsCache\n   * @description Updates the pools cache.\n   * @return {Promise<void>} A Promise that resolves when the pools cache is updated.\n   */\n  private async updatePoolsCache(): Promise<void> {\n    this.poolsCache = await this.retrieveAllPoolsFromApi();\n  }\n\n  /**\n   * @private\n   * @method updatePathsAndCoinsCache\n   * @description Updates the paths and coins cache.\n   * @return {void}\n   */\n  private updatePathsAndCoinsCache(): void {\n    const { poolMap, coinMap } = getPoolsDataFromApiData({ poolsInfo: this.poolsCache });\n    this.pathsCache = poolMap;\n    this.cetusCoinsCache = coinMap;\n\n    const { coinsCache } = getCoinsAndPathsCachesFromMaps({ coins: coinMap, paths: poolMap });\n    this.coinsCache = coinsCache;\n  }\n\n  /**\n   * Updates the graph used by Cetus for routing.\n   * If no SDK is provided, it defaults to the current Cetus SDK instance.\n   * @param {CetusClmmSDK} [cetusSdk=this.cetusSdk] - The Cetus SDK instance used to update the graph.\n   * @return {void}\n   */\n  public updateGraph(cetusSdk: CetusClmmSDK = this.cetusSdk): void {\n    const coins: CoinNodeWithSymbol[] = Array.from(this.cetusCoinsCache.values());\n    const paths: PathLink[] = Array.from(this.pathsCache.values());\n\n    const coinsProvider = { coins };\n    const pathsProvider = { paths };\n    cetusSdk.Router.loadGraph(coinsProvider, pathsProvider);\n  }\n\n  /**\n   * @private\n   * @method retrievelAllPools\n   * @description Retrieves all pools.\n   * @return {Promise<any>} A Promise that resolves to the retrieved pools.\n   */\n  private async retrievelAllPools() {\n    const pools = await this.cetusSdk.Pool.getPoolsWithPage([]);\n    console.log(`[retrievelAllPools] pool length: ${pools.length}`);\n\n    return pools;\n  }\n\n  /**\n   * @private\n   * @method retrieveAllPoolsFromApi\n   * @description Retrieves all pools from the API.\n   * @return {Promise<any>} A Promise that resolves to the retrieved pools.\n   */\n  private async retrieveAllPoolsFromApi() {\n    const url: string = this.proxy\n      ? `${this.proxy}/${CENTRALIZED_POOLS_INFO_ENDPOINT}`\n      : CENTRALIZED_POOLS_INFO_ENDPOINT;\n\n    const poolsResponse = await (await fetch(url)).json();\n    const isValidPoolsResponse = isApiResponseValid(poolsResponse);\n\n    if (!isValidPoolsResponse) {\n      console.error(\"[Cetus] Pools response:\", poolsResponse);\n      throw new Error(\"Pools response from API is not valid\");\n    }\n\n    return poolsResponse.data.lp_list;\n  }\n\n  /**\n   * @public\n   * @method getCoins\n   * @description Gets the updated coins cache.\n   * @return {UpdatedCoinsCache} Updated coins cache.\n   */\n  public getCoins(): UpdatedCoinsCache {\n    const allCoins: CommonCoinData[] = Array.from(this.coinsCache.values());\n    return { provider: this.providerName, data: allCoins };\n  }\n\n  /**\n   * @public\n   * @method getPaths\n   * @description Gets the paths cache.\n   * @return {Map<string, PathLink>} Paths cache.\n   */\n  public getPaths(): Map<string, PathLink> {\n    return this.pathsCache;\n  }\n\n  /**\n   * @public\n   * @method getRouteData\n   * @description Gets route data.\n   * @param {Object} params - Parameters for route data.\n   * @param {string} params.coinTypeFrom - Coin type from.\n   * @param {string} params.coinTypeTo - Coin type to.\n   * @param {string} params.inputAmount - Input amount.\n   * @param {number} params.slippagePercentage - Slippage percentage.\n   * @param {string} params.publicKey - Public key.\n   * @return {Promise<{ outputAmount: bigint, route: RouterCompleteTradeRoute }>} Route data.\n   */\n  public async getRouteData({\n    coinTypeFrom,\n    coinTypeTo,\n    inputAmount,\n    slippagePercentage = 10,\n  }: {\n    coinTypeFrom: string;\n    coinTypeTo: string;\n    inputAmount: string;\n    slippagePercentage: number;\n    publicKey: string;\n  }) {\n    const coinFrom: CommonCoinData | undefined = getCoinInfoFromCache(coinTypeFrom, this.coinsCache);\n    const coinTo: CommonCoinData | undefined = getCoinInfoFromCache(coinTypeTo, this.coinsCache);\n\n    if (coinFrom === undefined) {\n      throw new Error(`[Cetus] Cannot find coin with address \"${coinTypeFrom}\".`);\n    } else if (coinTo === undefined) {\n      throw new Error(`[Cetus] Cannot find coin with address \"${coinTypeTo}\".`);\n    }\n\n    const { outputAmount, route } = await this.getSmartOutputAmountData({\n      amountIn: inputAmount,\n      tokenFrom: coinFrom,\n      tokenTo: coinTo,\n      slippagePercentage,\n    });\n\n    return { outputAmount, route };\n  }\n\n  /**\n   * @private\n   * @method getSmartOutputAmountData\n   * @description Retrieves smart output amount data for the given coin types and input amount.\n   * @param {Object} params - Parameters for smart output amount data.\n   * @param {string} params.amountIn - The input amount.\n   * @param {CoinNode} params.tokenFrom - The token from object.\n   * @param {CoinNode} params.tokenTo - The token to object.\n   * @param {number} params.slippagePercentage - The slippage percentage.\n   * @param {CetusClmmSDK} [params.cetusSdk=this.cetusSdk] - The Cetus SDK instance (optional,\n   * defaults to the current Cetus SDK instance).\n   * @return {Promise<SmartOutputAmountData>} A Promise that resolves to smart output amount data.\n   */\n  private async getSmartOutputAmountData({\n    amountIn,\n    tokenFrom,\n    tokenTo,\n    slippagePercentage,\n    cetusSdk = this.cetusSdk,\n    useOnChainFallback = false,\n  }: {\n    amountIn: string;\n    tokenFrom: CommonCoinData;\n    tokenTo: CommonCoinData;\n    slippagePercentage: number;\n    cetusSdk?: CetusClmmSDK;\n    useOnChainFallback?: boolean;\n  }) {\n    const absoluteSlippage = convertSlippage(slippagePercentage);\n\n    const amountInWithDecimalsBigNumber = new BigNumber(amountIn).multipliedBy(10 ** tokenFrom.decimals);\n    // We do removing the decimal part in case client send number with more decimal part\n    // than this particular token has decimal places allowed (`inputCoinDecimals`)\n    // That's prevent situation when casting\n    // BigNumber to BigInt fails with error (\"Cannot convert 183763562.1 to a BigInt\")\n    const inputAmountWithoutExceededDecimalPart = removeDecimalPart(amountInWithDecimalsBigNumber);\n    const amountInt = inputAmountWithoutExceededDecimalPart.toNumber();\n    const byAmountIn = true;\n\n    let routerResult;\n    if (useOnChainFallback) {\n      const rawRouterResult = await cetusSdk.RouterV2.getBestRouter(\n        tokenFrom.type,\n        tokenTo.type,\n        amountInt,\n        byAmountIn,\n        absoluteSlippage,\n        \"\",\n      );\n\n      routerResult = rawRouterResult.result;\n    } else {\n      routerResult = await fetchBestRoute({\n        amount: amountInt.toString(),\n        byAmountIn,\n        coinTypeFrom: tokenFrom.type,\n        coinTypeTo: tokenTo.type,\n        config: { apiUrl: this.cetusSDKConfig.aggregatorUrl },\n      });\n    }\n\n    return { outputAmount: BigInt(routerResult.outputAmount), route: routerResult };\n  }\n\n  /**\n   * @public\n   * @method getSwapTransaction\n   * @description Retrieves the swap transaction for the given route and public key.\n   * @param {Object} params - Parameters for the swap transaction.\n   * @param {AggregatorResult} params.route - The route object.\n   * @param {string} params.publicKey - The public key.\n   * @param {number} params.slippagePercentage - The slippage percentage.\n   * @return {Promise<any>} A Promise that resolves to the swap transaction payload.\n   */\n  public async getSwapTransaction({\n    route,\n    publicKey,\n    slippagePercentage,\n  }: {\n    route: AggregatorResult;\n    publicKey: string;\n    slippagePercentage: number;\n  }) {\n    const absoluteSlippage = convertSlippage(slippagePercentage);\n    // If find the best swap router, then send transaction.\n    const allCoinAsset = await this.cetusSdk.getOwnerCoinAssets(publicKey);\n    // If recipient not set, transfer objects move call will use ctx sender.\n    const payload = await TransactionUtil.buildAggregatorSwapTransaction(\n      this.cetusSdk,\n      route,\n      allCoinAsset,\n      \"\",\n      absoluteSlippage,\n      publicKey,\n    );\n\n    return payload;\n  }\n\n  /**\n   * @public\n   * @method getSwapTransaction\n   * @description Retrieves the swap transaction for the given route and public key.\n   * @param {Object} params - Parameters for the swap transaction.\n   * @param {AggregatorResult} params.route - The route object.\n   * @param {string} params.publicKey - The public key.\n   * @param {number} params.slippagePercentage - The slippage percentage.\n   * @return {Promise<any>} A Promise that resolves to the swap transaction payload.\n   */\n  public async getSwapTransactionDoctored({\n    route,\n    publicKey,\n    slippagePercentage,\n  }: {\n    route: AggregatorResult;\n    publicKey: string;\n    slippagePercentage: number;\n  }) {\n    // TODO: Check that `route.fromCoin` and `route.toCoin` remains always the same as in initial inputs provided\n    // In case if not, extend `route` prop to include initial params of coins to that type\n    const mockedAssets = getMockedAssets(route.fromCoin, route.toCoin);\n\n    const absoluteSlippage = convertSlippage(slippagePercentage);\n    // If find the best swap router, then send transaction.\n    console.debug(\"txSignerPubkey: \", publicKey);\n    // If recipient not set, transfer objects move call will use ctx sender.\n    const payload = await TransactionUtil.buildAggregatorSwapTransaction(\n      this.cetusSdk,\n      route,\n      mockedAssets,\n      \"\",\n      absoluteSlippage,\n      publicKey,\n    );\n\n    return payload;\n  }\n\n  /**\n   * Generates a transaction for creating a new liquidity pool.\n   *\n   * @public\n   * @param {Object} params - Parameters for creating the pool transaction.\n   * @param {string} params.coinTypeA - The type of the first coin in the pool.\n   * @param {string} params.coinTypeB - The type of the second coin in the pool.\n   * @param {number} params.decimalsA - The number of decimals for the first coin.\n   * @param {number} params.decimalsB - The number of decimals for the second coin.\n   * @param {string} params.price - The price of coinB in terms of coinA (how much coinB is needed to buy 1 coinA).\n   * @param {number} params.tickSpacing - The tick spacing of the pool.\n   * @param {string} params.uri - The URI of the pool icon.\n   * @return {Promise<TransactionBlock>} A promise that resolves to the transaction block for creating the pool.\n   */\n  public async getCreatePoolTransaction({\n    coinTypeA,\n    coinTypeB,\n    decimalsA,\n    decimalsB,\n    price,\n    tickSpacing,\n    uri = \"\",\n  }: {\n    coinTypeA: string;\n    coinTypeB: string;\n    decimalsA: number;\n    decimalsB: number;\n    price: string;\n    tickSpacing: number;\n    uri?: string;\n  }): Promise<TransactionBlock> {\n    const swapParams: boolean = isSortedSymbols(normalizeSuiAddress(coinTypeA), normalizeSuiAddress(coinTypeB));\n    const resultCoinTypeA = swapParams ? coinTypeB : coinTypeA;\n    const resultCoinTypeB = swapParams ? coinTypeA : coinTypeB;\n    const resultDecimalsA = swapParams ? decimalsB : decimalsA;\n    const resultDecimalsB = swapParams ? decimalsA : decimalsB;\n    const resultPrice = swapParams ? new BigNumber(1).dividedBy(price).toString() : price;\n\n    const initializeSqrtPrice = TickMath.priceToSqrtPriceX64(\n      d(resultPrice),\n      resultDecimalsA,\n      resultDecimalsB,\n    ).toString();\n\n    const createPoolTransaction = await this.cetusSdk.Pool.creatPoolTransactionPayload({\n      coinTypeA: resultCoinTypeA,\n      coinTypeB: resultCoinTypeB,\n      tick_spacing: tickSpacing,\n      initialize_sqrt_price: initializeSqrtPrice,\n      uri,\n    });\n\n    return createPoolTransaction;\n  }\n\n  /**\n   * Retrieves the payload for adding liquidity to a pool along with additional information.\n   *\n   * @description\n   * The current implementation opens a position near the current price of the pool, potentially resulting\n   * in a larger `amountB` than expected. This behavior may lead to an extended liquidity range.\n   * Clients are advised to consider the following:\n   * - Allowing users to specify a price range for providing liquidity.\n   * - Exploring the option of implementing global liquidity adjustments.\n   * For more details, please refer to the Cetus development documentation.\n   *\n   * @public\n   * @param {Object} options - Parameters for generating the add liquidity payload.\n   * @param {Pool} options.pool - The pool to which liquidity will be added.\n   * @param {string} options.coinAmountA - The amount of coinA to add to the liquidity pool.\n   * @param {number} options.decimalsA - The number of decimals for coinA.\n   * @param {number} options.decimalsB - The number of decimals for coinB.\n   * @param {number} options.slippage - The acceptable slippage percentage for the transaction.\n   * @return {Object} An object containing the add liquidity payload, amount of coinB, and current square root price.\n   */\n  public getAddLiquidityPayload({\n    pool,\n    coinAmountA,\n    decimalsA,\n    decimalsB,\n    slippage,\n  }: {\n    pool: Pool;\n    coinAmountA: string;\n    decimalsA: number;\n    decimalsB: number;\n    slippage: number;\n  }): { addLiquidityPayload: AddLiquidityFixTokenParams; amountB: string; curSqrtPrice: BN } {\n    // TODO: The current implementation opens a position near the current price of the pool,\n    // resulting in a potentially large `amountB`. This behavior may lead to unexpected liquidity range.\n    // Possible solutions:\n    // 1. Allow users to specify a price range for providing liquidity.\n    // 2. Consider implementing global liquidity adjustments.\n    // For more details, refer to the Cetus development documentation.\n    const lowerTick = TickMath.getPrevInitializableTickIndex(\n      new BN(pool.current_tick_index).toNumber(),\n      new BN(pool.tickSpacing).toNumber(),\n    );\n    const upperTick = TickMath.getNextInitializableTickIndex(\n      new BN(pool.current_tick_index).toNumber(),\n      new BN(pool.tickSpacing).toNumber(),\n    );\n    const rawAmount = new BigNumber(coinAmountA).multipliedBy(10 ** decimalsA).toString();\n    const rawAmountBN = new BN(rawAmount);\n    const fixAmountA = true;\n    const curSqrtPrice = new BN(pool.current_sqrt_price);\n    const liquidityInput = ClmmPoolUtil.estLiquidityAndcoinAmountFromOneAmounts(\n      lowerTick,\n      upperTick,\n      rawAmountBN,\n      fixAmountA,\n      true,\n      slippage,\n      curSqrtPrice,\n    );\n\n    const amountA = fixAmountA ? rawAmountBN.toNumber() : liquidityInput.tokenMaxA.toNumber();\n    const amountB = fixAmountA ? liquidityInput.tokenMaxB.toNumber() : rawAmountBN.toNumber();\n    const normalizedAmountB = new BigNumber(amountB).dividedBy(10 ** decimalsB).toString();\n\n    const addLiquidityPayloadParams: AddLiquidityFixTokenParams = {\n      coinTypeA: pool.coinTypeA,\n      coinTypeB: pool.coinTypeB,\n      pool_id: pool.poolAddress,\n      tick_lower: lowerTick.toString(),\n      tick_upper: upperTick.toString(),\n      fix_amount_a: fixAmountA,\n      amount_a: amountA,\n      amount_b: amountB,\n      slippage,\n      // true means that it's the first liquidity add, so need to open one position\n      is_open: true,\n      // If these not empty, it will collect rewarder in this position, if client already open the position\n      rewarder_coin_types: [],\n      // If client already has one position, he can collect fees while adding liquidity\n      collect_fee: false,\n      // The position object id\n      pos_id: \"\",\n    };\n\n    return { addLiquidityPayload: addLiquidityPayloadParams, amountB: normalizedAmountB, curSqrtPrice };\n  }\n\n  /**\n   * Generates a transaction for adding liquidity to a pool.\n   *\n   * @public\n   * @param {Object} params - Parameters for adding liquidity to the pool transaction.\n   * @param {Pool} params.pool - The liquidity pool to which liquidity will be added.\n   * @param {string} params.coinAmountA - The amount of coinA to add to the liquidity pool.\n   * @param {number} params.decimalsA - The number of decimals for coinA.\n   * @param {number} params.decimalsB - The number of decimals for coinB.\n   * @param {number} params.slippage - The acceptable slippage percentage for the transaction.\n   * @param {string} params.publicKey - The public key of the transaction sender.\n   * @return {Promise<{ transaction: TransactionBlock, amountB: string }>} A promise that resolves to an object\n   * containing the transaction block for adding liquidity and the amount of coinB.\n   */\n  public async getAddLiquidityTransaction({\n    pool,\n    coinAmountA,\n    decimalsA,\n    decimalsB,\n    slippage,\n    publicKey,\n  }: {\n    pool: Pool;\n    coinAmountA: string;\n    decimalsA: number;\n    decimalsB: number;\n    slippage: number;\n    publicKey: string;\n  }): Promise<TransactionBlock> {\n    this.cetusSdk.senderAddress = publicKey;\n\n    const { addLiquidityPayload, curSqrtPrice } = this.getAddLiquidityPayload({\n      pool,\n      coinAmountA,\n      decimalsA,\n      decimalsB,\n      slippage,\n    });\n\n    const addLiquidityTransaction = await this.cetusSdk.Position.createAddLiquidityFixTokenPayload(\n      addLiquidityPayload,\n      {\n        slippage,\n        curSqrtPrice,\n      },\n    );\n\n    return addLiquidityTransaction;\n  }\n\n  /**\n   * Retrieves pool data for the specified pool ID.\n   *\n   * @public\n   * @param {string} poolId - The ID of the pool to retrieve.\n   * @return {Promise<Pool | null>} A promise that resolves to the pool data or null if no data is found.\n   */\n  public async getPool(poolId: string): Promise<Pool | null> {\n    try {\n      return await this.cetusSdk.Pool.getPool(poolId);\n    } catch (error) {\n      console.error(\"[Cetus.getPool] error occured:\", error);\n      return null;\n    }\n  }\n\n  /**\n   * Retrieves pools data for the specified pool IDs.\n   *\n   * @public\n   * @param {string[]} poolIds - The IDs of the pools to retrieve.\n   * @return {Promise<Pool | null>} A promise that resolves to the pools data or null if no data is found\n   * or error occured.\n   */\n  public async getPools(poolIds: string[]): Promise<Pool[] | null> {\n    try {\n      return await this.cetusSdk.Pool.getPools(poolIds);\n    } catch (error) {\n      console.error(\"[Cetus.getPools] error occured:\", error);\n      return null;\n    }\n  }\n\n  /**\n   * Retrieves a liquidity pool by coin types and tick spacing.\n   *\n   * @public\n   * @param {string} coinTypeA - The type of the first coin in the pool.\n   * @param {string} coinTypeB - The type of the second coin in the pool.\n   * @param {string} tickSpacing - The tick spacing of the pool.\n   * @return {Promise<LPList | undefined>} A promise that resolves to the liquidity pool with the specified\n   * coin types and tick spacing, or undefined if no pool is found.\n   */\n  public async getPoolByCoinTypesAndTickSpacing(\n    coinTypeA: string,\n    coinTypeB: string,\n    tickSpacing: string,\n  ): Promise<LPList | undefined> {\n    const cachedPools = this.poolsCache;\n    const foundPool = cachedPools.find((pool) => {\n      const processedCoinTypeA = isSuiCoinType(coinTypeA) ? LONG_SUI_COIN_TYPE : coinTypeA;\n      const processedCoinTypeB = isSuiCoinType(coinTypeB) ? LONG_SUI_COIN_TYPE : coinTypeB;\n      const processedPoolCoinA = isSuiCoinType(pool.coin_a_address) ? LONG_SUI_COIN_TYPE : pool.coin_a_address;\n      const processedPoolCoinB = isSuiCoinType(pool.coin_b_address) ? LONG_SUI_COIN_TYPE : pool.coin_b_address;\n\n      const tickSpacingMatch = pool.tick_spacing === tickSpacing;\n      const directMatch = processedPoolCoinA === processedCoinTypeA && processedPoolCoinB === processedCoinTypeB;\n      const reverseMatch = processedPoolCoinA === processedCoinTypeB && processedPoolCoinB === processedCoinTypeA;\n\n      return tickSpacingMatch && (directMatch || reverseMatch);\n    });\n\n    if (foundPool !== undefined) {\n      return foundPool;\n    }\n\n    const pools = await this.retrieveAllPoolsFromApi();\n    return pools.find(\n      (pool) =>\n        (pool.coin_a_address === coinTypeA || pool.coin_b_address === coinTypeA) &&\n        (pool.coin_a_address === coinTypeB || pool.coin_b_address === coinTypeB) &&\n        pool.tick_spacing === tickSpacing,\n    );\n  }\n\n  /**\n   * Retrieves CreatePoolEvents from an array of user events.\n   *\n   * @param {SuiEvent[]} userEvents - Array of user events.\n   * @return {SuiEvent[]} Array of CreatePoolEvents filtered from user events.\n   */\n  public getCreatePoolEventsFromUserEvents(userEvents: SuiEvent[]): SuiEvent[] {\n    const cetusCreatePoolEvent = `${this.cetusSDKConfig.clmm_pool.package_id}::factory::CreatePoolEvent`;\n\n    return userEvents.filter((event) => event.type === cetusCreatePoolEvent);\n  }\n\n  /**\n   * Retrieves the pools owned by a specific user.\n   *\n   * @description\n   * This method returns information about pools owned by a user, including the amounts of two\n   * different coins (`amountA` and `amountB`).\n   * The decimal precision of these amounts may vary depending on the availability of coin information.\n   * - If `getCoinByType2` returns valid decimal information for both coins, the amounts are adjusted accordingly.\n   * - If `getCoinByType2` returns null for either coin, the amounts are provided without decimal adjustment.\n   *\n   * To handle the potential discrepancy in decimal precision from the client-side,\n   * two additional parameters are introduced:\n   * - `amountAIsRaw`: A boolean indicating whether the returned `amountA` respects decimals (false) or is raw (true).\n   * - `amountBIsRaw`: A boolean indicating whether the returned `amountB` respects decimals (false) or is raw (true).\n   *\n   * It is recommended for the client to check these flags and adjust their processing logic accordingly.\n   *\n   * If either `amountAIsRaw` or `amountBIsRaw` is true, the corresponding\n   * amount should be used as-is without further decimal adjustments.\n   * If both flags are false, the amounts can be safely used after decimal adjustments.\n   *\n   * @public\n   * @param {SuiClient} provider - The provider for accessing the SUI client.\n   * @param {string} publicKey - The public key of the user whose pools are to be retrieved.\n   * @param {CoinManagerSingleton} coinManager - The CoinManagerSingleton instance for managing coin-related operations.\n   * @return {Promise<CetusOwnedPool[]>} A promise that resolves to an array of owned pools.\n   */\n  public async getOwnedPools(\n    provider: SuiClient,\n    publicKey: string,\n    coinManager: CoinManagerSingleton,\n  ): Promise<CetusOwnedPool[]> {\n    // TODO: Move all common events fetching (`queryEvents`) to a separate util function.\n    const pageCapacity = MAX_BATCH_EVENTS_PER_QUERY_EVENTS_REQUEST;\n    const allEvents: SuiEvent[] = [];\n    let nextCursor: EventId | undefined | null = null;\n    let events: PaginatedEvents = await provider.queryEvents({\n      query: { Sender: publicKey },\n      limit: pageCapacity,\n      cursor: nextCursor,\n    });\n\n    // Fetching and combining part\n    while (events.hasNextPage) {\n      const userEvents: SuiEvent[] = events.data;\n      allEvents.push(...userEvents);\n\n      nextCursor = events.nextCursor;\n      events = await provider.queryEvents({\n        query: { Sender: publicKey },\n        limit: pageCapacity,\n        cursor: nextCursor,\n      });\n    }\n\n    const userEvents: SuiEvent[] = events.data;\n    allEvents.push(...userEvents);\n\n    // Reducing part\n    const createPoolEvents: SuiEvent[] = this.getCreatePoolEventsFromUserEvents(allEvents);\n    const poolIds: string[] = createPoolEvents\n      .filter((event) => isCetusCreatePoolEventParsedJson(event.parsedJson))\n      // The false case must not occur since events not meeting the criteria have been filtered out above.\n      // This conditional statement primarily serves TypeScript type-checking purposes.\n      .map((event) => (isCetusCreatePoolEventParsedJson(event.parsedJson) ? event.parsedJson.pool_id : \"\"));\n\n    if (poolIds.length === 0) {\n      return [];\n    }\n\n    const pools: Pool[] | null = await this.getPools(poolIds);\n\n    if (pools === null) {\n      return [];\n    }\n\n    // We need `Promise.all` here to fetch coin metada to calculate `amountA` and `amountB` respecting decimals\n    return await Promise.all(\n      pools.map(async (pool) => {\n        // eslint-disable-next-line camelcase\n        const { name, poolAddress, coinTypeA, coinTypeB, coinAmountA, coinAmountB, fee_rate } = pool;\n        // Div by 10_000 because `fee_rate` is 100 in case it's 0.01% at UI, so 0.01 = 100 / 10_000.\n        const feeRate = new BigNumber(fee_rate).dividedBy(10_000).toString();\n\n        const poolInCache = this.poolsCache.find((pool) => pool.address === poolAddress);\n        let coinADecimals: number;\n        let coinBDecimals: number;\n\n        let coinSymbolA: string | undefined = undefined;\n        let coinSymbolB: string | undefined = undefined;\n\n        let amountAIsRaw: boolean;\n        let amountBIsRaw: boolean;\n\n        if (poolInCache !== undefined) {\n          coinADecimals = poolInCache.coin_a.decimals;\n          coinBDecimals = poolInCache.coin_b.decimals;\n\n          coinSymbolA = poolInCache.coin_a.symbol;\n          coinSymbolB = poolInCache.coin_b.symbol;\n\n          amountAIsRaw = false;\n          amountBIsRaw = false;\n        } else {\n          const coinAInfo = await coinManager.getCoinByType2(coinTypeA);\n          const coinBInfo = await coinManager.getCoinByType2(coinTypeB);\n\n          amountAIsRaw = !coinAInfo;\n          amountBIsRaw = !coinBInfo;\n\n          coinADecimals = coinAInfo?.decimals ?? 0;\n          coinBDecimals = coinBInfo?.decimals ?? 0;\n\n          coinSymbolA = coinAInfo?.symbol;\n          coinSymbolB = coinBInfo?.symbol;\n        }\n\n        const amountA = new BigNumber(coinAmountA).dividedBy(10 ** coinADecimals).toString();\n        const amountB = new BigNumber(coinAmountB).dividedBy(10 ** coinBDecimals).toString();\n\n        return {\n          name,\n          poolAddress,\n          coinTypeA,\n          coinTypeB,\n          coinSymbolA,\n          coinSymbolB,\n          amountA,\n          amountB,\n          feeRate,\n          amountAIsRaw,\n          amountBIsRaw,\n        };\n      }),\n    );\n  }\n\n  /**\n   * Creates a new instance of the Cetus SDK with the provided options.\n   * If `simulationAccountAddress` is not provided, it will use the simulation account from `this.cetusSDKConfig`.\n   * @param {string} [simulationAccountAddress] - The address for simulation account (optional).\n   * @return {CetusClmmSDK} A new instance of the Cetus SDK.\n   */\n  public getNewCetusSdk(simulationAccountAddress?: string) {\n    // TODO: We might not need to specify signerAddress here, depends on internal Cetus smart-contract structure\n    return new CetusClmmSDK({\n      ...this.cetusSDKConfig,\n      simulationAccount:\n        simulationAccountAddress !== undefined\n          ? { address: simulationAccountAddress }\n          : this.cetusSDKConfig.simulationAccount,\n    });\n  }\n\n  /**\n   * Checks whether paths exist in the graph between the specified coin types using the provided Cetus SDK instance.\n   * If no Cetus SDK instance is provided, the method uses the current Cetus SDK instance of the class.\n   * @param {string} coinTypeFrom - The coin type from which the path starts.\n   * @param {string} coinTypeTo - The coin type to which the path leads.\n   * @param {CetusClmmSDK} [cetusSdk=this.cetusSdk] - The Cetus SDK instance (optional, defaults to the current\n   * Cetus SDK instance).\n   * @return {boolean} True if paths exist in the graph between the specified coin types, otherwise false.\n   */\n  public checkPathsExistInGraph(coinTypeFrom: string, coinTypeTo: string, cetusSdk: CetusClmmSDK = this.cetusSdk) {\n    const graph = cetusSdk.Router.graph;\n\n    coinTypeFrom = isSuiCoinType(coinTypeFrom) ? LONG_SUI_COIN_TYPE : coinTypeFrom;\n    coinTypeTo = isSuiCoinType(coinTypeTo) ? LONG_SUI_COIN_TYPE : coinTypeTo;\n\n    const fromVertex = graph.getVertexByKey(coinTypeFrom);\n    const toVertex = graph.getVertexByKey(coinTypeTo);\n\n    const pathIters = graph.findAllPath(fromVertex, toVertex);\n    const allPaths = Array.from(pathIters);\n\n    return allPaths.length !== 0;\n  }\n\n  /**\n   * Retrieves route data using the graph for the specified coin types, input amount, and slippage percentage.\n   * @param {Object} params - Parameters for retrieving route data.\n   * @param {string} params.coinTypeFrom - The coin type from which the route starts.\n   * @param {string} params.coinTypeTo - The coin type to which the route leads.\n   * @param {string} params.inputAmount - The input amount for the route.\n   * @param {number} [params.slippagePercentage=10] - The slippage percentage for the route (optional, defaults to 10).\n   * @return {Promise<void>} A Promise that resolves when the route data is retrieved.\n   */\n  public async getRouteDataWithGraph({\n    coinTypeFrom,\n    coinTypeTo,\n    inputAmount,\n    slippagePercentage = 10,\n    publicKey,\n  }: {\n    coinTypeFrom: string;\n    coinTypeTo: string;\n    inputAmount: string;\n    slippagePercentage: number;\n    publicKey: string;\n  }) {\n    console.debug(\"Finding Cetus route separately, because all the providers have no route...\");\n\n    const routesByProviderMap: ProvidersToRouteDataMap = new Map();\n    const providersByOutputAmountsMap: Map<bigint, string> = new Map();\n\n    const sdk = this.getNewCetusSdk(publicKey); // We re-create Cetus sdk to avoid race-conditions\n    this.updateGraph(sdk);\n\n    const pathExist = this.checkPathsExistInGraph(coinTypeFrom, coinTypeTo, sdk);\n\n    if (!pathExist) {\n      throw new NoRoutesError(\"[CetusSingleton] There is no paths in Cetus graph.\");\n    }\n\n    const coinFrom: CommonCoinData | undefined = getCoinInfoFromCache(coinTypeFrom, this.coinsCache);\n    const coinTo: CommonCoinData | undefined = getCoinInfoFromCache(coinTypeTo, this.coinsCache);\n\n    if (coinFrom === undefined) {\n      throw new Error(`[CetusSingleton.getRouteDataWithGraph] Cannot find coin with address \"${coinTypeFrom}\".`);\n    } else if (coinTo === undefined) {\n      throw new Error(`[CetusSingleton.getRouteDataWithGraph] Cannot find coin with address \"${coinTypeTo}\".`);\n    }\n\n    let smartOutputAmountData: Awaited<ReturnType<typeof this.getSmartOutputAmountData>> | null;\n\n    try {\n      smartOutputAmountData = await this.getSmartOutputAmountData({\n        amountIn: inputAmount,\n        tokenFrom: coinFrom,\n        tokenTo: coinTo,\n        slippagePercentage,\n        cetusSdk: sdk,\n        useOnChainFallback: true,\n      });\n    } catch (error) {\n      if (error instanceof Error) {\n        console.error(\n          \"[CetusSingleton.getRouteDataWithGraph] Error occured while getSmartOutputAmountData:\",\n          error.message,\n        );\n      } else {\n        console.error(\"[CetusSingleton.getRouteDataWithGraph] Error occured while getSmartOutputAmountData:\", error);\n      }\n\n      smartOutputAmountData = null;\n    }\n\n    // In case route is not found or provider throw an error\n    if (smartOutputAmountData === null) {\n      routesByProviderMap.set(this.providerName, { provider: this, route: null });\n      providersByOutputAmountsMap.set(BigInt(0), this.providerName);\n    } else {\n      // In case route is found\n      routesByProviderMap.set(this.providerName, { provider: this, route: smartOutputAmountData.route });\n      providersByOutputAmountsMap.set(smartOutputAmountData.outputAmount, this.providerName);\n    }\n\n    const cetusOutputAmount: bigint = smartOutputAmountData?.outputAmount ?? BigInt(0);\n\n    if (cetusOutputAmount === BigInt(0)) {\n      throw new NoRoutesError(\"[CetusSingleton.getRouteDataWithGraph] Cetus output amount is 0 too.\");\n    }\n\n    return { routesByProviderMap, providersByOutputAmountsMap, cetusOutputAmount };\n  }\n\n  /**\n   * Removes the current instance of CetusSingleton.\n   *\n   * Disclaimer: While this method in this class is marked as public, it is strongly discouraged\n   * to use it directly unless you are certain about the behavior.\n   */\n  public static removeInstance() {\n    CetusSingleton._instance = undefined;\n  }\n\n  public buildDcaTxBlockAdapter = buildDcaTxBlock;\n}\n","import { PathLink } from \"@cetusprotocol/cetus-sui-clmm-sdk\";\nimport { CetusPathForStorage } from \"../../providers/cetus/types\";\nimport { Storage, StorageProperty, StorageValue } from \"../types\";\nimport { isCetusPathForStorageArray } from \"./typeguards\";\n\n/**\n * Returns Cetus paths cache from storage. If cache is not up to date, empty map is returned.\n */\nexport const getCetusPathsCache = async ({\n  storage,\n  provider,\n  updateCacheInterval,\n}: {\n  storage: Storage;\n  provider: string;\n  updateCacheInterval: number;\n}): Promise<Map<string, PathLink>> => {\n  let pathsCache: Map<string, PathLink> = new Map();\n\n  const paths: StorageValue = await storage.getCache({\n    provider,\n    property: StorageProperty.CetusPaths,\n  });\n\n  if (isCetusPathForStorageArray(paths?.value)) {\n    const timestamp = parseInt(paths.timestamp);\n    const cacheIsUpToDate = timestamp + updateCacheInterval > Date.now();\n\n    if (cacheIsUpToDate) {\n      pathsCache = paths.value.reduce((cache: Map<string, PathLink>, path: CetusPathForStorage) => {\n        const key = `${path.base}-${path.quote}`;\n        const addressMap = new Map(path.addressMap);\n\n        cache.set(key, { ...path, addressMap });\n\n        return cache;\n      }, new Map());\n    } else {\n      console.warn(`[getCetusPathsCache] ${provider} paths cache is not up to date.`);\n    }\n  } else if (paths === null) {\n    console.warn(`[getCetusPathsCache] ${provider} Received empty paths from strorage, paths === null `);\n  } else {\n    const stringifiedPath: string = JSON.stringify(paths.value[0]);\n    throw new Error(\n      `[${provider}] prefillCaches: paths from storage are not (PathLink[] or null). ` +\n        `Example of path: ${stringifiedPath}`,\n    );\n  }\n\n  return pathsCache;\n};\n","/* eslint-disable require-jsdoc */\n\nimport { PathLink } from \"@cetusprotocol/cetus-sui-clmm-sdk\";\nimport { CetusSingleton } from \"../../providers/cetus/cetus\";\nimport { CetusPathForStorage } from \"../../providers/cetus/types\";\nimport { Storage, StorageProperty } from \"../types\";\n\nexport async function storeCetusPathsCache({\n  provider,\n  storage,\n  pathsCache,\n}: {\n  provider: string;\n  storage: Storage;\n  pathsCache: ReturnType<CetusSingleton[\"getPaths\"]>;\n}): Promise<void> {\n  try {\n    const paths: PathLink[] = Array.from(pathsCache.values());\n\n    const pathsForStorage: CetusPathForStorage[] = paths.map((pathLink) => ({\n      base: pathLink.base,\n      quote: pathLink.quote,\n      addressMap: Array.from(pathLink.addressMap.entries()),\n    }));\n\n    await storage.setCache({\n      provider,\n      property: StorageProperty.CetusPaths,\n      value: { value: pathsForStorage, timestamp: Date.now().toString() },\n    });\n  } catch (error) {\n    console.error(`[storeCetusPathsCache] error for params: provider ${provider} `, error);\n\n    throw error;\n  }\n}\n","const SDKConfig = {\n  clmmConfig: {\n    pools_id: \"0xf699e7f2276f5c9a75944b37a0c5b5d9ddfd2471bf6242483b03ab2887d198d0\",\n    global_config_id: \"0xdaa46292632c3c4d8f31f23ea0f9b36a28ff3677e9684980e4438403a67a3d8f\",\n    global_vault_id: \"0xce7bceef26d3ad1f6d9b6f13a953f053e6ed3ca77907516481ce99ae8e588f2b\",\n    admin_cap_id: \"0x89c1a321291d15ddae5a086c9abc533dff697fde3d89e0ca836c41af73e36a75\",\n  },\n  cetusConfig: {\n    coin_list_id: \"0x8cbc11d9e10140db3d230f50b4d30e9b721201c0083615441707ffec1ef77b23\",\n    launchpad_pools_id: \"0x1098fac992eab3a0ab7acf15bb654fc1cf29b5a6142c4ef1058e6c408dd15115\",\n    clmm_pools_id: \"0x15b6a27dd9ae03eb455aba03b39e29aad74abd3757b8e18c0755651b2ae5b71e\",\n    admin_cap_id: \"0x39d78781750e193ce35c45ff32c6c0c3f2941fa3ddaf8595c90c555589ddb113\",\n    global_config_id: \"0x0408fa4e4a4c03cc0de8f23d0c2bbfe8913d178713c9a271ed4080973fe42d8f\",\n    coin_list_handle: \"0x49136005e90e28c4695419ed4194cc240603f1ea8eb84e62275eaff088a71063\",\n    launchpad_pools_handle: \"0x5e194a8efcf653830daf85a85b52e3ae8f65dc39481d54b2382acda25068375c\",\n    clmm_pools_handle: \"0x37f60eb2d9d227949b95da8fea810db3c32d1e1fa8ed87434fc51664f87d83cb\",\n  },\n};\n\n// mainnet\nexport const clmmMainnet = {\n  cetus_config: {\n    package_id: \"0x95b8d278b876cae22206131fb9724f701c9444515813042f54f0a426c9a3bc2f\",\n    published_at: \"0x95b8d278b876cae22206131fb9724f701c9444515813042f54f0a426c9a3bc2f\",\n    config: SDKConfig.cetusConfig,\n  },\n  clmm_pool: {\n    package_id: \"0x1eabed72c53feb3805120a081dc15963c204dc8d091542592abaf7a35689b2fb\",\n    published_at: \"0xc33c3e937e5aa2009cc0c3fdb3f345a0c3193d4ee663ffc601fe8b894fbc4ba6\",\n    version: 4,\n    config: SDKConfig.clmmConfig,\n  },\n  integrate: {\n    package_id: \"0xd43348b8879c1457f882b02555ba862f2bc87bcc31b16294ca14a82f608875d2\",\n    published_at: \"0xd43348b8879c1457f882b02555ba862f2bc87bcc31b16294ca14a82f608875d2\",\n    version: 2,\n  },\n  deepbook: {\n    package_id: \"0x000000000000000000000000000000000000000000000000000000000000dee9\",\n    published_at: \"0x000000000000000000000000000000000000000000000000000000000000dee9\",\n  },\n  deepbook_endpoint_v2: {\n    package_id: \"0x10b5eea7a286091241b69102a5e63ae444a27363ebe4ee7261fa6b688ae3daf5\",\n    published_at: \"0x10b5eea7a286091241b69102a5e63ae444a27363ebe4ee7261fa6b688ae3daf5\",\n  },\n  aggregatorUrl: \"https://api-sui.cetus.zone/router\",\n  swapCountUrl: \"https://api-sui.cetus.zone/v2/sui/swap/count\",\n};\n\nexport const CENTRALIZED_POOLS_INFO_ENDPOINT = \"https://api-sui.cetus.zone/v2/sui/pools_info\";\n\nexport const MIN_FETCH_BEST_ROUTE_TIMEOUT_DURATION = 4_000;\nexport const MAX_FETCH_BEST_ROUTE_TIMEOUT_DURATION = 5_500;\nexport const FETCH_BEST_ROUTE_ATTEMPTS_COUNT = 1;\n","import { CoinAsset, CoinNode, PathLink } from \"@cetusprotocol/cetus-sui-clmm-sdk\";\nimport { CoinsCache, PathsCache } from \"../types\";\nimport {\n  APIResponse,\n  CetusCreatePoolEventParsedJson,\n  CoinInfo,\n  CoinMap,\n  CoinNodeWithSymbol,\n  LPList,\n  PathMap,\n} from \"./types\";\n\n/* eslint-disable require-jsdoc */\nexport function isApiResponseValid(\n  response: APIResponse,\n): response is { code: 200; msg: \"OK\"; data: { lp_list: LPList[] } } {\n  return (\n    response.code === 200 &&\n    response.msg === \"OK\" &&\n    response.data !== undefined &&\n    Array.isArray(response.data.lp_list) &&\n    response.data.lp_list.length > 0 &&\n    response.data.lp_list.every(isLPListValid)\n  );\n}\n\nexport function isLPListValid(lpList: LPList): boolean {\n  return (\n    typeof lpList.symbol === \"string\" &&\n    typeof lpList.name === \"string\" &&\n    typeof lpList.decimals === \"number\" &&\n    typeof lpList.fee === \"string\" &&\n    typeof lpList.tick_spacing === \"string\" &&\n    typeof lpList.pool_type === \"string\" &&\n    typeof lpList.address === \"string\" &&\n    typeof lpList.coin_a_address === \"string\" &&\n    typeof lpList.coin_b_address === \"string\" &&\n    typeof lpList.is_closed === \"boolean\" &&\n    typeof lpList.price === \"string\" &&\n    isCoinInfoValid(lpList.coin_a) &&\n    isCoinInfoValid(lpList.coin_b) &&\n    isObjectValid(lpList.object)\n  );\n}\n\nexport function isCoinInfoValid(coinInfo: CoinInfo): boolean {\n  return (\n    typeof coinInfo.name === \"string\" &&\n    typeof coinInfo.symbol === \"string\" &&\n    typeof coinInfo.decimals === \"number\" &&\n    typeof coinInfo.address === \"string\" &&\n    typeof coinInfo.balance === \"string\"\n  );\n}\n\nexport function isObjectValid(obj: unknown): boolean {\n  return !!(obj && typeof obj === \"object\" && !Array.isArray(obj));\n}\n\nexport function coinExists(coin: string, coinMap: CoinMap): boolean {\n  return coinMap.has(coin);\n}\n\nexport function getCoinNode(coin: string, coinMap: CoinMap): CoinNode | undefined {\n  return coinMap.get(coin);\n}\n\nexport function hasPath(coinA: string, coinB: string, pathMap: PathMap): boolean {\n  const keyAB = `${coinA}-${coinB}`;\n  const keyBA = `${coinB}-${coinA}`;\n  return pathMap.has(keyAB) || pathMap.has(keyBA);\n}\n\nexport function getPoolsDataFromApiData({ poolsInfo }: { poolsInfo: LPList[] }) {\n  const coinMap: CoinMap = new Map();\n  const poolMap: PathMap = new Map();\n\n  for (const pool of poolsInfo) {\n    if (pool.is_closed) {\n      continue;\n    }\n\n    const coinA = pool.coin_a.address;\n    const coinB = pool.coin_b.address;\n\n    coinMap.set(coinA, {\n      symbol: pool.coin_a.symbol,\n      address: pool.coin_a.address,\n      type: pool.coin_a.address,\n      decimals: pool.coin_a.decimals,\n    });\n    coinMap.set(coinB, {\n      symbol: pool.coin_b.symbol,\n      address: pool.coin_b.address,\n      type: pool.coin_b.address,\n      decimals: pool.coin_b.decimals,\n    });\n\n    const pair = `${coinA}-${coinB}`;\n    const pathProvider = poolMap.get(pair);\n    if (pathProvider) {\n      pathProvider.addressMap.set(Number(pool.fee) * 100, pool.address);\n    } else {\n      poolMap.set(pair, {\n        base: coinA,\n        quote: coinB,\n        addressMap: new Map([[Number(pool.fee) * 100, pool.address]]),\n      });\n    }\n  }\n\n  const coins: CoinNodeWithSymbol[] = Array.from(coinMap.values());\n  const paths: PathLink[] = Array.from(poolMap.values());\n\n  return { coins, paths, coinMap, poolMap };\n}\n\nexport function getCoinsAndPathsCachesFromMaps({ paths, coins }: { paths: PathMap; coins: CoinMap }): {\n  coinsCache: CoinsCache;\n  pathsCache: PathsCache;\n} {\n  const coinsCache: CoinsCache = new Map();\n  const pathsCache: PathsCache = new Map();\n\n  paths.forEach((path: PathLink, pathKey: string) => {\n    pathsCache.set(pathKey, { base: path.base, quote: path.quote });\n  });\n\n  coins.forEach((coin: CoinNodeWithSymbol, coinType: string) => {\n    coinsCache.set(coinType, { symbol: coin.symbol, type: coin.type, decimals: coin.decimals });\n  });\n\n  return { coinsCache, pathsCache };\n}\n\nexport function isCetusCreatePoolEventParsedJson(data: unknown): data is CetusCreatePoolEventParsedJson {\n  return (\n    typeof data === \"object\" &&\n    data !== null &&\n    \"coin_type_a\" in data &&\n    typeof data.coin_type_a === \"string\" &&\n    \"coin_type_b\" in data &&\n    typeof data.coin_type_b === \"string\" &&\n    \"pool_id\" in data &&\n    typeof data.pool_id === \"string\" &&\n    \"tick_spacing\" in data &&\n    typeof data.tick_spacing === \"number\"\n  );\n}\n\nexport function getCoinMapFromCoinsCache(coinsCache: CoinsCache): CoinMap {\n  const coins: CoinMap = new Map();\n  coinsCache.forEach((coinData, coinType) => coins.set(coinType, { ...coinData, address: coinType }));\n\n  return coins;\n}\n\nexport const getMockedAssets = (tokenFrom: string, tokenTo: string): CoinAsset[] => [\n  {\n    coinAddress: tokenFrom,\n    coinObjectId: \"0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\n    balance: BigInt(\"9999999999999999999\"),\n  },\n  {\n    coinAddress: tokenTo,\n    coinObjectId: \"0xbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb\",\n    balance: BigInt(\"9999999999999999999\"),\n  },\n];\n","import { TransactionBlock } from \"@mysten/sui.js/transactions\";\nimport { TxBlock, Transaction, Arguments, Argument, Input } from \"../txBlock\";\nimport { fromArgument } from \"../utils\";\nimport { DCA_CONFIG } from \"../config\";\n\nconst DCA_ROUTER = \"cetus2\";\nlet InputIndex = 0;\n\nconst swapPatterns: Record<string, `${string}::${string}::${string}`> = {\n  \".*::router::swap$\": `${DCA_CONFIG.DCA_CONTRACT}::${DCA_ROUTER}::${\"swap\"}`,\n  \".*::router::swap_ab_bc$\": `${DCA_CONFIG.DCA_CONTRACT}::${DCA_ROUTER}::${\"swap_ab_bc\"}`,\n  \".*::router::swap_ab_cb$\": `${DCA_CONFIG.DCA_CONTRACT}::${DCA_ROUTER}::${\"swap_ab_cb\"}`,\n  \".*::router::swap_ba_bc$\": `${DCA_CONFIG.DCA_CONTRACT}::${DCA_ROUTER}::${\"swap_ba_bc\"}`,\n  \".*::router::swap_ba_cb$\": `${DCA_CONFIG.DCA_CONTRACT}::${DCA_ROUTER}::${\"swap_ba_cb\"}`,\n};\n\nconst checkPatterns: Record<string, `${string}::${string}::${string}`> = {\n  \".*::router::check_coin_threshold$\": `${DCA_CONFIG.DCA_CONTRACT}::${DCA_ROUTER}::${\"check_coin_threshold\"}`,\n};\n\ntype SwapParams = {\n  globalConfig: Argument;\n  poolA: Argument;\n  poolB?: Argument;\n  inputFunds: Argument;\n  outputFunds: Argument;\n  // If simple swap then exists, else no\n  a2b?: Argument;\n  byAmountIn: Argument;\n  amount0: Argument;\n  amount1?: Argument;\n  sqrtPriceLimit0: Argument;\n  sqrtPriceLimit1?: Argument;\n  arg8?: Argument; // TODO: Find out naming\n  clock: Argument;\n  outputThreshold: Argument;\n  dca: Argument;\n  gasGost: Argument;\n};\n\n/**\n * Builds a transaction block for Dollar Cost Averaging (DCA).\n * @param {TransactionBlock} txBlock - The transaction block to build upon.\n * @param {string} tokenFrom - The token to be exchanged from.\n * @param {string} tokenTo - The token to be exchanged to.\n * @param {string} dcaId - The ID for the Dollar Cost Averaging (DCA) operation.\n * @param {number} gasCost - The gas cost for the transaction.\n * @return {TransactionBlock} - The built transaction block for DCA.\n */\nexport function buildDcaTxBlock(\n  txBlock: TransactionBlock,\n  tokenFrom: string,\n  tokenTo: string,\n  dcaId: string,\n  gasCost: number,\n): TransactionBlock {\n  let isSimpleSwap = false;\n\n  // Initialize a TransactionBlock\n  const dcaBlock: TxBlock = {\n    version: 1,\n    transactions: [],\n    inputs: [],\n    gasConfig: txBlock.blockData.gasConfig,\n    sender: txBlock.blockData.sender,\n    expiration: txBlock.blockData.expiration,\n  };\n\n  // 1. Transaction to create Coin<tokenFrom>\n  dcaBlock.transactions.push({\n    kind: \"MoveCall\",\n    target: \"0x2::coin::zero\",\n    arguments: [],\n    typeArguments: [tokenFrom],\n  });\n\n  // 2. Transaction to create Coin<tokenTo>\n  dcaBlock.transactions.push({\n    kind: \"MoveCall\",\n    target: \"0x2::coin::zero\",\n    arguments: [],\n    typeArguments: [tokenTo],\n  });\n\n  const minOutput = findMinOutput(txBlock);\n  const swapPatternRegex = new RegExp(Object.keys(swapPatterns).join(\"|\"));\n\n  txBlock.blockData.transactions.forEach((transaction) => {\n    if (transaction.kind === \"MoveCall\" && transaction.target) {\n      const swapMatch: RegExpExecArray | null = swapPatternRegex.exec(transaction.target);\n\n      if (swapMatch) {\n        const parts = transaction.target.split(\"::\");\n        let newTarget: `${string}::${string}::${string}` = `${DCA_CONFIG.DCA_CONTRACT}::${DCA_ROUTER}::${parts[2]}`;\n        isSimpleSwap = newTarget === `${DCA_CONFIG.DCA_CONTRACT}::${DCA_ROUTER}::${\"swap\"}`;\n\n        // if pattern is swap --> route: if a2b == true --> swap_ab, else --> swap_ba\n        if (isSimpleSwap) {\n          // Check if the argument at index 6 (arguments[5]) has value \"true\" or \"false\"\n          const argument6 = transaction.arguments[5];\n          if (argument6 && argument6.kind === \"Input\" && argument6.value === true) {\n            // Modify the function name to swap_ab\n            newTarget = `${DCA_CONFIG.DCA_CONTRACT}::${DCA_ROUTER}::${\"swap_ab\"}`;\n          } else if (argument6 && argument6.kind === \"Input\" && argument6.value === false) {\n            // Modify the function name to swap_ba\n            newTarget = `${DCA_CONFIG.DCA_CONTRACT}::${DCA_ROUTER}::${\"swap_ba\"}`;\n          } else {\n            throw new Error(\"Incoherent function parameter\");\n          }\n        }\n\n        const swapParams: SwapParams = isSimpleSwap\n          ? {\n              globalConfig: fromArgument(transaction.arguments[0] as Argument, inputIdx()),\n              poolA: fromArgument(transaction.arguments[1] as Argument, inputIdx()),\n              inputFunds: { kind: \"Result\", index: 0 } as Argument,\n              outputFunds: { kind: \"Result\", index: 1 } as Argument,\n              a2b: fromArgument(transaction.arguments[4] as Argument, inputIdx()),\n              byAmountIn: fromArgument(transaction.arguments[5] as Argument, inputIdx()),\n              amount0: fromArgument(transaction.arguments[6] as Argument, inputIdx()),\n              sqrtPriceLimit0: fromArgument(transaction.arguments[7] as Argument, inputIdx()),\n              arg8: fromArgument(transaction.arguments[8] as Argument, inputIdx()),\n              clock: fromArgument(transaction.arguments[9] as Argument, inputIdx()),\n              outputThreshold: { kind: \"Input\", value: minOutput, index: inputIdx(), type: \"pure\" },\n              dca: { kind: \"Input\", value: dcaId, index: inputIdx(), type: \"object\" },\n              gasGost: { kind: \"Input\", value: gasCost, index: inputIdx(), type: \"pure\" },\n            }\n          : {\n              globalConfig: fromArgument(transaction.arguments[0] as Argument, inputIdx()),\n              poolA: fromArgument(transaction.arguments[1] as Argument, inputIdx()),\n              poolB: fromArgument(transaction.arguments[2] as Argument, inputIdx()),\n              inputFunds: { kind: \"Result\", index: 0 } as Argument,\n              outputFunds: { kind: \"Result\", index: 1 } as Argument,\n              byAmountIn: fromArgument(transaction.arguments[5] as Argument, inputIdx()),\n              amount0: fromArgument(transaction.arguments[6] as Argument, inputIdx()),\n              amount1: fromArgument(transaction.arguments[7] as Argument, inputIdx()),\n              sqrtPriceLimit0: fromArgument(transaction.arguments[8] as Argument, inputIdx()),\n              sqrtPriceLimit1: fromArgument(transaction.arguments[9] as Argument, inputIdx()),\n              clock: fromArgument(transaction.arguments[10] as Argument, inputIdx()),\n              outputThreshold: { kind: \"Input\", value: minOutput, index: inputIdx(), type: \"pure\" },\n              dca: { kind: \"Input\", value: dcaId, index: inputIdx(), type: \"object\" },\n              gasGost: { kind: \"Input\", value: gasCost, index: inputIdx(), type: \"pure\" },\n            };\n\n        const inputs = isSimpleSwap\n          ? [\n              swapParams.globalConfig as Input,\n              swapParams.poolA as Input,\n              swapParams.a2b as Input,\n              swapParams.byAmountIn as Input,\n              swapParams.amount0 as Input,\n              swapParams.sqrtPriceLimit0 as Input,\n              swapParams.arg8 as Input,\n              swapParams.clock as Input,\n              swapParams.outputThreshold as Input,\n              swapParams.dca as Input,\n              swapParams.gasGost as Input,\n            ]\n          : [\n              swapParams.globalConfig as Input,\n              swapParams.poolA as Input,\n              swapParams.poolB as Input,\n              swapParams.byAmountIn as Input,\n              swapParams.amount0 as Input,\n              swapParams.amount1 as Input,\n              swapParams.sqrtPriceLimit0 as Input,\n              swapParams.sqrtPriceLimit1 as Input,\n              swapParams.clock as Input,\n              swapParams.outputThreshold as Input,\n              swapParams.dca as Input,\n              swapParams.gasGost as Input,\n            ];\n\n        const args: Arguments = isSimpleSwap\n          ? [\n              swapParams.globalConfig,\n              swapParams.poolA,\n              swapParams.inputFunds,\n              swapParams.outputFunds,\n              // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n              swapParams.a2b!,\n              swapParams.byAmountIn,\n              swapParams.amount0,\n              swapParams.sqrtPriceLimit0,\n              // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n              swapParams.arg8!,\n              swapParams.clock,\n              swapParams.outputThreshold,\n              swapParams.dca,\n              swapParams.gasGost,\n            ]\n          : [\n              swapParams.globalConfig,\n              swapParams.poolA,\n              // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n              swapParams.poolB!,\n              swapParams.inputFunds,\n              swapParams.outputFunds,\n              swapParams.byAmountIn,\n              swapParams.amount0,\n              // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n              swapParams.amount1!,\n              swapParams.sqrtPriceLimit0,\n              // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n              swapParams.sqrtPriceLimit1!,\n              swapParams.clock,\n              swapParams.outputThreshold,\n              swapParams.dca,\n              swapParams.gasGost,\n            ];\n\n        const tx: Transaction = {\n          arguments: args,\n          kind: transaction.kind,\n          target: newTarget,\n          typeArguments: transaction.typeArguments,\n        };\n\n        dcaBlock.inputs.push(...inputs);\n        dcaBlock.transactions.push(tx);\n      }\n    }\n  });\n\n  const newTxBlock = TransactionBlock.from(JSON.stringify(dcaBlock));\n  return newTxBlock;\n}\n\n// eslint-disable-next-line\nfunction inputIdx(): number {\n  ++InputIndex;\n  return InputIndex - 1;\n}\n\n// eslint-disable-next-line\nfunction findMinOutput(txBlock: TransactionBlock): number {\n  const checkPatternRegex = new RegExp(Object.keys(checkPatterns).join(\"|\"));\n\n  for (const transaction of txBlock.blockData.transactions) {\n    if (transaction.kind === \"MoveCall\" && transaction.target) {\n      const checkMatch = checkPatternRegex.exec(transaction.target);\n\n      if (checkMatch) {\n        const arg1 = transaction.arguments[1] as {\n          kind: \"Input\";\n          index: number;\n          type: \"object\" | \"pure\" | undefined;\n          value: any;\n        };\n\n        const minOutputArg = arg1.value;\n\n        return minOutputArg;\n      }\n    }\n  }\n\n  // If the function hasn't returned by this point, no matching transaction was found\n  throw new Error(\"No suitable transaction found to extract minOutputArg.\");\n}\n","/* eslint-disable @typescript-eslint/no-explicit-any */\n/* eslint-disable require-jsdoc */\n\nimport { AggregatorResult, SplitPath, TickMath, ZERO } from \"@cetusprotocol/cetus-sui-clmm-sdk\";\nimport BN from \"bn.js\";\nimport { randomUUID } from \"crypto\";\nimport Decimal from \"decimal.js\";\nimport {\n  FETCH_BEST_ROUTE_ATTEMPTS_COUNT,\n  MAX_FETCH_BEST_ROUTE_TIMEOUT_DURATION,\n  MIN_FETCH_BEST_ROUTE_TIMEOUT_DURATION,\n} from \"./config\";\n\nexport async function fetchBestRoute({\n  coinTypeFrom,\n  coinTypeTo,\n  amount,\n  config: {\n    apiUrl,\n    attempts = FETCH_BEST_ROUTE_ATTEMPTS_COUNT,\n    maxTimeoutDuration = MAX_FETCH_BEST_ROUTE_TIMEOUT_DURATION,\n    minTimeoutDuration = MIN_FETCH_BEST_ROUTE_TIMEOUT_DURATION,\n  },\n  byAmountIn,\n}: {\n  coinTypeFrom: string;\n  coinTypeTo: string;\n  amount: string;\n  byAmountIn: boolean;\n  config: {\n    apiUrl: string;\n    attempts?: number;\n    minTimeoutDuration?: number;\n    maxTimeoutDuration?: number;\n  };\n}): Promise<AggregatorResult> {\n  const params = new URLSearchParams({\n    from: coinTypeFrom,\n    to: coinTypeTo,\n    amount: encodeURIComponent(amount),\n    by_amount_in: encodeURIComponent(byAmountIn),\n    order_split: encodeURIComponent(false),\n    external_router: encodeURIComponent(false),\n    request_id: encodeURIComponent(randomUUID()),\n  });\n\n  for (let i = 0; i < attempts; i++) {\n    try {\n      const timeout = Math.floor(Math.random() * (maxTimeoutDuration - minTimeoutDuration + 1)) + minTimeoutDuration;\n      const controller = new AbortController();\n      const timeoutId = setTimeout(() => controller.abort(), timeout);\n\n      const response = await fetch(`${apiUrl}?${params.toString()}`, {\n        signal: controller.signal,\n      });\n\n      clearTimeout(timeoutId);\n\n      if (response.status === 200) {\n        return parseJsonResult(await response.json());\n      } else {\n        throw new Error(\"Response status is not 200.\");\n      }\n    } catch (error) {\n      console.error(`[fetchBestRoute] Attempt ${i + 1} failed: ${error}`);\n    }\n  }\n\n  throw new Error(\"[fetchBestRoute] All attempts to fetch best route data failed.\");\n}\n\nfunction parseJsonResult(data: any): AggregatorResult {\n  const result: AggregatorResult = {\n    isExceed: data.is_exceed,\n    isTimeout: data.is_timeout,\n    inputAmount: data.input_amount,\n    outputAmount: data.output_amount,\n    fromCoin: data.from_coin,\n    toCoin: data.to_coin,\n    byAmountIn: data.by_amount_in,\n    splitPaths: data.split_paths.map((path: any) => {\n      const splitPath: SplitPath = {\n        pathIndex: path.path_index,\n        lastQuoteOutput: path.last_quote_output,\n        percent: path.percent,\n        basePaths: path.best_path.map((basePath: any) => {\n          return {\n            direction: basePath.direction,\n            label: basePath.label,\n            poolAddress: basePath.provider,\n            fromCoin: basePath.from_coin,\n            toCoin: basePath.to_coin,\n            outputAmount: basePath.output_amount,\n            inputAmount: basePath.input_amount,\n            feeRate: basePath.fee_rate,\n            currentSqrtPrice: new BN(basePath.current_sqrt_price.toString()),\n            afterSqrtPrice: basePath.label === \"Cetus\" ? new BN(basePath.after_sqrt_price.toString()) : ZERO,\n            fromDecimal: basePath.from_decimal,\n            toDecimal: basePath.to_decimal,\n            currentPrice: calculatePrice(\n              new BN(basePath.current_sqrt_price.toString()),\n              basePath.from_decimal,\n              basePath.to_decimal,\n              basePath.direction,\n              basePath.label,\n            ),\n          };\n        }),\n        inputAmount: path.input_amount,\n        outputAmount: path.output_amount,\n      };\n      return splitPath;\n    }),\n  };\n  return result;\n}\n\nfunction calculatePrice(\n  currentSqrtPrice: BN,\n  fromDecimals: number,\n  toDecimals: number,\n  a2b: boolean,\n  label: string,\n): Decimal {\n  const decimalA = a2b ? fromDecimals : toDecimals;\n  const decimalB = a2b ? toDecimals : fromDecimals;\n  if (label === \"Cetus\") {\n    const price = TickMath.sqrtPriceX64ToPrice(currentSqrtPrice, decimalA, decimalB);\n    return price;\n  }\n\n  const price = new Decimal(currentSqrtPrice.toString()).div(new Decimal(10).pow(new Decimal(decimalB + 9 - decimalA)));\n  return price;\n}\n","import { getCoinsFlowX, getPairs, swapExactInput } from \"@flowx-pkg/ts-sdk\";\nimport { TransactionBlock } from \"@mysten/sui.js/transactions\";\nimport { EventEmitter } from \"../../emitters/EventEmitter\";\nimport { CommonCoinData, UpdatedCoinsCache } from \"../../managers/types\";\nimport { InMemoryStorageSingleton } from \"../../storages/InMemoryStorage\";\nimport { Storage } from \"../../storages/types\";\nimport { exitHandlerWrapper } from \"../common\";\nimport { CacheOptions, CoinsCache, CommonPoolData, IPoolProvider, PathsCache } from \"../types\";\nimport { convertSlippage } from \"../utils/convertSlippage\";\nimport { getCoinInfoFromCache } from \"../utils/getCoinInfoFromCache\";\nimport { getCoinsAndPathsCaches } from \"../../storages/utils/getCoinsAndPathsCaches\";\nimport { storeCaches } from \"../../storages/utils/storeCaches\";\nimport { calculateAmountOutInternal } from \"./calculateAmountOutInternal\";\nimport {\n  CoinNode,\n  ExtendedSwapCalculatedOutputDataType,\n  ExtractedPairSettingsType,\n  FlowxOptions,\n  ShortCoinMetadata,\n} from \"./types\";\nimport { getCoinsMap, getPathsMap, isCoinListValid, isPairListValid } from \"./utils\";\nimport { getCoinsMetadataCache } from \"../../storages/utils/getCoinsMetadataCache\";\nimport { swapExactInputDoctored } from \"../../managers/dca/adapterUtils/flowxUtils\";\nimport { buildDcaTxBlock } from \"../../managers/dca/adapters/flowxAdapter\";\n\n/**\n * @class FlowxSingleton\n * @extends EventEmitter\n * @implements {IPoolProvider<FlowxSingleton>}\n * @description Singleton class for Flowx.\n *\n * Note: If using `lazyLoading: true` with any storage configuration in a serverless/cloud functions environment,\n * be aware that each invocation of your cloud function will start cache population from scratch.\n * This may lead to unexpected behavior when using different SDK methods. To avoid this and minimize the time\n * for cache population, consider using `lazyLoading: false` along with passing a persistent\n * storage adapter (external, e.g., Redis or any kind of DB) to the ProviderSingleton.\n */\nexport class FlowxSingleton extends EventEmitter implements IPoolProvider<FlowxSingleton> {\n  private static _instance: FlowxSingleton | undefined;\n  public providerName = \"Flowx\";\n  public isSmartRoutingAvailable = false;\n  public pathsCache: PathsCache = new Map();\n  public coinsCache: CoinsCache = new Map();\n  public coinsMetadataCache: ShortCoinMetadata[] = [];\n  private cacheOptions: CacheOptions;\n  private intervalId: NodeJS.Timeout | undefined;\n  private storage: Storage;\n\n  /**\n   * @constructor\n   * @param {Omit<FlowxOptions, \"lazyLoading\">} options - The options for FlowxSingleton.\n   */\n  private constructor(options: Omit<FlowxOptions, \"lazyLoading\">) {\n    super();\n    const { updateIntervally = true, ...restCacheOptions } = options.cacheOptions;\n    this.cacheOptions = { updateIntervally, ...restCacheOptions };\n    this.storage = options.cacheOptions.storage ?? InMemoryStorageSingleton.getInstance();\n  }\n\n  /**\n   * @public\n   * @method getInstance\n   * @description Gets the singleton instance of FlowxSingleton.\n   * @param {FlowxOptions} [options] - Options for FlowxSingleton.\n   * @return {Promise<FlowxSingleton>} The singleton instance of FlowxSingleton.\n   */\n  public static async getInstance(options?: FlowxOptions): Promise<FlowxSingleton> {\n    if (!FlowxSingleton._instance) {\n      if (options === undefined) {\n        throw new Error(\"[Flowx] Options are required in arguments to create instance.\");\n      }\n\n      const { cacheOptions, lazyLoading = true } = options;\n\n      const instance = new FlowxSingleton({ cacheOptions });\n      lazyLoading ? instance.init() : await instance.init();\n      FlowxSingleton._instance = instance;\n    }\n\n    return FlowxSingleton._instance;\n  }\n\n  /**\n   * @private\n   * @method init\n   * @description Initializes the FlowxSingleton instance.\n   * @return {Promise<void>} A Promise that resolves when initialization is complete.\n   */\n  private async init() {\n    console.debug(`[${this.providerName}] Singleton initiating.`);\n\n    await this.fillCacheFromStorage();\n    await this.updateCaches();\n    this.cacheOptions.updateIntervally && this.updateCachesIntervally();\n\n    this.bufferEvent(\"cachesUpdate\", this.getCoins());\n  }\n\n  /**\n   * Fills the cache from storage asynchronously.\n   *\n   * @private\n   * @return {Promise<void>} A promise that resolves when the cache is filled from storage.\n   */\n  private async fillCacheFromStorage(): Promise<void> {\n    try {\n      const { coinsCache, pathsCache } = await getCoinsAndPathsCaches({\n        storage: this.storage,\n        provider: this.providerName,\n        updateCacheInterval: this.cacheOptions.updateIntervalInMs,\n      });\n      const coinsMetadataCache = await getCoinsMetadataCache({\n        storage: this.storage,\n        provider: this.providerName,\n        updateCacheInterval: this.cacheOptions.updateIntervalInMs,\n      });\n\n      this.coinsCache = coinsCache;\n      this.pathsCache = pathsCache;\n      this.coinsMetadataCache = coinsMetadataCache;\n    } catch (error) {\n      console.error(`[${this.providerName}] fillCacheFromStorage failed:`, error);\n    }\n  }\n\n  /**\n   * Checks if the storage cache is empty.\n   *\n   * @private\n   * @return {boolean} True if the storage cache is empty, false otherwise.\n   */\n  private isStorageCacheEmpty() {\n    const isCacheEmpty =\n      this.coinsCache.size === 0 || this.pathsCache.size === 0 || this.coinsMetadataCache.length === 0;\n\n    return isCacheEmpty;\n  }\n\n  /**\n   * @private\n   * @method updateCaches\n   * @description Updates the caches for paths and coins.\n   * @return {Promise<void>} A Promise that resolves when caches are updated.\n   */\n  private async updateCaches({ force }: { force: boolean } = { force: false }): Promise<void> {\n    const isCacheEmpty = this.isStorageCacheEmpty();\n\n    if (isCacheEmpty || force) {\n      try {\n        await this.updatePathsCache();\n        await this.updateCoinsCache();\n        this.emit(\"cachesUpdate\", this.getCoins());\n\n        await storeCaches({\n          provider: this.providerName,\n          storage: this.storage,\n          coinsCache: this.getCoins(),\n          pathsCache: this.getPaths(),\n          coinsMetadataCache: this.coinsMetadataCache,\n        });\n\n        console.debug(\"[FlowX] Caches are updated and stored.\");\n      } catch (error) {\n        console.error(\"[Flowx] Caches update failed:\", error);\n      }\n    }\n  }\n\n  /**\n   * @private\n   * @method updateCachesIntervally\n   * @description Updates the caches at regular intervals.\n   * @return {void}\n   */\n  private updateCachesIntervally(): void {\n    let isUpdatingCurrently = false;\n    this.intervalId = setInterval(async () => {\n      try {\n        if (isUpdatingCurrently) {\n          return;\n        }\n        isUpdatingCurrently = true;\n        await this.updateCaches({ force: true });\n      } finally {\n        isUpdatingCurrently = false;\n      }\n    }, this.cacheOptions.updateIntervalInMs);\n\n    exitHandlerWrapper({ intervalId: this.intervalId, providerName: this.providerName });\n  }\n\n  /**\n   * @private\n   * @method updateCoinsCache\n   * @description Updates the coins cache.\n   * @return {Promise<void>} A Promise that resolves when the coins cache is updated.\n   */\n  private async updateCoinsCache(): Promise<void> {\n    const coinList = await getCoinsFlowX();\n    const isValidResponse = isCoinListValid(coinList);\n\n    if (!isValidResponse) {\n      console.error(\"[Flowx] Coins response:\", coinList);\n      throw new Error(\"Coins response from API is not valid\");\n    }\n\n    const { coinMap } = getCoinsMap({ coinList });\n    // TODO: Remove that .map to separate method\n    this.coinsMetadataCache = coinList.map((coin) => ({ type: coin.type, decimals: coin.decimals }));\n    this.coinsCache = coinMap;\n  }\n\n  /**\n   * @private\n   * @method updatePathsCache\n   * @description Updates the paths cache.\n   * @return {Promise<void>} A Promise that resolves when the paths cache is updated.\n   */\n  private async updatePathsCache(): Promise<void> {\n    const pairs: ExtractedPairSettingsType[] = await getPairs();\n    const isValidResponse = isPairListValid(pairs);\n\n    if (!isValidResponse) {\n      console.error(\"[Flowx] Pairs response:\", pairs);\n      throw new Error(\"Pairs response from API is not valid\");\n    }\n\n    this.pathsCache = getPathsMap(pairs);\n  }\n\n  /**\n   * @public\n   * @method getCoins\n   * @description Gets the updated coins cache.\n   * @return {UpdatedCoinsCache} Updated coins cache.\n   */\n  public getCoins(): UpdatedCoinsCache {\n    const data = Array.from(this.coinsCache.values());\n\n    return { provider: this.providerName, data };\n  }\n\n  /**\n   * @public\n   * @method getPaths\n   * @description Gets the paths cache.\n   * @return {Map<string, CommonPoolData>} Paths cache.\n   */\n  public getPaths(): Map<string, CommonPoolData> {\n    return this.pathsCache;\n  }\n\n  /**\n   * @public\n   * @method getRouteData\n   * @description Gets route data for a given pair of coins.\n   * @param {Object} options - Options for getting route data.\n   * @param {string} options.coinTypeFrom - The coin type to swap from.\n   * @param {string} options.coinTypeTo - The coin type to swap to.\n   * @param {string} options.inputAmount - The input amount for the swap.\n   * @param {number} options.slippagePercentage - The slippage percentage.\n   * @param {string} options.publicKey - The public key for the swap.\n   * @return {Promise<{ outputAmount: bigint, route: ExtendedSwapCalculatedOutputDataType }>} Route data.\n   */\n  public async getRouteData({\n    coinTypeFrom,\n    coinTypeTo,\n    inputAmount,\n  }: {\n    coinTypeFrom: string;\n    coinTypeTo: string;\n    inputAmount: string;\n    slippagePercentage: number;\n    publicKey: string;\n  }): Promise<{ outputAmount: bigint; route: ExtendedSwapCalculatedOutputDataType }> {\n    const tokenFromCoinNode: CommonCoinData | undefined = getCoinInfoFromCache(coinTypeFrom, this.coinsCache);\n    const tokenToCoinNode: CommonCoinData | undefined = getCoinInfoFromCache(coinTypeTo, this.coinsCache);\n\n    if (!tokenFromCoinNode) {\n      throw new Error(`Coin ${coinTypeFrom} does not exist.`);\n    }\n\n    if (!tokenToCoinNode) {\n      throw new Error(`Coin ${coinTypeTo} does not exist.`);\n    }\n\n    const { outputAmount, route } = await this.getSmartOutputAmountData({\n      amountIn: inputAmount,\n      tokenFrom: { address: tokenFromCoinNode.type, ...tokenFromCoinNode },\n      tokenTo: { address: tokenToCoinNode.type, ...tokenToCoinNode },\n    });\n\n    return { outputAmount, route };\n  }\n\n  /**\n   * @private\n   * @method getSmartOutputAmountData\n   * @description Gets the smart output amount data for a swap.\n   * @param {Object} options - Options for getting smart output amount data.\n   * @param {string} options.amountIn - The input amount for the swap.\n   * @param {CoinNode} options.tokenFrom - The coin node to swap from.\n   * @param {CoinNode} options.tokenTo - The coin node to swap to.\n   * @return {Promise<{ outputAmount: bigint, route: ExtendedSwapCalculatedOutputDataType }>} Smart output amount data.\n   */\n  private async getSmartOutputAmountData({\n    amountIn,\n    tokenFrom,\n    tokenTo,\n  }: {\n    amountIn: string;\n    tokenFrom: CoinNode;\n    tokenTo: CoinNode;\n  }) {\n    const swapData = await calculateAmountOutInternal(amountIn, tokenFrom, tokenTo, this.coinsMetadataCache);\n\n    return { outputAmount: BigInt(swapData.amountOut.decimalAmount), route: { ...swapData, tokenFrom, tokenTo } };\n  }\n\n  /**\n   * @public\n   * @method getSwapTransaction\n   * @description Gets the swap transaction data.\n   * @param {Object} options - Options for getting swap transaction data.\n   * @param {ExtendedSwapCalculatedOutputDataType} options.route - The route for the swap.\n   * @param {string} options.publicKey - The public key for the swap.\n   * @param {number} options.slippagePercentage - The slippage percentage.\n   * @return {Promise<TransactionBlock>} Swap transaction data.\n   */\n  public async getSwapTransaction({\n    route,\n    publicKey,\n    slippagePercentage,\n  }: {\n    route: ExtendedSwapCalculatedOutputDataType;\n    publicKey: string;\n    slippagePercentage: number;\n  }) {\n    const absoluteSlippage = convertSlippage(slippagePercentage);\n\n    const legacyTxBlock = await swapExactInput(\n      false, // it should be false for now\n      route.amountIn, // amount want to swap\n      route.amountOut, // amount want to receive\n      route.trades, // trades from calculate amount\n      route.tokenFrom, // coin In data\n      route.tokenTo, // coin Out data\n      publicKey,\n      absoluteSlippage, // slippage (0.05%)\n    );\n\n    const txBlock = new TransactionBlock(TransactionBlock.from(legacyTxBlock.serialize()));\n\n    return txBlock;\n  }\n\n  /**\n   * @public\n   * @method getSwapTransaction\n   * @description Gets the swap transaction data.\n   * @param {Object} options - Options for getting swap transaction data.\n   * @param {ExtendedSwapCalculatedOutputDataType} options.route - The route for the swap.\n   * @param {string} options.publicKey - The public key for the swap.\n   * @param {number} options.slippagePercentage - The slippage percentage.\n   * @return {Promise<TransactionBlock>} Swap transaction data.\n   */\n  public async getSwapTransactionDoctored({\n    route,\n    publicKey,\n    slippagePercentage,\n  }: {\n    route: ExtendedSwapCalculatedOutputDataType;\n    publicKey: string;\n    slippagePercentage: number;\n  }) {\n    const absoluteSlippage = convertSlippage(slippagePercentage);\n\n    const legacyTxBlock = await swapExactInputDoctored(\n      false, // it should be false for now\n      route.amountIn, // amount want to swap\n      route.amountOut, // amount want to receive\n      route.trades, // trades from calculate amount\n      route.tokenFrom, // coin In data\n      route.tokenTo, // coin Out data\n      publicKey,\n      absoluteSlippage, // slippage (0.05%)\n    );\n\n    const txBlock = new TransactionBlock(TransactionBlock.from(legacyTxBlock.serialize()));\n\n    return txBlock;\n  }\n\n  /**\n   * Removes the current instance of FlowxSingleton.\n   *\n   * Disclaimer: While this method in this class is marked as public, it is strongly discouraged\n   * to use it directly unless you are certain about the behavior.\n   */\n  public static removeInstance() {\n    FlowxSingleton._instance = undefined;\n  }\n\n  public buildDcaTxBlockAdapter = buildDcaTxBlock;\n}\n","/* eslint-disable new-cap */\n\nimport { getPools, getSmartRoute } from \"@flowx-pkg/ts-sdk\";\nimport { BigNumber as BNumber } from \"bignumber.js\";\n\nimport {\n  CoinNode,\n  ExtractedAmountType,\n  ExtractedIPoolsInfoType,\n  ExtractedPairSettingsType,\n  ExtractedSmartRouteType,\n  ExtractedSwapCalculatedOutputDataType,\n  ShortCoinMetadata,\n} from \"./types\";\n\nexport const getReserveByCoinType = (coinX: string, pairSetting: ExtractedIPoolsInfoType) => {\n  if (coinX === pairSetting.coinX) {\n    return {\n      reserveX: pairSetting.reserveX?.fields?.balance || \"0\",\n      reserveY: pairSetting.reserveY?.fields?.balance || \"0\",\n    };\n  }\n\n  return {\n    reserveX: pairSetting.reserveY?.fields?.balance || \"0\",\n    reserveY: pairSetting.reserveX?.fields?.balance || \"0\",\n  };\n};\n\nexport const getAmountOut = (amountIn: string | number, reserveIn: string, reserveOut: string, fee: number): string => {\n  const amountWithFee = BigNumberInstance(amountIn).multipliedBy(1 - fee);\n  const numerator = amountWithFee.multipliedBy(reserveOut);\n  const denominator = amountWithFee.plus(reserveIn);\n\n  return numerator.dividedBy(denominator).toFixed(0);\n};\n\nconst _getAmountOut = (\n  pair: ExtractedPairSettingsType,\n  _amountIn: string | number,\n  coinIn: string,\n  poolInfos: ExtractedIPoolsInfoType[],\n) => {\n  const poolDetail = poolInfos.find((item) => item.objectId === pair.lpObjectId);\n\n  if (poolDetail === undefined) {\n    throw new Error(\"Empty pool detail\");\n  }\n\n  if (poolDetail.feeRate === undefined) {\n    throw new Error(\"Empty feeRate\");\n  }\n\n  const reserve = getReserveByCoinType(coinIn, poolDetail);\n  return getAmountOut(_amountIn, reserve.reserveX, reserve.reserveY, poolDetail.feeRate);\n};\nexport const calculateAmountOutFromPath = (\n  amount: string | number,\n  coinInType: string,\n  tradAbles: ExtractedPairSettingsType[],\n  poolInfos: ExtractedIPoolsInfoType[],\n): ExtractedSmartRouteType => {\n  const smartRoute: ExtractedSmartRouteType = {};\n  smartRoute.amountIn = amount;\n  smartRoute.routes = [];\n  let amountOut = amount;\n  let lpOutType = coinInType;\n\n  for (let i = 0; i < tradAbles?.length; i++) {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const route: any = {};\n    route.coinTypeIn = lpOutType;\n    route.amountIn = amountOut;\n\n    amountOut = _getAmountOut(tradAbles[i], amountOut, lpOutType, poolInfos);\n    lpOutType = tradAbles[i].coinYType == lpOutType ? tradAbles[i].coinXType : tradAbles[i].coinYType;\n\n    route.coinTypeOut = lpOutType;\n    route.amountOut = amountOut;\n    route.pair = tradAbles[i];\n\n    smartRoute.routes.push(route);\n  }\n\n  smartRoute.amountOut = amountOut;\n  return smartRoute;\n};\n\nexport const LP_DECIMAL = 9;\n\nBNumber.config({\n  DECIMAL_PLACES: 1000,\n  EXPONENTIAL_AT: [-1000, 1000],\n  ROUNDING_MODE: 3,\n});\nexport const BigNumber = BNumber;\nexport const BigNumberInstance = (value: string | number): BNumber => new BigNumber(value);\nexport const BIG_ZERO = BigNumberInstance(0);\nexport const BIG_ONE = BigNumberInstance(1);\nexport const BIG_NINE = BigNumberInstance(9);\nexport const BIG_TEN = BigNumberInstance(10);\n\nexport const getBalanceAmount = (amount: string | number, decimals = LP_DECIMAL) => {\n  return BigNumberInstance(amount).div(BIG_TEN.pow(decimals));\n};\n\nexport const getDecimalAmount = (amount: string | number, decimals = LP_DECIMAL) => {\n  return BigNumberInstance(amount).times(BIG_TEN.pow(decimals)).toFixed();\n};\n\nexport const calculateAmountOutInternal = async (\n  value: string | number,\n  coinIn: CoinNode,\n  coinOut: CoinNode,\n  coins: ShortCoinMetadata[],\n): Promise<ExtractedSwapCalculatedOutputDataType> => {\n  const { poolInfos } = await getPools();\n  const decimalInAmount = BigNumberInstance(getDecimalAmount(value, coinIn.decimals)).toFixed(0);\n  const amountInFormat = getBalanceAmount(\n    decimalInAmount,\n    coins.find((coin) => coin.type === coinIn.type)?.decimals,\n  ).toFixed();\n\n  const amountInNewState: ExtractedAmountType = {\n    decimalAmount: decimalInAmount,\n    amount: amountInFormat,\n  };\n\n  const trades = await getSmartRoute(decimalInAmount, coinIn.type, coinOut.type, true);\n\n  const smartRoute = calculateAmountOutFromPath(decimalInAmount, coinIn.type, trades, poolInfos);\n  const decimalOutAmount = smartRoute.amountOut;\n\n  if (decimalOutAmount === undefined) {\n    throw new Error(\"Decimal amount out is undefined\");\n  }\n\n  const amountOutFormat = getBalanceAmount(\n    decimalOutAmount,\n    coins.find((coin) => coin.type === coinOut.type)?.decimals,\n  ).toFixed();\n\n  const amountOutNewState: ExtractedAmountType = {\n    decimalAmount: decimalOutAmount,\n    amount: amountOutFormat,\n  };\n  return {\n    amountIn: amountInNewState,\n    amountOut: amountOutNewState,\n    trades,\n    smartRoute,\n  };\n};\n","/* eslint-disable require-jsdoc */\n\nimport { CoinsCache, CommonPoolData } from \"../types\";\nimport { ExtractedCoinMetadataListType, ExtractedCoinMetadataType, ExtractedPairSettingsType } from \"./types\";\n\nexport function getCoinsMap({ coinList }: { coinList: ExtractedCoinMetadataListType }) {\n  const coinMap: CoinsCache = coinList.reduce((acc, el) => {\n    if (el.type === undefined || el.decimals === undefined) {\n      console.debug(\"flowx [getPoolsMap] no decimals or type for coin: \", el);\n    }\n\n    acc.set(el.type, { type: el.type, decimals: el.decimals, symbol: el.name });\n\n    return acc;\n  }, new Map());\n\n  const coins = {\n    coins: Array.from(coinMap.values()),\n  };\n\n  return { coins, coinMap };\n}\n\nexport function getPathsMap(pairs: ExtractedPairSettingsType[]): Map<string, CommonPoolData> {\n  return pairs.reduce((map: Map<string, CommonPoolData>, pair: ExtractedPairSettingsType) => {\n    const base: string = pair.coinXType;\n    const quote: string = pair.coinYType;\n\n    const commonPoolData: CommonPoolData = {\n      base,\n      quote,\n    };\n    const poolKey = `${base}-${quote}`;\n\n    map.set(poolKey, commonPoolData);\n    return map;\n  }, new Map());\n}\n\nexport function isCoinListValid(coinList: ExtractedCoinMetadataListType): boolean {\n  return Array.isArray(coinList) && coinList.every(isCoinMetadataValid);\n}\n\nexport function isCoinMetadataValid(coinMetadata: ExtractedCoinMetadataType): boolean {\n  return (\n    typeof coinMetadata.decimals === \"number\" &&\n    typeof coinMetadata.type === \"string\" &&\n    (typeof coinMetadata.symbol === \"string\" || coinMetadata.symbol === undefined)\n  );\n}\n\nexport function isPairSettingValid(pairSetting: ExtractedPairSettingsType): boolean {\n  return typeof pairSetting.coinXType === \"string\" && typeof pairSetting.coinYType === \"string\";\n}\n\nexport function isPairListValid(pairList: ExtractedPairSettingsType[]): boolean {\n  return Array.isArray(pairList) && pairList.every(isPairSettingValid);\n}\n","import { ExtractedCoinMetadataType } from \"../../providers/flowx/types\";\nimport { StorageValue, StorageProperty, Storage } from \"../types\";\nimport { isShortCoinMetadataArray } from \"./typeguards\";\n\n/**\n * Returns coins metadata cache from storage. If cache is not up to date, empty array is returned.\n */\nexport async function getCoinsMetadataCache({\n  storage,\n  provider,\n  updateCacheInterval,\n}: {\n  storage: Storage;\n  provider: string;\n  updateCacheInterval: number;\n}): Promise<ExtractedCoinMetadataType[]> {\n  let coinsMetadataCache: ExtractedCoinMetadataType[] = [];\n\n  const coinsMetadata: StorageValue = await storage.getCache({\n    provider: provider,\n    property: StorageProperty.CoinsMetadata,\n  });\n\n  if (isShortCoinMetadataArray(coinsMetadata?.value)) {\n    const timestamp = parseInt(coinsMetadata.timestamp);\n    const cacheIsUpToDate = timestamp + updateCacheInterval > Date.now();\n\n    if (cacheIsUpToDate) {\n      coinsMetadataCache = coinsMetadata.value;\n    } else {\n      console.warn(`[getCoinsMetadataCache] ${provider} coins metadata cache is not up to date.`);\n    }\n  } else if (coinsMetadata === null) {\n    console.warn(\n      `[getCoinsMetadataCache] ${provider} Received empty coinsMetadataCache from strorage,\n      coinsMetadataCache === null `,\n    );\n  } else {\n    const stringifiedCoinMetadata: string = JSON.stringify(coinsMetadata.value[0]);\n    throw new Error(\n      `[${provider}] getCoinsMetadataCache: coins metadata from storage is not ` +\n        `(ExtractedCoinMetadataType[] or null). Example of coin metadata: ${stringifiedCoinMetadata}`,\n    );\n  }\n\n  return coinsMetadataCache;\n}\n","import { TransactionBlock } from \"@mysten/sui.js/transactions\";\nimport { BigNumberInstance } from \"../../../providers/flowx/calculateAmountOutInternal\";\nimport { estimateDealine } from \"@flowx-pkg/ts-sdk\";\n\nexport const CONTAINER_OBJECT_ID = \"0xb65dcbf63fd3ad5d0ebfbf334780dc9f785eff38a4459e37ab08fa79576ee511\";\nexport const CLOCK_ID = \"0x0000000000000000000000000000000000000000000000000000000000000006\";\nexport const PACKAGE_OBJECT_ID = \"0xba153169476e8c3114962261d1edc70de5ad9781b83cc617ecc8c1923191cae0\";\n\nexport const FUNCTION = {\n  SWAP_EXACT_OUTPUT: \"swap_exact_output\",\n  SWAP_EXACT_INPUT: \"swap_exact_input\",\n  SWAP_EXACT_INPUT_DOUBLEHOP: \"swap_exact_input_doublehop\",\n  SWAP_EXACT_OUTPUT_DOUBLEHOP: \"swap_exact_output_doublehop\",\n  SWAP_EXACT_INPUT_TRIPLEHOP: \"swap_exact_input_triplehop\",\n  SWAP_EXACT_OUTPUT_TRIPLEHOP: \"swap_exact_output_triplehop\",\n  SWAP_EXACT_INPUT_DOUBLE_OUTPUT: \"swap_exact_input_double_output\",\n  SWAP_EXACT_INPUT_TRIPLE_OUTPUT: \"swap_exact_input_triple_output\",\n  SWAP_EXACT_INPUT_QUADRUPLE_OUTPUT: \"swap_exact_input_quadruple_output\",\n  SWAP_EXACT_INPUT_QUINTUPLE_OUTPUT: \"swap_exact_input_quintuple_output\",\n  SWAP_EXACT_DOUBLE_INPUT: \"swap_exact_double_input\",\n  SWAP_EXACT_TRIPLE_INPUT: \"swap_exact_triple_input\",\n  SWAP_EXACT_QUADRUPLE_INPUT: \"swap_exact_quadruple_input\",\n  SWAP_EXACT_QUINTUPLE_INPUT: \"swap_exact_quintuple_input\",\n};\n\n// https://github.com/FlowX-Finance/ts-sdk/blob/master/src/types.ts#L4\nexport interface CoinMetadata {\n  decimals?: number;\n  description?: string;\n  iconUrl?: string;\n  type?: string;\n  isVerified?: boolean;\n  symbol?: string;\n  balance?: number | string;\n  derivedSUI?: number | string;\n  derivedPriceInUSD?: number | string;\n  name?: string;\n  id?: string;\n  stats?: CoinStats;\n  twitterUrl?: string;\n  websiteUrl?: string;\n  coinMarketcapUrl?: string;\n  coingeckoUrl?: string;\n}\n\nexport interface CoinStruct {\n  balance: string;\n  coinObjectId: string;\n  coinType: string;\n  digest: string;\n  previousTransaction: string;\n  version: string;\n}\n\nexport interface CoinStats {\n  totalLiquidityInUSD: number | string;\n  priceChange24H: number | string;\n  price: number | string;\n  volume7D: number | string;\n  volume24H: number | string;\n  transaction24H: number | string;\n  totalLiquidity: number | string;\n  fee24H: number | string;\n}\n\nexport interface PairSetting {\n  _id?: string;\n  coinXType: string;\n  coinYType: string;\n  createdBy?: string;\n  createdAt?: string;\n  isNewPair?: boolean;\n  lpType?: string;\n  lpName?: string;\n  userLpBalance?: string;\n  reserveX?: string;\n  reserveY?: string;\n  lpObjectId?: string;\n  inRate?: string;\n  outRate?: string;\n  stats?: PairStats;\n}\n\nexport interface PairStats {\n  volume7D: number | string;\n  volume24H: number | string;\n  transaction24H: number | string;\n  totalLiquidity: number | string;\n  fee24H: number | string;\n  aprPerformance7D: number | string;\n  totalLiquidityInUSD: string | number;\n}\n\nexport type Amount = {\n  amount: number | string;\n  decimalAmount: number | string;\n};\n\nexport interface SwapArgs {\n  typeArguments: string[];\n  args: any[];\n  tx: TransactionBlock;\n  callFunction: string;\n}\n\n// Forked from: https://github.com/FlowX-Finance/ts-sdk/blob/001d2b549931001fe01f4547c311b96\n// 39182e0af/src/swap/swapExactInput.ts#L119\nexport const swapExactInputDoctored = async (\n  isExactIn: boolean,\n  amountIn: Amount,\n  amountOut: Amount,\n  trades: PairSetting[],\n  coinIn: CoinMetadata,\n  coinOut: CoinMetadata,\n  account: string,\n  valueSlippage: number,\n) => {\n  try {\n    const slipageVal = valueSlippage > 100 ? 100 : valueSlippage < 0 ? 0 : valueSlippage;\n    // eslint-disable-next-line new-cap\n    const slippage = BigNumberInstance(slipageVal).div(100).toFixed();\n    // if (isExactIn) {\n    //   console.log(\"AAA\", BigNumberInstance(1).minus(slippage).toFixed(), {\n    //     amountIn: amountIn.decimalAmount,\n    //     amountOutMin: BigNumberInstance(amountOut.decimalAmount)\n    //       .multipliedBy(BigNumberInstance(1).minus(slippage).toFixed())\n    //       .toFixed(0),\n    //   });\n    // } else {\n    //   console.log(\"BBB\", {\n    //     amountInMax: amountIn.decimalAmount,\n    //     amountOut: amountOut.decimalAmount,\n    //   });\n    // }\n    const { typeArguments, args, tx, callFunction } = isExactIn\n      ? await getArgsSwapExactInput(\n          amountIn.decimalAmount,\n          // eslint-disable-next-line new-cap\n          BigNumberInstance(amountOut.decimalAmount)\n            .multipliedBy(1 - +slippage)\n            .toFixed(0),\n          trades,\n          coinIn,\n          account,\n          \"\",\n        )\n      : await getArgsSwapExactOutput(amountIn.decimalAmount, amountOut.decimalAmount, trades, coinIn, account, \"\");\n\n    // console.log('=======> Swap Args ==========>');\n    // console.log('Args: ', args);\n    // console.log('Amount in: ', amountIn.decimalAmount);\n    // console.log('Amount out: ', amountOut.decimalAmount);\n    // console.log('Type Args: ', typeArguments);\n    // console.log('=======> End Args ==========>');\n    // console.log(\"KKK\", tx);\n    const txb = await swap(tx, typeArguments, args, callFunction);\n    return txb;\n  } catch (e) {\n    console.log(\"error\", e);\n    // eslint-disable-next-line no-throw-literal\n    throw `ERROR SWAP: ${e}`;\n  }\n};\n\nconst swap = async (\n  tx: TransactionBlock,\n  typeArguments: string[],\n  args: any[],\n  callFunction: string,\n): Promise<TransactionBlock> => {\n  tx.moveCall({\n    target: `${PACKAGE_OBJECT_ID}::router::${callFunction}`,\n    arguments: args,\n    typeArguments,\n  });\n  return tx;\n};\n\nconst getArgsSwapExactInput = async (\n  amountIn: string | number,\n  amountOutMin: string | number,\n  trades: PairSetting[],\n  coinIn: CoinMetadata,\n  account: string,\n  recipient: string,\n): Promise<SwapArgs> => {\n  const { coin: coinObjectId, tx } = await handleGetCoinAmount(amountIn, account, coinIn.type!);\n  const typeArguments: any[] = [coinIn.type];\n  trades?.forEach((item) => {\n    const lastArgs = typeArguments[typeArguments.length - 1] ?? \"\";\n    if (lastArgs == item.coinXType) {\n      typeArguments.push(item.coinYType);\n    } else {\n      typeArguments.push(item.coinXType);\n    }\n  });\n  return {\n    tx,\n    typeArguments,\n    args: [\n      tx.object(CLOCK_ID),\n      tx.object(CONTAINER_OBJECT_ID),\n      tx.object(coinObjectId),\n      tx.pure(+amountOutMin),\n      tx.pure(recipient || account),\n      tx.pure(estimateDealine()),\n    ],\n    callFunction: getSwapFunction(trades, true),\n  };\n};\n\nconst getSwapFunction = (trades: PairSetting[], isExactIn = false) => {\n  switch (trades?.length) {\n    case 1:\n      return isExactIn ? FUNCTION.SWAP_EXACT_INPUT : FUNCTION.SWAP_EXACT_OUTPUT;\n    case 2:\n      return isExactIn ? FUNCTION.SWAP_EXACT_INPUT_DOUBLEHOP : FUNCTION.SWAP_EXACT_OUTPUT_DOUBLEHOP;\n    case 3:\n      return isExactIn ? FUNCTION.SWAP_EXACT_INPUT_TRIPLEHOP : FUNCTION.SWAP_EXACT_OUTPUT_TRIPLEHOP;\n    default:\n      return isExactIn ? FUNCTION.SWAP_EXACT_INPUT : FUNCTION.SWAP_EXACT_OUTPUT;\n  }\n};\n\nconst getArgsSwapExactOutput = async (\n  amountInMax: string | number,\n  amountOut: string | number,\n  trades: PairSetting[],\n  coinIn: CoinMetadata,\n  account: string,\n  recipient: string,\n): Promise<SwapArgs> => {\n  const { coin: coinObjectId, tx } = await handleGetCoinAmount(amountInMax, account, coinIn.type!);\n\n  const typeArguments: any[] = [coinIn.type];\n  trades?.forEach((item) => {\n    const lastArgs = typeArguments[typeArguments.length - 1] ?? \"\";\n    if (lastArgs == item.coinXType) {\n      typeArguments.push(item.coinYType);\n    } else {\n      typeArguments.push(item.coinXType);\n    }\n  });\n\n  return {\n    tx,\n    typeArguments,\n    args: [\n      tx.object(CLOCK_ID),\n      tx.object(CONTAINER_OBJECT_ID),\n      tx.object(coinObjectId),\n      tx.pure(+amountInMax),\n      tx.pure(+amountOut),\n      tx.pure(recipient || account),\n      tx.pure(estimateDealine()),\n    ],\n    callFunction: getSwapFunction(trades, false),\n  };\n};\n\nexport const handleGetCoinAmount = async (\n  amount: number | string,\n  account: string,\n  coinType: string,\n  inheritTx?: TransactionBlock,\n): Promise<{ tx: TransactionBlock; coin: string }> => {\n  const tx = inheritTx ?? new TransactionBlock();\n  const coin = \"0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\";\n\n  return { tx, coin };\n};\n","/* eslint-disable max-len */\nimport { TransactionBlock } from \"@mysten/sui.js/transactions\";\nimport { TxBlock, Transaction, Arguments, Argument, Input } from \"../txBlock\";\nimport { fromArgument } from \"../utils\";\nimport { DCA_CONFIG } from \"../config\";\n\nconst DCA_ROUTER = \"flow_x\";\nlet InputIndex = 0;\n\nconst swapPatterns: Record<string, `${string}::${string}::${string}`> = {\n  \".*::router::swap_exact_output$\": `${DCA_CONFIG.DCA_CONTRACT}::${DCA_ROUTER}::${\"swap_exact_output\"}`,\n  \".*::router::swap_exact_output_doublehop$\": `${DCA_CONFIG.DCA_CONTRACT}::${DCA_ROUTER}::${\"swap_exact_output_doublehop\"}`,\n  \".*::router::swap_exact_output_triplehop$\": `${DCA_CONFIG.DCA_CONTRACT}::${DCA_ROUTER}::${\"swap_exact_output_triplehop\"}`,\n  \".*::router::swap_exact_input$\": `${DCA_CONFIG.DCA_CONTRACT}::${DCA_ROUTER}::${\"swap_exact_input\"}`,\n  \".*::router::swap_exact_input_doublehop$\": `${DCA_CONFIG.DCA_CONTRACT}::${DCA_ROUTER}::${\"swap_exact_input_doublehop\"}`,\n  \".*::router::swap_exact_input_triplehop$\": `${DCA_CONFIG.DCA_CONTRACT}::${DCA_ROUTER}::${\"swap_exact_input_triplehop\"}`,\n};\n\ntype SwapParams = {\n  clock: Argument;\n  pools: Argument;\n  inputFunds: Argument;\n  minOutput?: Argument; // ExactIn\n  maxInputAmount?: Argument; // ExactOut\n  exactOutput?: Argument; // ExactOut\n  recipient: Argument;\n  sqrtPrice: Argument;\n  dca: Argument;\n  gasGost: Argument;\n};\n\n/**\n * Builds a transaction block for Dollar Cost Averaging (DCA).\n * @param {TransactionBlock} txBlock - The transaction block to build upon.\n * @param {string} tokenFrom - The token to be exchanged from.\n * @param {string} tokenTo - The token to be exchanged to.\n * @param {string} dcaId - The ID for the Dollar Cost Averaging (DCA) operation.\n * @param {number} gasCost - The gas cost for the transaction.\n * @return {TransactionBlock} - The built transaction block for DCA.\n */\nexport function buildDcaTxBlock(\n  txBlock: TransactionBlock,\n  tokenFrom: string,\n  tokenTo: string,\n  dcaId: string,\n  gasCost: number,\n): TransactionBlock {\n  let isExactIn = false;\n\n  // Initialize a TransactionBlock\n  const dcaBlock: TxBlock = {\n    version: 1,\n    transactions: [],\n    inputs: [],\n    gasConfig: txBlock.blockData.gasConfig,\n    sender: txBlock.blockData.sender,\n    expiration: txBlock.blockData.expiration,\n  };\n\n  // 1. Transaction to create Coin<tokenFrom>, i.e. input funds\n  dcaBlock.transactions.push({\n    kind: \"MoveCall\",\n    target: \"0x2::coin::zero\",\n    arguments: [],\n    typeArguments: [tokenFrom],\n  });\n\n  const swapPatternRegex = new RegExp(Object.keys(swapPatterns).join(\"|\"));\n\n  txBlock.blockData.transactions.forEach((transaction) => {\n    if (transaction.kind === \"MoveCall\" && transaction.target) {\n      const swapMatch: RegExpExecArray | null = swapPatternRegex.exec(transaction.target);\n\n      if (swapMatch) {\n        const parts = transaction.target.split(\"::\");\n        const newTarget: `${string}::${string}::${string}` = `${DCA_CONFIG.DCA_CONTRACT}::${DCA_ROUTER}::${parts[2]}`;\n        isExactIn = parts[2].includes(\"exact_input\");\n\n        const swapParams: SwapParams = isExactIn\n          ? {\n              clock: fromArgument(transaction.arguments[0] as Argument, inputIdx()),\n              pools: fromArgument(transaction.arguments[1] as Argument, inputIdx()),\n              inputFunds: { kind: \"Result\", index: 0 } as Argument,\n              minOutput: fromArgument(transaction.arguments[3] as Argument, inputIdx()),\n              recipient: fromArgument(transaction.arguments[4] as Argument, inputIdx()),\n              sqrtPrice: fromArgument(transaction.arguments[5] as Argument, inputIdx()),\n              dca: { kind: \"Input\", value: dcaId, index: inputIdx(), type: \"object\" },\n              gasGost: { kind: \"Input\", value: gasCost, index: inputIdx(), type: \"pure\" },\n            }\n          : {\n              clock: fromArgument(transaction.arguments[0] as Argument, inputIdx()),\n              pools: fromArgument(transaction.arguments[1] as Argument, inputIdx()),\n              inputFunds: { kind: \"Result\", index: 0 } as Argument,\n              maxInputAmount: fromArgument(transaction.arguments[3] as Argument, inputIdx()),\n              exactOutput: fromArgument(transaction.arguments[4] as Argument, inputIdx()),\n              recipient: fromArgument(transaction.arguments[5] as Argument, inputIdx()),\n              sqrtPrice: fromArgument(transaction.arguments[6] as Argument, inputIdx()),\n              dca: { kind: \"Input\", value: dcaId, index: inputIdx(), type: \"object\" },\n              gasGost: { kind: \"Input\", value: gasCost, index: inputIdx(), type: \"pure\" },\n            };\n\n        const inputs = isExactIn\n          ? [\n              swapParams.clock as Input,\n              swapParams.pools as Input,\n              swapParams.minOutput as Input,\n              swapParams.recipient as Input,\n              swapParams.sqrtPrice as Input,\n              swapParams.dca as Input,\n              swapParams.gasGost as Input,\n            ]\n          : [\n              swapParams.clock as Input,\n              swapParams.pools as Input,\n              swapParams.maxInputAmount as Input,\n              swapParams.exactOutput as Input,\n              swapParams.recipient as Input,\n              swapParams.sqrtPrice as Input,\n              swapParams.dca as Input,\n              swapParams.gasGost as Input,\n            ];\n\n        const args: Arguments = isExactIn\n          ? [\n              swapParams.clock,\n              swapParams.pools,\n              swapParams.inputFunds,\n              // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n              swapParams.minOutput!,\n              swapParams.recipient,\n              swapParams.sqrtPrice,\n              swapParams.dca,\n              swapParams.gasGost,\n            ]\n          : [\n              swapParams.clock,\n              swapParams.pools,\n              swapParams.inputFunds,\n              // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n              swapParams.maxInputAmount!,\n              // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n              swapParams.exactOutput!,\n              swapParams.recipient,\n              swapParams.sqrtPrice,\n              swapParams.dca,\n              swapParams.gasGost,\n            ];\n\n        const tx: Transaction = {\n          arguments: args,\n          kind: transaction.kind,\n          target: newTarget,\n          typeArguments: transaction.typeArguments,\n        };\n\n        dcaBlock.inputs.push(...inputs);\n        dcaBlock.transactions.push(tx);\n      }\n    }\n  });\n\n  const newTxBlock = TransactionBlock.from(JSON.stringify(dcaBlock));\n  return newTxBlock;\n}\n\n// eslint-disable-next-line\nfunction inputIdx(): number {\n  ++InputIndex;\n  return InputIndex - 1;\n}\n","import { SuiClient, SuiEvent } from \"@mysten/sui.js/client\";\nimport { TransactionBlock } from \"@mysten/sui.js/transactions\";\nimport BigNumber from \"bignumber.js\";\nimport { Contract, Network, TurbosSdk } from \"turbos-clmm-sdk\";\nimport { EventEmitter } from \"../../emitters/EventEmitter\";\nimport { CoinManagerSingleton } from \"../../managers/coin/CoinManager\";\nimport { swapDoctored } from \"../../managers/dca/adapterUtils/turbosUtils\";\nimport { buildDcaTxBlock } from \"../../managers/dca/adapters/turbosAdapter\";\nimport { CommonCoinData, UpdatedCoinsCache } from \"../../managers/types\";\nimport { InMemoryStorageSingleton } from \"../../storages/InMemoryStorage\";\nimport { Storage } from \"../../storages/types\";\nimport { getCoinsAndPathsCaches } from \"../../storages/utils/getCoinsAndPathsCaches\";\nimport { getPoolsCache } from \"../../storages/utils/getPoolsCache\";\nimport { storeCaches } from \"../../storages/utils/storeCaches\";\nimport { LONG_SUI_COIN_TYPE, SHORT_SUI_COIN_TYPE, exitHandlerWrapper, getAllUserEvents } from \"../common\";\nimport { CacheOptions, CoinsCache, CommonPoolData, IPoolProvider, PathsCache } from \"../types\";\nimport { convertSlippage } from \"../utils/convertSlippage\";\nimport { getCoinInfoFromCache } from \"../utils/getCoinInfoFromCache\";\nimport { removeDecimalPart } from \"../utils/removeDecimalPart\";\nimport {\n  CoinData,\n  DetailedTurbosOwnedPoolInfo,\n  PoolData,\n  ShortPoolData,\n  SwapRequiredData,\n  TurbosOptions,\n  TurbosOwnedPool,\n} from \"./types\";\nimport {\n  getCoinsDataForPool,\n  getCoinsMap,\n  getPathsMap,\n  getPoolByCoins,\n  isCoinsApiResponseValid,\n  isPoolsApiResponseValid,\n  isTurbosCreatePoolEventParsedJson,\n} from \"./utils\";\n\n// TODO: Need a fallback in case when API doesn't work\n// sdk.pool.getPools() doesn't work\n\n/**\n * @class TurbosSingleton\n * @extends EventEmitter\n * @implements {IPoolProvider<TurbosSingleton>}\n * @description Represents a singleton instance of TurbosManager managing TurbosSdk functionality.\n *\n * Note: If using `lazyLoading: true` with any storage configuration in a serverless/cloud functions environment,\n * be aware that each invocation of your cloud function will start cache population from scratch.\n * This may lead to unexpected behavior when using different SDK methods. To avoid this and minimize the time\n * for cache population, consider using `lazyLoading: false` along with passing a persistent\n * storage adapter (external, e.g., Redis or any kind of DB) to the ProviderSingleton.\n */\nexport class TurbosSingleton extends EventEmitter implements IPoolProvider<TurbosSingleton> {\n  private static _instance: TurbosSingleton | undefined;\n  private static TURBOS_API_URL = \"https://api.turbos.finance\";\n  public turbosSdk: TurbosSdk;\n  public isSmartRoutingAvailable = false;\n  public providerName = \"Turbos\";\n  public poolsCache: ShortPoolData[] = [];\n  public pathsCache: PathsCache = new Map();\n  public coinsCache: CoinsCache = new Map();\n  private cacheOptions: CacheOptions;\n  private intervalId: NodeJS.Timeout | undefined;\n  private proxy: string | undefined;\n  private storage: Storage;\n\n  public static CREATE_POOL_GAS_BUDGET = 100_000_000;\n  public static FEE_DIVIDER = 10_000;\n\n  /**\n   * @constructor\n   * @param {Omit<TurbosOptions, \"lazyLoading\">} options - The options for TurbosSingleton.\n   */\n  private constructor(options: Omit<TurbosOptions, \"lazyLoading\">) {\n    super();\n    const provider = new SuiClient({ url: options.suiProviderUrl });\n    this.turbosSdk = new TurbosSdk(Network.mainnet, provider);\n    const { updateIntervally = true, ...restCacheOptions } = options.cacheOptions;\n    this.cacheOptions = { updateIntervally, ...restCacheOptions };\n    this.proxy = options.proxy;\n    this.storage = options.cacheOptions.storage ?? InMemoryStorageSingleton.getInstance();\n  }\n\n  /**\n   * @public\n   * @method getInstance\n   * @description Gets the singleton instance of TurbosSingleton.\n   * @param {TurbosOptions} [options] - Options for TurbosSingleton.\n   * @return {Promise<TurbosSingleton>} The singleton instance of TurbosSingleton.\n   */\n  public static async getInstance(options?: TurbosOptions): Promise<TurbosSingleton> {\n    if (!TurbosSingleton._instance) {\n      if (options === undefined) {\n        throw new Error(\"[TurbosManager] Options are required in arguments to create instance.\");\n      }\n      const { suiProviderUrl, cacheOptions, lazyLoading = true, proxy } = options;\n\n      const instance = new TurbosSingleton({ suiProviderUrl, cacheOptions, proxy });\n      lazyLoading ? instance.init() : await instance.init();\n      TurbosSingleton._instance = instance;\n    }\n\n    return TurbosSingleton._instance;\n  }\n\n  /**\n   * @private\n   * @method init\n   * @description Initializes the TurbosSingleton instance.\n   * @return {Promise<void>} A Promise that resolves when initialization is complete.\n   */\n  private async init() {\n    console.debug(`[${this.providerName}] Singleton initiating.`);\n\n    await this.fillCacheFromStorage();\n    await this.updateCaches();\n    this.cacheOptions.updateIntervally && this.updateCachesIntervally();\n\n    this.bufferEvent(\"cachesUpdate\", this.getCoins());\n  }\n\n  /**\n   * Fills the cache from storage asynchronously.\n   *\n   * @private\n   * @return {Promise<void>} A promise that resolves when the cache is filled from storage.\n   */\n  private async fillCacheFromStorage(): Promise<void> {\n    try {\n      const { coinsCache, pathsCache } = await getCoinsAndPathsCaches({\n        storage: this.storage,\n        provider: this.providerName,\n        updateCacheInterval: this.cacheOptions.updateIntervalInMs,\n      });\n      const poolsCache = await getPoolsCache({\n        storage: this.storage,\n        provider: this.providerName,\n        updateCacheInterval: this.cacheOptions.updateIntervalInMs,\n      });\n\n      this.coinsCache = coinsCache;\n      this.pathsCache = pathsCache;\n      this.poolsCache = poolsCache;\n    } catch (error) {\n      console.error(`[${this.providerName}] fillCacheFromStorage failed:`, error);\n    }\n  }\n\n  /**\n   * Checks if the storage cache is empty.\n   *\n   * @private\n   * @return {boolean} True if the storage cache is empty, false otherwise.\n   */\n  private isStorageCacheEmpty() {\n    const isCacheEmpty = this.coinsCache.size === 0 || this.pathsCache.size === 0 || this.poolsCache.length === 0;\n\n    return isCacheEmpty;\n  }\n\n  /**\n   * @private\n   * @method updateCaches\n   * @description Updates the caches for pools, paths, and coins.\n   * @return {Promise<void>} A Promise that resolves when caches are updated.\n   */\n  private async updateCaches({ force }: { force: boolean } = { force: false }): Promise<void> {\n    const isCacheEmpty = this.isStorageCacheEmpty();\n\n    if (isCacheEmpty || force) {\n      try {\n        await this.updatePoolsCache();\n        this.updatePathsCache();\n        await this.updateCoinsCache();\n        this.emit(\"cachesUpdate\", this.getCoins());\n\n        await storeCaches({\n          provider: this.providerName,\n          storage: this.storage,\n          coinsCache: this.getCoins(),\n          pathsCache: this.getPaths(),\n          poolsCache: this.getPools(),\n        });\n\n        console.debug(\"[Turbos] Caches are updated and stored.\");\n      } catch (error) {\n        console.error(\"[Turbos] Caches update failed:\", error);\n      }\n    }\n  }\n\n  /**\n   * @private\n   * @method updateCachesIntervally\n   * @description Updates the caches at regular intervals.\n   * @return {void}\n   */\n  private updateCachesIntervally(): void {\n    let isUpdatingCurrently = false;\n    this.intervalId = setInterval(async () => {\n      try {\n        if (isUpdatingCurrently) {\n          return;\n        }\n        isUpdatingCurrently = true;\n        await this.updateCaches({ force: true });\n      } finally {\n        isUpdatingCurrently = false;\n      }\n    }, this.cacheOptions.updateIntervalInMs);\n\n    exitHandlerWrapper({ intervalId: this.intervalId, providerName: this.providerName });\n  }\n\n  /**\n   * @private\n   * @method updatePoolsCache\n   * @description Updates the pools cache.\n   * @return {Promise<void>} A Promise that resolves when the pools cache is updated.\n   */\n  public async updatePoolsCache(): Promise<void> {\n    const pools: PoolData[] = await this.fetchPoolsFromApi();\n\n    // TODO: Remove that method to separate one\n    this.poolsCache = pools.map((pool: PoolData) => ({\n      poolId: pool.pool_id,\n      coinTypeA: pool.coin_type_a,\n      coinTypeB: pool.coin_type_b,\n    }));\n  }\n\n  /**\n   * @private\n   * @method updatePathsCache\n   * @description Updates the paths cache.\n   * @return {void}\n   */\n  private updatePathsCache(): void {\n    this.pathsCache = getPathsMap(this.poolsCache);\n  }\n\n  /**\n   * @private\n   * @method updateCoinsCache\n   * @description Updates the coins cache.\n   * @return {Promise<void>} A Promise that resolves when the coins cache is updated.\n   */\n  private async updateCoinsCache(): Promise<void> {\n    const coins: CoinData[] = await this.fetchCoinsFromApi();\n    this.coinsCache = getCoinsMap(coins);\n  }\n\n  /**\n   * Gets pools data from the Turbos API.\n   *\n   * @public\n   * @async\n   * @return {Promise<PoolData[]>} A Promise that resolves to an array of PoolData.\n   */\n  private async fetchPoolsFromApi(): Promise<PoolData[]> {\n    // By default Turbos API returns not all the pools, so we need to explicitly set count of pools we want to fetch.\n    const fetchPoolsCount = 1_000_000;\n\n    const url: string = this.proxy\n      ? `${this.proxy}/${TurbosSingleton.TURBOS_API_URL}/pools?pageSize=${fetchPoolsCount}`\n      : `${TurbosSingleton.TURBOS_API_URL}/pools?pageSize=${fetchPoolsCount}`;\n\n    const response: Response = await fetch(url);\n    const responseJson: { code: number; message: string; data: PoolData[] } = await response.json();\n    const isValidPoolsResponse = isPoolsApiResponseValid(responseJson);\n\n    if (!isValidPoolsResponse) {\n      throw new Error(\"[Turbos] Pools response from API is not valid.\");\n    }\n\n    return responseJson.data;\n  }\n\n  /**\n   * Fetches coin data from the Turbos API.\n   *\n   * @public\n   * @async\n   * @return {Promise<CoinData[]>} A Promise that resolves to an array of CoinData.\n   */\n  private async fetchCoinsFromApi(): Promise<CoinData[]> {\n    const response: Response = await fetch(`${TurbosSingleton.TURBOS_API_URL}/coins`);\n    const responseJson: { code: number; message: string; data: CoinData[] } = await response.json();\n    const isValidResponse = isCoinsApiResponseValid(responseJson);\n\n    if (!isValidResponse) {\n      throw new Error(\"[Turbos] Coins response from API is not valid.\");\n    }\n\n    return responseJson.data;\n  }\n\n  /**\n   * @public\n   * @method getPools\n   * @description Gets the pools cache.\n   * @return {ShortPoolData[]} Pools cache.\n   */\n  public getPools(): ShortPoolData[] {\n    return this.poolsCache;\n  }\n\n  /**\n   * Fetches the pool data and maps them into a map where the key is a combination of\n   * `coin_type_a` and `coin_type_b` and the value is a `CommonPoolData` object.\n   *\n   * @return {Map<string, CommonPoolData>} Map of `CommonPoolData`.\n   */\n  public getPaths(): Map<string, CommonPoolData> {\n    return this.pathsCache;\n  }\n\n  /**\n   * Transforms coins cache to CommonCoinData format.\n   *\n   * @public\n   * @async\n   * @return {CommonCoinData[]} An array of CommonCoinData.\n   */\n  public getCoins(): UpdatedCoinsCache {\n    const allCoins: CommonCoinData[] = Array.from(this.coinsCache.values());\n    return { provider: this.providerName, data: allCoins };\n  }\n\n  /**\n   * @public\n   * @method getRouteData\n   * @description Gets route data for a given pair of coins.\n   * @param {Object} options - Options for getting route data.\n   * @param {string} options.coinTypeFrom - The coin type to swap from.\n   * @param {string} options.coinTypeTo - The coin type to swap to.\n   * @param {string} options.inputAmount - The input amount for the swap.\n   * @param {number} options.slippagePercentage - The slippage percentage.\n   * @param {string} options.publicKey - The public key for the swap.\n   * @return {Promise<{ outputAmount: bigint, route: ExtendedSwapCalculatedOutputDataType }>} Route data.\n   */\n  public async getRouteData({\n    coinTypeFrom,\n    coinTypeTo,\n    inputAmount,\n    publicKey,\n  }: {\n    coinTypeFrom: string;\n    coinTypeTo: string;\n    inputAmount: string;\n    slippagePercentage: number;\n    publicKey: string;\n  }) {\n    const { outputAmount, ...otherData } = await this.getSwapRequiredData({\n      inputAmount,\n      tokenFrom: coinTypeFrom,\n      tokenTo: coinTypeTo,\n      publicKey,\n    });\n\n    return { outputAmount, route: { outputAmount, ...otherData } };\n  }\n\n  /**\n   * Retrieves swap-related data required for swapping tokens.\n   *\n   * @public\n   * @async\n   * @param {string} tokenFrom - The token from which the swap is initiated.\n   * @param {string} tokenTo - The target token for the swap.\n   * @param {number} inputAmount - The amount of the input token for the swap.\n   * @param {string} publicKey - The public key of the user initiating the swap.\n   * @return {Promise<SwapRequiredData>} A Promise that resolves to the SwapRequiredData for the swap.\n   * @throws {Error} Throws an error if there is no pool with the specified coin types.\n   */\n  private async getSwapRequiredData({\n    tokenFrom,\n    tokenTo,\n    inputAmount,\n    publicKey,\n  }: {\n    tokenFrom: string;\n    tokenTo: string;\n    inputAmount: string;\n    publicKey: string;\n  }): Promise<SwapRequiredData> {\n    const pool: ShortPoolData | undefined = getPoolByCoins(tokenFrom, tokenTo, this.poolsCache);\n\n    if (!pool) {\n      throw new Error(`[TurbosManager] Pool with coin types \"${tokenFrom}\" and \"${tokenTo}\" is not found.`);\n    }\n\n    const poolId: string = pool.poolId;\n    const tokenFromIsSui: boolean = tokenFrom === SHORT_SUI_COIN_TYPE || tokenFrom === LONG_SUI_COIN_TYPE;\n    const tokenFromIsTokenA: boolean = tokenFromIsSui\n      ? pool.coinTypeA === SHORT_SUI_COIN_TYPE || pool.coinTypeA === LONG_SUI_COIN_TYPE\n      : pool.coinTypeA === tokenFrom;\n    const inputCoin: CommonCoinData | undefined = getCoinInfoFromCache(tokenFrom, this.coinsCache);\n\n    if (!inputCoin) {\n      throw new Error(`[TurbosManager] Cannot find coin with type \"${tokenFrom}\".`);\n    }\n\n    const inputCoinDecimals: number = inputCoin.decimals;\n    const inputAmountWithDecimalsBigNumber = new BigNumber(inputAmount).multipliedBy(10 ** inputCoinDecimals);\n    // We do removing the decimal part in case client send number with more decimal part\n    // than this particular token has decimal places allowed (`inputCoinDecimals`)\n    // That's prevent situation when casting\n    // BigNumber to BigInt fails with error (\"Cannot convert 183763562.1 to a BigInt\")\n    const inputAmountWithoutExceededDecimalPart = removeDecimalPart(inputAmountWithDecimalsBigNumber);\n    const inputAmountWithDecimals = inputAmountWithoutExceededDecimalPart.toString();\n\n    // TODO (possible improvement):\n    // executing time could be reduced by patching this method to pass into it config (getConfig() inside)\n    const swapResult = (\n      await this.turbosSdk.trade.computeSwapResult({\n        pools: [{ pool: poolId, a2b: tokenFromIsTokenA }],\n        address: publicKey,\n        amountSpecified: inputAmountWithDecimals,\n        amountSpecifiedIsInput: true,\n      })\n    )[0];\n    const nextTickIndex: number = this.turbosSdk.math.bitsToNumber(swapResult.tick_current_index.bits);\n    const outputAmount: string = tokenFromIsTokenA ? swapResult.amount_b : swapResult.amount_a;\n\n    return {\n      outputAmount: BigInt(outputAmount),\n      nextTickIndex,\n      pool,\n      inputAmountWithDecimals,\n      tokenFromIsTokenA,\n    };\n  }\n\n  /**\n   * Gets a transaction block for swapping tokens based on provided swap data.\n   *\n   * @public\n   * @async\n   * @param {SwapRequiredData} swapRequiredData - The required data for the swap.\n   * @param {string} publicKey - The public key of the user.\n   * @param {number} [slippagePercentage=10] - The slippage percentage.\n   * @return {Promise<TransactionBlock>} A Promise that resolves to a TransactionBlock.\n   */\n  public async getSwapTransaction({\n    route,\n    publicKey,\n    slippagePercentage = 10,\n  }: {\n    route: SwapRequiredData;\n    publicKey: string;\n    slippagePercentage: number;\n  }): Promise<TransactionBlock> {\n    const { pool, outputAmount, nextTickIndex, inputAmountWithDecimals, tokenFromIsTokenA } = route;\n    const parsedSlippage: string = convertSlippage(slippagePercentage).toString();\n\n    const transaction: TransactionBlock = await this.turbosSdk.trade.swap({\n      routes: [{ pool: pool.poolId, a2b: tokenFromIsTokenA, nextTickIndex }],\n      coinTypeA: tokenFromIsTokenA ? pool.coinTypeA : pool.coinTypeB,\n      coinTypeB: tokenFromIsTokenA ? pool.coinTypeB : pool.coinTypeA,\n      address: publicKey,\n      amountA: inputAmountWithDecimals,\n      amountB: outputAmount.toString(),\n      amountSpecifiedIsInput: true,\n      slippage: parsedSlippage,\n    });\n\n    return transaction;\n  }\n\n  /**\n   * Gets a transaction block for swapping tokens based on provided swap data.\n   *\n   * @public\n   * @async\n   * @param {SwapRequiredData} swapRequiredData - The required data for the swap.\n   * @param {string} publicKey - The public key of the user.\n   * @param {number} [slippagePercentage=10] - The slippage percentage.\n   * @return {Promise<TransactionBlock>} A Promise that resolves to a TransactionBlock.\n   */\n  public async getSwapTransactionDoctored({\n    route,\n    publicKey,\n    slippagePercentage = 10,\n  }: {\n    route: SwapRequiredData;\n    publicKey: string;\n    slippagePercentage: number;\n  }): Promise<TransactionBlock> {\n    const { pool, outputAmount, nextTickIndex, inputAmountWithDecimals, tokenFromIsTokenA } = route;\n    const parsedSlippage: string = convertSlippage(slippagePercentage).toString();\n\n    const transaction: TransactionBlock = await swapDoctored(this.turbosSdk, {\n      routes: [{ pool: pool.poolId, a2b: tokenFromIsTokenA, nextTickIndex }],\n      coinTypeA: tokenFromIsTokenA ? pool.coinTypeA : pool.coinTypeB,\n      coinTypeB: tokenFromIsTokenA ? pool.coinTypeB : pool.coinTypeA,\n      address: publicKey,\n      amountA: inputAmountWithDecimals,\n      amountB: outputAmount.toString(),\n      amountSpecifiedIsInput: true,\n      slippage: parsedSlippage,\n    });\n\n    return transaction;\n  }\n\n  /**\n   * Generates a transaction for creating a new liquidity pool.\n   *\n   * @param {Object} params - Parameters for creating the pool transaction.\n   * @param {number} params.tickSpacing - The tick spacing of the pool.\n   * @param {string} params.coinTypeA - The type of the first coin in the pool.\n   * @param {string} params.coinTypeB - The type of the second coin in the pool.\n   * @param {number} params.coinDecimalsA - The number of decimals for the first coin.\n   * @param {number} params.coinDecimalsB - The number of decimals for the second coin.\n   * @param {string} params.amountA - The amount of the first coin to deposit into the pool. Example: 10000.1286 RINCEL\n   * @param {string} params.amountB - The amount of the second coin to deposit into the pool. Example: 12.472 SUI\n   * @param {number} params.slippage - The acceptable slippage percentage for the transaction. Example: 10 (means 10%)\n   * @param {string} params.publicKey - The public key of the transaction sender.\n   * @return {Promise<TransactionBlock>} A promise that resolves to the transaction block for creating the pool.\n   */\n  public async getCreatePoolTransaction({\n    tickSpacing,\n    coinDecimalsA,\n    coinDecimalsB,\n    coinTypeA,\n    coinTypeB,\n    amountA,\n    amountB,\n    slippage,\n    publicKey,\n  }: {\n    tickSpacing: number;\n    coinTypeA: string;\n    coinTypeB: string;\n    coinDecimalsA: number;\n    coinDecimalsB: number;\n    amountA: string;\n    amountB: string;\n    slippage: number;\n    publicKey: string;\n  }): Promise<TransactionBlock> {\n    const fee = await this.getFeeObject(tickSpacing);\n\n    const rawAmountA = new BigNumber(amountA).multipliedBy(10 ** coinDecimalsA).toFixed();\n    const rawAmountB = new BigNumber(amountB).multipliedBy(10 ** coinDecimalsB).toFixed();\n\n    const price = new BigNumber(rawAmountB).div(rawAmountA).toString();\n    const sqrtPrice = this.turbosSdk.math.priceToSqrtPriceX64(price, coinDecimalsA, coinDecimalsB).toString();\n    const { tickLower, tickUpper } = this.getGlobalLiquidityTicks(tickSpacing);\n\n    const createPoolTransaction = await this.turbosSdk.pool.createPool({\n      address: publicKey,\n      coinTypeA,\n      coinTypeB,\n      fee,\n      amountA: rawAmountA,\n      amountB: rawAmountB,\n      slippage,\n      sqrtPrice,\n      tickLower,\n      tickUpper,\n    });\n\n    createPoolTransaction.setGasBudget(TurbosSingleton.CREATE_POOL_GAS_BUDGET);\n\n    return createPoolTransaction;\n  }\n\n  /**\n   * Retrieves the fee object for the specified tick spacing.\n   *\n   * @param {number} tickSpacing - The tick spacing value.\n   * @return {Promise<Contract.Fee>} A promise that resolves to the fee object.\n   * @throws {Error} If the fee for the specified tick spacing is undefined.\n   */\n  public async getFeeObject(tickSpacing: number): Promise<Contract.Fee> {\n    const fees = await this.getFees();\n    const fee = fees.find((feeObject) => feeObject.tickSpacing === tickSpacing);\n\n    if (fee === undefined) {\n      throw new Error(`[TurbosSingleton.getFeeObject] Fee for tick spacing ${tickSpacing} is undefined.`);\n    }\n\n    return fee;\n  }\n\n  /**\n   * Retrieves the fees associated with the contract.\n   *\n   * @return {Promise<Contract.Fee[]>} A promise that resolves to an array of fee objects.\n   */\n  public async getFees(): Promise<Contract.Fee[]> {\n    return await this.turbosSdk.contract.getFees();\n  }\n\n  /**\n   * Retrieves the global liquidity tick range for the specified tick spacing.\n   *\n   * @param {number} tickSpacing - The tick spacing value.\n   * @return {{ tickLower: number, tickUpper: number }} An object containing the lower and upper bounds\n   * of the tick range.\n   */\n  public getGlobalLiquidityTicks(tickSpacing: number): { tickLower: number; tickUpper: number } {\n    /**\n     * This is a constant, derived from the maximum range representable by the Q32.62 fixed-point number format.\n     * It is used to set the global liquidity on all the price range.\n     * Ref: https://cetus-1.gitbook.io/cetus-developer-docs/developer/via-sdk/features-available/add-liquidity\n     */\n    const maxTickIndex = 443636;\n\n    const tickLower = -maxTickIndex + (maxTickIndex % tickSpacing);\n    const tickUpper = maxTickIndex - (maxTickIndex % tickSpacing);\n\n    return { tickLower, tickUpper };\n  }\n\n  /**\n   * Retrieves all the pools and finds specified one by its parameters.\n   *\n   * @param {Object} params - Parameters for finding the pool.\n   * @param {string} params.coinTypeA - The type of the first coin in the pool.\n   * @param {string} params.coinTypeB - The type of the second coin in the pool.\n   * @param {string} params.tickSpacing - The tick spacing of the pool.\n   * @return {Promise<PoolData | undefined>} A promise that resolves to the pool data matching\n   * the specified parameters, or `undefined` if no matching pool is found.\n   */\n  public async getPoolByParams({\n    coinTypeA,\n    coinTypeB,\n    tickSpacing,\n  }: {\n    coinTypeA: string;\n    coinTypeB: string;\n    tickSpacing: string;\n  }): Promise<PoolData | undefined> {\n    const fetchedPools = await this.fetchPoolsFromApi();\n\n    const foundPool = fetchedPools.find(\n      (pool) =>\n        pool.tick_spacing === tickSpacing &&\n        ((pool.coin_type_a === coinTypeA && pool.coin_type_b === coinTypeB) ||\n          (pool.coin_type_a === coinTypeB && pool.coin_type_b === coinTypeA)),\n    );\n\n    return foundPool;\n  }\n\n  /**\n   * Retrieves the create pool events from the provided user events.\n   *\n   * @param {SuiEvent[]} userEvents - An array of user events.\n   * @return {Promise<SuiEvent[]>} A promise that resolves to an array of create pool events.\n   */\n  public async getCreatePoolEventsFromUserEvents(userEvents: SuiEvent[]): Promise<SuiEvent[]> {\n    const contract = await this.turbosSdk.contract.getConfig();\n    const cetusCreatePoolEvent = `${contract.PackageIdOriginal}::pool_factory::PoolCreatedEvent`;\n\n    return userEvents.filter((event) => event.type === cetusCreatePoolEvent);\n  }\n\n  /**\n   * Retrieves the pools owned by a specific user.\n   *\n   * @description\n   * This method returns information about pools owned by a user, including the amounts of two\n   * different coins (`amountA` and `amountB`).\n   * The decimal precision of these amounts may vary depending on the availability of coin information.\n   * - If `getCoinByType2` returns valid decimal information for both coins, the amounts are adjusted accordingly.\n   * - If `getCoinByType2` returns null for either coin, the amounts are provided without decimal adjustment.\n   *\n   * To handle the potential discrepancy in decimal precision from the client-side,\n   * two additional parameters are introduced:\n   * - `amountAIsRaw`: A boolean indicating whether the returned `amountA` respects decimals (false) or is raw (true).\n   * - `amountBIsRaw`: A boolean indicating whether the returned `amountB` respects decimals (false) or is raw (true).\n   *\n   * It is recommended for the client to check these flags and adjust their processing logic accordingly.\n   *\n   * If either `amountAIsRaw` or `amountBIsRaw` is true, the corresponding\n   * amount should be used as-is without further decimal adjustments.\n   * If both flags are false, the amounts can be safely used after decimal adjustments.\n   *\n   * @public\n   * @param {SuiClient} options.provider - The provider for accessing the SUI client.\n   * @param {string} options.publicKey - The public key of the user whose pools are to be retrieved.\n   * @param {CoinManagerSingleton} options.coinManager - The CoinManagerSingleton instance for managing\n   * coin-related operations.\n   * @return {Promise<CetusOwnedPool[]>} A promise that resolves to an array of owned pools.\n   */\n  public async getOwnedPools({\n    provider,\n    publicKey,\n    coinManager,\n  }: {\n    provider: SuiClient;\n    publicKey: string;\n    coinManager: CoinManagerSingleton;\n  }): Promise<TurbosOwnedPool[]> {\n    const poolIds = await this.getUserPoolIds(publicKey, provider);\n\n    if (poolIds.length === 0) {\n      return [];\n    }\n\n    const userPools = await Promise.all(poolIds.map((poolId) => this.turbosSdk.pool.getPool(poolId)));\n\n    // We need `Promise.all` here to fetch coin metadata to calculate `amountA` and `amountB` respecting decimals\n    // in `getCoinsDataForPool()`\n    return await Promise.all(\n      userPools.map(async (poolData) => {\n        // `poolData.types` is an array with 3 elements: first 2 — coin types, 3rd — fee type.\n        const [coinTypeA, coinTypeB] = poolData.types;\n        const { coin_a: rawCoinAmountA, coin_b: rawCoinAmountB, fee, tick_spacing: tickSpacing } = poolData;\n\n        const { amountA, amountAIsRaw, amountB, amountBIsRaw, coinSymbolA, coinSymbolB, poolName, feePercentage } =\n          await getCoinsDataForPool({ coinManager, coinTypeA, coinTypeB, rawCoinAmountA, rawCoinAmountB, fee });\n\n        return {\n          poolName,\n          poolId: poolData.id.id,\n          coinTypeA,\n          coinTypeB,\n          coinSymbolA,\n          coinSymbolB,\n          amountA,\n          amountB,\n          tickSpacing,\n          feePercentage,\n          amountAIsRaw,\n          amountBIsRaw,\n        };\n      }),\n    );\n  }\n\n  /**\n   * Retrieves detailed information about pools based on their IDs.\n   *\n   * @param {string[]} poolIds - An array of pool IDs.\n   * @return {Promise<DetailedTurbosOwnedPoolInfo[]>} A promise that resolves to an array of detailed pool information.\n   */\n  public async getDetailedPoolsInfo({\n    provider,\n    publicKey,\n    coinManager,\n  }: {\n    provider: SuiClient;\n    publicKey: string;\n    coinManager: CoinManagerSingleton;\n  }): Promise<DetailedTurbosOwnedPoolInfo[]> {\n    const poolIds = await this.getUserPoolIds(publicKey, provider);\n\n    if (poolIds.length === 0) {\n      return [];\n    }\n\n    const allPools = await this.fetchPoolsFromApi();\n    const userPools = allPools.filter((pool) => poolIds.includes(pool.pool_id));\n\n    // We need `Promise.all` here to fetch coin metadata to calculate `amountA` and `amountB` respecting decimals\n    // in `getCoinsDataForPool()`\n    return await Promise.all(\n      userPools.map(async (poolData) => {\n        const {\n          coin_type_a: coinTypeA,\n          coin_type_b: coinTypeB,\n          coin_symbol_a: coinSymbolA,\n          coin_symbol_b: coinSymbolB,\n          coin_a: rawCoinAmountA,\n          coin_b: rawCoinAmountB,\n          fee,\n          tick_spacing: tickSpacing,\n        } = poolData;\n\n        const { amountA, amountAIsRaw, amountB, amountBIsRaw, poolName, feePercentage } = await getCoinsDataForPool({\n          coinManager,\n          coinTypeA,\n          coinTypeB,\n          rawCoinAmountA,\n          rawCoinAmountB,\n          fee: +fee,\n        });\n\n        return {\n          poolName,\n          poolId: poolData.pool_id,\n          coinTypeA,\n          coinTypeB,\n          coinSymbolA,\n          coinSymbolB,\n          amountA,\n          amountB,\n          tickSpacing: +tickSpacing,\n          feePercentage,\n          amountAIsRaw,\n          amountBIsRaw,\n          apr: poolData.apr,\n          aprPercent: poolData.apr_percent,\n          feeApr: poolData.fee_apr,\n          rewardApr: poolData.reward_apr,\n          volumeFor24hUsd: poolData.volume_24h_usd,\n          liquidityUsd: poolData.liquidity_usd,\n          coinLiquidityUsdA: poolData.coin_a_liquidity_usd,\n          coinLiquidityUsdB: poolData.coin_b_liquidity_usd,\n          feeFor24hUsd: poolData.fee_24h_usd,\n        };\n      }),\n    );\n  }\n\n  /**\n   * Retrieves pool IDs associated with a specific user.\n   *\n   * @param {string} publicKey - The public key of the user.\n   * @param {SuiClient} provider - The SuiClient provider.\n   * @return {Promise<string[]>} A promise that resolves to an array of pool IDs.\n   */\n  public async getUserPoolIds(publicKey: string, provider: SuiClient): Promise<string[]> {\n    const allEvents = await getAllUserEvents(provider, publicKey);\n\n    const createTurbosPoolEvents = await this.getCreatePoolEventsFromUserEvents(allEvents);\n    const poolIds: string[] = createTurbosPoolEvents\n      .filter((event) => isTurbosCreatePoolEventParsedJson(event.parsedJson))\n      // The false case must not occur since events not meeting the criteria have been filtered out above.\n      // This conditional statement primarily serves TypeScript type-checking purposes.\n      .map((event) => (isTurbosCreatePoolEventParsedJson(event.parsedJson) ? event.parsedJson.pool : \"\"));\n\n    return poolIds;\n  }\n\n  /**\n   * Removes the current instance of TurbosSingleton.\n   *\n   * Disclaimer: While this method in this class is marked as public, it is strongly discouraged\n   * to use it directly unless you are certain about the behavior.\n   */\n  public static removeInstance() {\n    TurbosSingleton._instance = undefined;\n  }\n\n  public buildDcaTxBlockAdapter = buildDcaTxBlock;\n}\n","import { TransactionBlock } from \"@mysten/sui.js/transactions\";\nimport { BN, Decimal, MAX_SQRT_PRICE, MIN_SQRT_PRICE, Pool, Trade, TurbosSdk } from \"turbos-clmm-sdk\";\nimport { SUI_CLOCK_OBJECT_ID } from \"@mysten/sui.js/utils\";\n\nconst ONE_MINUTE = 60 * 1000;\n\n// eslint-disable-next-line\nfunction amountOutWithSlippage(amountOut: Decimal, slippage: string, amountSpecifiedIsInput: boolean) {\n  if (amountSpecifiedIsInput) {\n    const minus = new Decimal(100).minus(slippage).div(100);\n    return new Decimal(amountOut).mul(minus).toFixed(0);\n  }\n\n  const plus = new Decimal(100).plus(slippage).div(100);\n  return new Decimal(amountOut).mul(plus).toFixed(0);\n}\n\n// eslint-disable-next-line\nfunction sqrtPriceWithSlippage(\n  sdk: TurbosSdk,\n  price: Decimal,\n  slippage: string,\n  a2b: boolean,\n  decimalsA: number,\n  decimalsB: number,\n): string {\n  const newPrice = new Decimal(price).mul(\n    a2b ? new Decimal(100).minus(slippage).div(100) : new Decimal(100).plus(slippage).div(100),\n  );\n  const sqrtPrice = sdk.math.priceToSqrtPriceX64(newPrice, decimalsA, decimalsB);\n\n  if (sqrtPrice.lt(new BN(MIN_SQRT_PRICE))) {\n    return MIN_SQRT_PRICE;\n  }\n  if (sqrtPrice.gt(new BN(MAX_SQRT_PRICE))) {\n    return MAX_SQRT_PRICE;\n  }\n  return sqrtPrice.toString();\n}\n\n// eslint-disable-next-line\nfunction getFunctionNameAndTypeArguments(pools: Pool.Types[], coinTypeA: string, coinTypeB: string) {\n  let typeArguments: string[] = [];\n  const functionName: string[] = [\"swap\"];\n  if (pools.length === 1) {\n    typeArguments = pools[0]!;\n    if (coinTypeA === typeArguments[0]) {\n      functionName.push(\"a\", \"b\");\n    } else {\n      functionName.push(\"b\", \"a\");\n    }\n  } else {\n    const pool1Args = pools[0]!;\n    const pool2Args = pools[1]!;\n    if (coinTypeA === pool1Args[0]) {\n      functionName.push(\"a\", \"b\");\n      typeArguments.push(pool1Args[0], pool1Args[2], pool1Args[1]);\n    } else {\n      functionName.push(\"b\", \"a\");\n      typeArguments.push(pool1Args[1], pool1Args[2], pool1Args[0]);\n    }\n\n    typeArguments.push(pool2Args[2], coinTypeB);\n    if (coinTypeB === pool2Args[0]) {\n      functionName.push(\"c\", \"b\");\n    } else {\n      functionName.push(\"b\", \"c\");\n    }\n  }\n\n  return {\n    functionName: functionName.join(\"_\"),\n    typeArguments,\n  };\n}\n\n// eslint-disable-next-line\nexport async function swapDoctored(sdk: TurbosSdk, options: Trade.SwapOptions): Promise<TransactionBlock> {\n  const { coinTypeA, coinTypeB, address, amountSpecifiedIsInput, slippage } = options;\n  const amountA = new Decimal(options.amountA);\n  const amountB = new Decimal(options.amountB);\n\n  const contract = await sdk.contract.getConfig();\n  console.log(\"Geting Routes\");\n  const routes = await Promise.all(\n    options.routes.map(async (item) => {\n      const typeArguments = await sdk.pool.getPoolTypeArguments(item.pool);\n      const [coinA, coinB] = await Promise.all([\n        sdk.coin.getMetadata(typeArguments[0]),\n        sdk.coin.getMetadata(typeArguments[1]),\n      ]);\n      return {\n        ...item,\n        coinA,\n        coinB,\n        typeArguments: typeArguments,\n      };\n    }),\n  );\n  console.log(\"Got Routes\");\n  // Doctoring the coinIDs --> empty array\n  const coinIds: string[] = [];\n  const { functionName, typeArguments } = getFunctionNameAndTypeArguments(\n    routes.map(({ typeArguments }) => typeArguments),\n    coinTypeA,\n    coinTypeB,\n  );\n  console.log(\"Got Function Names\");\n  const sqrtPrices = routes.map(({ nextTickIndex, coinA, coinB, a2b }) => {\n    const nextTickPrice = sdk.math.tickIndexToPrice(nextTickIndex, coinA.decimals, coinB.decimals);\n    return sqrtPriceWithSlippage(sdk, nextTickPrice, slippage, a2b, coinA.decimals, coinB.decimals);\n  });\n  console.log(\"Got sqrtPrices\");\n\n  const txb = options.txb || new TransactionBlock();\n  txb.moveCall({\n    target: `${contract.PackageId}::swap_router::${functionName}`,\n    typeArguments: typeArguments,\n    arguments: [\n      ...routes.map(({ pool }) => txb.object(pool)),\n      txb.makeMoveVec({\n        objects: sdk.coin.convertTradeCoins(txb, coinIds, coinTypeA, amountA),\n      }),\n      txb.pure((amountSpecifiedIsInput ? amountA : amountB).toFixed(0), \"u64\"),\n      txb.pure(\n        amountOutWithSlippage(amountSpecifiedIsInput ? amountB : amountA, slippage, amountSpecifiedIsInput),\n        \"u64\",\n      ),\n      ...sqrtPrices.map((price) => txb.pure(price, \"u128\")),\n      txb.pure(amountSpecifiedIsInput, \"bool\"),\n      txb.pure(address, \"address\"),\n      txb.pure(Date.now() + ONE_MINUTE * 3, \"u64\"),\n      txb.object(SUI_CLOCK_OBJECT_ID),\n      txb.object(contract.Versioned),\n    ],\n  });\n\n  return txb;\n}\n","import { TransactionBlock } from \"@mysten/sui.js/transactions\";\nimport { TxBlock, Transaction, Arguments, Argument, Input } from \"../txBlock\";\nimport { fromArgument } from \"../utils\";\nimport { DCA_CONFIG } from \"../config\";\n\nconst DCA_ROUTER = \"turbos\";\nlet InputIndex = 0;\n\nconst swapPatterns: Record<string, `${string}::${string}::${string}`> = {\n  \".*::swap_router::swap_a_b$\": `${DCA_CONFIG.DCA_CONTRACT}::${DCA_ROUTER}::${\"swap_a_b\"}`,\n  \".*::swap_router::swap_b_a$\": `${DCA_CONFIG.DCA_CONTRACT}::${DCA_ROUTER}::${\"swap_b_a\"}`,\n  \".*::swap_router::swap_a_b_b_c$\": `${DCA_CONFIG.DCA_CONTRACT}::${DCA_ROUTER}::${\"swap_a_b_b_c\"}`,\n  \".*::swap_router::swap_a_b_c_b$\": `${DCA_CONFIG.DCA_CONTRACT}::${DCA_ROUTER}::${\"swap_a_b_c_b\"}`,\n  \".*::swap_router::swap_b_a_b_c$\": `${DCA_CONFIG.DCA_CONTRACT}::${DCA_ROUTER}::${\"swap_b_a_b_c\"}`,\n  \".*::swap_router::swap_b_a_c_b$\": `${DCA_CONFIG.DCA_CONTRACT}::${DCA_ROUTER}::${\"swap_b_a_c_b\"}`,\n};\n\ntype SwapParams = {\n  pool: Argument;\n  poolII?: Argument; // Swap with hop\n  coin: Argument;\n  amount: Argument;\n  amountThreshold: Argument;\n  sqrtPriceLimit: Argument;\n  sqrtPriceLimitII?: Argument; // Swap with hop\n  isExactIn: Argument;\n  recipient: Argument;\n  deadline: Argument;\n  clock: Argument;\n  versioned: Argument;\n  dca: Argument;\n  gasGost: Argument;\n};\n\n/**\n * Builds a transaction block for Dollar Cost Averaging (DCA).\n * @param {TransactionBlock} txBlock - The transaction block to build upon.\n * @param {string} tokenFrom - The token to be exchanged from.\n * @param {string} tokenTo - The token to be exchanged to.\n * @param {string} dcaId - The ID for the Dollar Cost Averaging (DCA) operation.\n * @param {number} gasCost - The gas cost for the transaction.\n * @return {TransactionBlock} - The built transaction block for DCA.\n */\nexport function buildDcaTxBlock(\n  txBlock: TransactionBlock,\n  tokenFrom: string,\n  tokenTo: string,\n  dcaId: string,\n  gasCost: number,\n): TransactionBlock {\n  //   // Check first transaction. If its SplitCoin, then we know we need to\n  //   // remove input of index 1, which is the split amount\n  //   const txBlockInputs = cloneDeep(txBlock.blockData.inputs); // make a copy\n\n  //   const tx0 = txBlock.blockData.transactions[0];\n\n  //   if (tx0.kind === \"SplitCoins\") {\n  //     txBlockInputs.splice(1, 1); // This removes the second element, idx:1\n  //   }\n\n  let simpleSwap = false;\n\n  // Initialize a TransactionBlock\n  const dcaBlock: TxBlock = {\n    version: 1,\n    transactions: [],\n    inputs: [],\n    gasConfig: txBlock.blockData.gasConfig,\n    sender: txBlock.blockData.sender,\n    expiration: txBlock.blockData.expiration,\n  };\n\n  // 1. Transaction to create Coin<tokenFrom>, i.e. input funds\n  dcaBlock.transactions.push({\n    kind: \"MoveCall\",\n    target: \"0x2::coin::zero\",\n    arguments: [],\n    typeArguments: [tokenFrom],\n  });\n\n  const swapPatternRegex = new RegExp(Object.keys(swapPatterns).join(\"|\"));\n\n  txBlock.blockData.transactions.forEach((transaction) => {\n    if (transaction.kind === \"MoveCall\" && transaction.target) {\n      const swapMatch: RegExpExecArray | null = swapPatternRegex.exec(transaction.target);\n\n      if (swapMatch) {\n        const parts = transaction.target.split(\"::\");\n        const newTarget: `${string}::${string}::${string}` = `${DCA_CONFIG.DCA_CONTRACT}::${DCA_ROUTER}::${parts[2]}`;\n        simpleSwap = parts[2] === \"swap_a_b\" || parts[2] === \"swap_b_a\";\n\n        const swapParams: SwapParams = simpleSwap\n          ? {\n              pool: fromArgument(transaction.arguments[0] as Argument, inputIdx()),\n              coin: { kind: \"Result\", index: 0 } as Argument,\n              amount: fromArgument(transaction.arguments[2] as Argument, inputIdx()),\n              amountThreshold: fromArgument(transaction.arguments[3] as Argument, inputIdx()),\n              sqrtPriceLimit: fromArgument(transaction.arguments[4] as Argument, inputIdx()),\n              isExactIn: fromArgument(transaction.arguments[5] as Argument, inputIdx()),\n              recipient: fromArgument(transaction.arguments[6] as Argument, inputIdx()),\n              deadline: fromArgument(transaction.arguments[7] as Argument, inputIdx()),\n              clock: fromArgument(transaction.arguments[8] as Argument, inputIdx()),\n              versioned: fromArgument(transaction.arguments[9] as Argument, inputIdx()),\n              dca: { kind: \"Input\", value: dcaId, index: inputIdx(), type: \"object\" },\n              gasGost: { kind: \"Input\", value: gasCost, index: inputIdx(), type: \"pure\" },\n            }\n          : {\n              pool: fromArgument(transaction.arguments[0] as Argument, inputIdx()),\n              poolII: fromArgument(transaction.arguments[1] as Argument, inputIdx()),\n              coin: { kind: \"Result\", index: 0 } as Argument,\n              amount: fromArgument(transaction.arguments[3] as Argument, inputIdx()),\n              amountThreshold: fromArgument(transaction.arguments[4] as Argument, inputIdx()),\n              sqrtPriceLimit: fromArgument(transaction.arguments[5] as Argument, inputIdx()),\n              sqrtPriceLimitII: fromArgument(transaction.arguments[6] as Argument, inputIdx()),\n              isExactIn: fromArgument(transaction.arguments[7] as Argument, inputIdx()),\n              recipient: fromArgument(transaction.arguments[8] as Argument, inputIdx()),\n              deadline: fromArgument(transaction.arguments[9] as Argument, inputIdx()),\n              clock: fromArgument(transaction.arguments[10] as Argument, inputIdx()),\n              versioned: fromArgument(transaction.arguments[11] as Argument, inputIdx()),\n              dca: { kind: \"Input\", value: dcaId, index: inputIdx(), type: \"object\" },\n              gasGost: { kind: \"Input\", value: gasCost, index: inputIdx(), type: \"pure\" },\n            };\n\n        const inputs = simpleSwap\n          ? [\n              swapParams.pool as Input,\n              swapParams.amount as Input,\n              swapParams.amountThreshold as Input,\n              swapParams.sqrtPriceLimit as Input,\n              swapParams.isExactIn as Input,\n              swapParams.recipient as Input,\n              swapParams.deadline as Input,\n              swapParams.clock as Input,\n              swapParams.versioned as Input,\n              swapParams.dca as Input,\n              swapParams.gasGost as Input,\n            ]\n          : [\n              swapParams.pool as Input,\n              swapParams.poolII as Input,\n              swapParams.amount as Input,\n              swapParams.amountThreshold as Input,\n              swapParams.sqrtPriceLimit as Input,\n              swapParams.sqrtPriceLimitII as Input,\n              swapParams.isExactIn as Input,\n              swapParams.recipient as Input,\n              swapParams.deadline as Input,\n              swapParams.clock as Input,\n              swapParams.versioned as Input,\n              swapParams.dca as Input,\n              swapParams.gasGost as Input,\n            ];\n\n        const args: Arguments = simpleSwap\n          ? [\n              swapParams.pool,\n              swapParams.coin,\n              swapParams.amount,\n              swapParams.amountThreshold,\n              swapParams.sqrtPriceLimit,\n              swapParams.isExactIn,\n              swapParams.recipient,\n              swapParams.deadline,\n              swapParams.clock,\n              swapParams.versioned,\n              swapParams.dca,\n              swapParams.gasGost,\n            ]\n          : [\n              swapParams.pool,\n              // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n              swapParams.poolII!,\n              swapParams.coin,\n              swapParams.amount,\n              swapParams.amountThreshold,\n              swapParams.sqrtPriceLimit,\n              // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n              swapParams.sqrtPriceLimitII!,\n              swapParams.isExactIn,\n              swapParams.recipient,\n              swapParams.deadline,\n              swapParams.clock,\n              swapParams.versioned,\n              swapParams.dca,\n              swapParams.gasGost,\n            ];\n\n        const tx: Transaction = {\n          arguments: args,\n          kind: transaction.kind,\n          target: newTarget,\n          typeArguments: transaction.typeArguments,\n        };\n\n        dcaBlock.inputs.push(...inputs);\n        dcaBlock.transactions.push(tx);\n      }\n    }\n  });\n\n  const newTxBlock = TransactionBlock.from(JSON.stringify(dcaBlock));\n  return newTxBlock;\n}\n\n// eslint-disable-next-line\nfunction inputIdx(): number {\n  ++InputIndex;\n  return InputIndex - 1;\n}\n","import { Storage, StorageProperty, StorageValue } from \"../types\";\nimport { isShortPoolDataArray } from \"./typeguards\";\nimport { ShortPoolData } from \"../../providers/turbos/types\";\n\n/**\n * Returns pools cache from storage. If cache is not up to date, empty array is returned.\n */\nexport const getPoolsCache = async ({\n  storage,\n  provider,\n  updateCacheInterval,\n}: {\n  storage: Storage;\n  provider: string;\n  updateCacheInterval: number;\n}): Promise<ShortPoolData[]> => {\n  let poolsCache: ShortPoolData[] = [];\n\n  const pools: StorageValue = await storage.getCache({\n    provider,\n    property: StorageProperty.Pools,\n  });\n\n  if (isShortPoolDataArray(pools?.value)) {\n    const timestamp = parseInt(pools.timestamp);\n    const cacheIsUpToDate = timestamp + updateCacheInterval > Date.now();\n\n    if (cacheIsUpToDate) {\n      poolsCache = pools.value;\n    } else {\n      console.warn(`[getPoolsCache] ${provider} pools cache is not up to date.`);\n    }\n  } else if (pools === null) {\n    console.warn(`[getPoolsCache] ${provider} Received empty pools from strorage, pools === null `);\n  } else {\n    const stringifiedPool: string = JSON.stringify(pools.value[0]);\n    throw new Error(\n      `[${provider}] getPoolsCache: pools from storage are not ` +\n        `(ShortPoolData[] or null). Example of pool: ${stringifiedPool}`,\n    );\n  }\n\n  return poolsCache;\n};\n","import BigNumber from \"bignumber.js\";\nimport { CoinManagerSingleton } from \"../../managers/coin/CoinManager\";\nimport { CommonCoinData } from \"../../managers/types\";\nimport { LONG_SUI_COIN_TYPE, SHORT_SUI_COIN_TYPE } from \"../common\";\nimport { CoinsCache, CommonPoolData, PathsCache } from \"../types\";\nimport { TurbosSingleton } from \"./turbos\";\nimport {\n  CoinData,\n  CoinsAPIResponse,\n  PoolData,\n  PoolsAPIResponse,\n  ShortPoolData,\n  TurbosCreatePoolEventParsedJson,\n} from \"./types\";\n\n/* eslint-disable require-jsdoc */\nexport function isPoolsApiResponseValid(\n  response: PoolsAPIResponse,\n): response is { code: 0; message: \"OK\"; data: PoolData[] } {\n  return (\n    response.code === 0 &&\n    response.message === \"OK\" &&\n    response.data !== undefined &&\n    Array.isArray(response.data) &&\n    response.data.every(isPoolDataValid)\n  );\n}\n\nexport function isCoinsApiResponseValid(\n  response: CoinsAPIResponse,\n): response is { code: 0; message: \"OK\"; data: CoinData[] } {\n  return (\n    response.code === 0 &&\n    response.message === \"OK\" &&\n    response.data !== undefined &&\n    Array.isArray(response.data) &&\n    response.data.every(isCoinDataValid)\n  );\n}\n\nexport function isPoolDataValid(poolData: PoolData): boolean {\n  return (\n    typeof poolData.id === \"number\" &&\n    typeof poolData.coin_a === \"string\" &&\n    typeof poolData.coin_b === \"string\" &&\n    typeof poolData.deploy_time_ms === \"string\" &&\n    typeof poolData.fee === \"string\" &&\n    typeof poolData.fee_growth_global_a === \"string\" &&\n    typeof poolData.fee_growth_global_b === \"string\" &&\n    typeof poolData.fee_protocol === \"string\" &&\n    typeof poolData.liquidity === \"string\" &&\n    typeof poolData.max_liquidity_per_tick === \"string\" &&\n    typeof poolData.protocol_fees_a === \"string\" &&\n    typeof poolData.protocol_fees_b === \"string\" &&\n    typeof poolData.sqrt_price === \"string\" &&\n    typeof poolData.tick_current_index === \"number\" &&\n    typeof poolData.tick_spacing === \"string\" &&\n    typeof poolData.unlocked === \"boolean\" &&\n    typeof poolData.pool_id === \"string\" &&\n    typeof poolData.type === \"string\" &&\n    typeof poolData.coin_symbol_a === \"string\" &&\n    typeof poolData.coin_symbol_b === \"string\" &&\n    typeof poolData.coin_type_a === \"string\" &&\n    typeof poolData.coin_type_b === \"string\" &&\n    typeof poolData.fee_type === \"string\" &&\n    typeof poolData.add_2_percent_depth === \"string\" &&\n    typeof poolData.reduce_2_percent_depth === \"string\" &&\n    Array.isArray(poolData.reward_infos) &&\n    poolData.reward_infos.every(isRewardInfoValid) &&\n    typeof poolData.reward_last_updated_time_ms === \"string\" &&\n    (typeof poolData.category === \"string\" || poolData.category === null) &&\n    typeof poolData.apr === \"number\" &&\n    typeof poolData.apr_percent === \"number\" &&\n    typeof poolData.fee_apr === \"number\" &&\n    typeof poolData.reward_apr === \"number\" &&\n    typeof poolData.volume_24h_usd === \"number\" &&\n    typeof poolData.liquidity_usd === \"number\" &&\n    typeof poolData.coin_a_liquidity_usd === \"number\" &&\n    typeof poolData.coin_b_liquidity_usd === \"number\" &&\n    typeof poolData.fee_24h_usd === \"number\" &&\n    typeof poolData.flag === \"number\" &&\n    typeof poolData.created_at === \"string\" &&\n    typeof poolData.updated_at === \"string\"\n  );\n}\n\nexport function isRewardInfoValid(rewardInfo: { type: string; fields: Record<string, unknown> }): boolean {\n  return (\n    typeof rewardInfo.type === \"string\" && typeof rewardInfo.fields === \"object\" && !Array.isArray(rewardInfo.fields)\n  );\n}\n\nexport function isCategoryValid(category: { id: number; name: string; badge_url: string }): boolean {\n  return typeof category.id === \"number\" && typeof category.name === \"string\" && typeof category.badge_url === \"string\";\n}\n\nexport function isCoinDataValid(coinData: CoinData): boolean {\n  return (\n    typeof coinData.id === \"number\" &&\n    typeof coinData.name === \"string\" &&\n    typeof coinData.type === \"string\" &&\n    typeof coinData.symbol === \"string\" &&\n    typeof coinData.decimals === \"number\" &&\n    typeof coinData.logo_url === \"string\" &&\n    typeof coinData.coingecko_id === \"string\" &&\n    (typeof coinData.pyth_id === \"string\" || coinData.pyth_id === null) &&\n    typeof coinData.in_quote_list === \"boolean\" &&\n    typeof coinData.is_stable === \"boolean\" &&\n    typeof coinData.is_popular === \"boolean\" &&\n    typeof coinData.in_pool === \"boolean\" &&\n    typeof coinData.category_id === \"number\" &&\n    typeof coinData.faucet_amount === \"string\" &&\n    typeof coinData.flag === \"number\" &&\n    typeof coinData.created_at === \"string\" &&\n    typeof coinData.updated_at === \"string\" &&\n    isCategoryValid(coinData.category)\n  );\n}\n\nexport function getPathsMap(pools: ShortPoolData[]): PathsCache {\n  return pools.reduce((map: PathsCache, pool: ShortPoolData) => {\n    const coinTypeA: string = pool.coinTypeA;\n    const coinTypeB: string = pool.coinTypeB;\n\n    const commonPoolData: CommonPoolData = {\n      base: coinTypeA,\n      quote: coinTypeB,\n    };\n    const poolKey = `${coinTypeA}-${coinTypeB}`;\n\n    map.set(poolKey, commonPoolData);\n    return map;\n  }, new Map());\n}\n\nexport const getCoinsMap = (coins: CoinData[]): CoinsCache => {\n  return coins.reduce((map: Map<string, CommonCoinData>, coin: CoinData) => {\n    map.set(coin.type, { symbol: coin.symbol, type: coin.type, decimals: coin.decimals });\n    return map;\n  }, new Map());\n};\n\nexport const getPoolByCoins = (\n  tokenFrom: string,\n  tokenTo: string,\n  pools: ShortPoolData[],\n): ShortPoolData | undefined => {\n  const tokenFromIsSui: boolean = tokenFrom === SHORT_SUI_COIN_TYPE || tokenFrom === LONG_SUI_COIN_TYPE;\n  const tokenToIsSui: boolean = tokenTo === SHORT_SUI_COIN_TYPE || tokenTo === LONG_SUI_COIN_TYPE;\n\n  return pools.find((pool: ShortPoolData) => {\n    const coinAInPoolIsSui: boolean = pool.coinTypeA === SHORT_SUI_COIN_TYPE || pool.coinTypeA === LONG_SUI_COIN_TYPE;\n    const coinBInPoolIsSui: boolean = pool.coinTypeB === SHORT_SUI_COIN_TYPE || pool.coinTypeB === LONG_SUI_COIN_TYPE;\n    const notSuiToken: string = tokenFromIsSui ? tokenTo : tokenFrom;\n    const poolHasBothTokens: boolean =\n      (pool.coinTypeA === tokenFrom && pool.coinTypeB === tokenTo) ||\n      (pool.coinTypeA === tokenTo && pool.coinTypeB === tokenFrom);\n\n    return tokenFromIsSui || tokenToIsSui\n      ? (coinAInPoolIsSui && pool.coinTypeB === notSuiToken) || (coinBInPoolIsSui && pool.coinTypeA === notSuiToken)\n      : poolHasBothTokens;\n  });\n};\n\nexport function isTurbosCreatePoolEventParsedJson(data: unknown): data is TurbosCreatePoolEventParsedJson {\n  return typeof data === \"object\" && data !== null && \"pool\" in data && typeof data.pool === \"string\";\n}\n\nexport async function getCoinsDataForPool({\n  coinManager,\n  coinTypeA,\n  coinTypeB,\n  rawCoinAmountA,\n  rawCoinAmountB,\n  fee,\n}: {\n  coinTypeA: string;\n  coinTypeB: string;\n  rawCoinAmountA: string;\n  rawCoinAmountB: string;\n  fee: number;\n  coinManager: CoinManagerSingleton;\n}) {\n  const coinDataA = await coinManager.getCoinByType2(coinTypeA);\n  const coinDataB = await coinManager.getCoinByType2(coinTypeB);\n\n  let coinSymbolA: string = coinTypeA;\n  let coinSymbolB: string = coinTypeB;\n\n  let coinDecimalsA = 0;\n  let coinDecimalsB = 0;\n\n  let amountAIsRaw = true;\n  let amountBIsRaw = true;\n\n  if (coinDataA !== null) {\n    coinSymbolA = coinDataA.symbol ?? coinDataA.type;\n    coinDecimalsA = coinDataA.decimals;\n    amountAIsRaw = false;\n  }\n\n  if (coinDataB !== null) {\n    coinSymbolB = coinDataB.symbol ?? coinDataB.type;\n    coinDecimalsB = coinDataB.decimals;\n    amountBIsRaw = false;\n  }\n\n  const amountA = new BigNumber(rawCoinAmountA).dividedBy(10 ** coinDecimalsA).toString();\n  const amountB = new BigNumber(rawCoinAmountB).dividedBy(10 ** coinDecimalsB).toString();\n\n  const poolName = `${coinSymbolA}-${coinSymbolB}`;\n  const feePercentage = new BigNumber(fee).div(TurbosSingleton.FEE_DIVIDER).toString();\n\n  return {\n    poolName,\n    amountA,\n    amountB,\n    coinSymbolA,\n    coinSymbolB,\n    amountAIsRaw,\n    amountBIsRaw,\n    feePercentage,\n  };\n}\n","import { CLAMM, InterestPool, MoveObjectArgument, SwapRouteArgs } from \"@interest-protocol/clamm-sdk\";\nimport { SuiClient } from \"@mysten/sui.js-0.51.2/client\";\nimport { TransactionBlock as UpdatedTransactionBlock } from \"@mysten/sui.js-0.51.2/transactions\";\nimport { CoinMetadata } from \"@mysten/sui.js/client\";\nimport { TransactionBlock } from \"@mysten/sui.js/transactions\";\nimport BigNumber from \"bignumber.js\";\nimport { EventEmitter } from \"../../emitters/EventEmitter\";\nimport { WalletManagerSingleton } from \"../../managers/WalletManager\";\nimport { CommonCoinData, UpdatedCoinsCache } from \"../../managers/types\";\nimport { InMemoryStorageSingleton } from \"../../storages/InMemoryStorage\";\nimport { Storage } from \"../../storages/types\";\nimport { getCoinsAndPathsCaches } from \"../../storages/utils/getCoinsAndPathsCaches\";\nimport { storeCaches } from \"../../storages/utils/storeCaches\";\nimport { LONG_SUI_COIN_TYPE, exitHandlerWrapper } from \"../common\";\nimport { CacheOptions, CoinsCache, CommonPoolData, IPoolProvider, PathsCache } from \"../types\";\nimport { getUserCoinObjects } from \"../utils/getUserCoinObjects\";\nimport { isSuiCoinType } from \"../utils/isSuiCoinType\";\nimport { isApiResponseValid } from \"./type-guards\";\nimport { InterestOptions, InterestRouteData } from \"./types\";\nimport { getAmountWithSlippage, getBestInterestRoute, getPathMapAndCoinTypesSet } from \"./utils\";\n\n/**\n * @class InterestProtocolSingleton\n * @extends EventEmitter\n * @implements {IPoolProvider<InterestProtocolSingleton>}\n * @description Singleton class for Interest Protocol.\n *\n * Note: If using `lazyLoading: true` with any storage configuration in a serverless/cloud functions environment,\n * be aware that each invocation of your cloud function will start cache population from scratch.\n * This may lead to unexpected behavior when using different SDK methods. To avoid this and minimize the time\n * for cache population, consider using `lazyLoading: false` along with passing a persistent\n * storage adapter (external, e.g., Redis or any kind of DB) to the ProviderSingleton.\n */\nexport class InterestProtocolSingleton extends EventEmitter implements IPoolProvider<InterestProtocolSingleton> {\n  private static _instance: InterestProtocolSingleton | undefined;\n  public static INTEREST_PROTOCOL_PACKAGE_ADDRESS =\n    \"0x429dbf2fc849c0b4146db09af38c104ae7a3ed746baf835fa57fee27fa5ff382\";\n  public static INTEREST_PROTOCOL_SUI_TEARS = \"0xf7334947a5037552a94cee15fc471dbda71bf24d46c97ee24e1fdac38e26644c\";\n\n  private provider: SuiClient;\n  private cacheOptions: CacheOptions;\n  private intervalId: NodeJS.Timeout | undefined;\n  private storage: Storage;\n\n  public interestSdk: CLAMM;\n  public providerName = \"Interest\";\n  public isSmartRoutingAvailable = true;\n  public pathsCache: PathsCache = new Map();\n  public coinsCache: CoinsCache = new Map();\n  public poolsCache: InterestPool[] = [];\n\n  /**\n   * @constructor\n   * @param {Omit<InterestOptions, \"lazyLoading\">} options - Options for InterestProtocolSingleton.\n   */\n  private constructor(options: Omit<InterestOptions, \"lazyLoading\">) {\n    super();\n\n    this.provider = new SuiClient({ url: options.suiProviderUrl });\n\n    this.interestSdk = new CLAMM({\n      suiClient: this.provider,\n      packageAddress: InterestProtocolSingleton.INTEREST_PROTOCOL_PACKAGE_ADDRESS,\n      network: \"mainnet\",\n      suiTearsAddress: InterestProtocolSingleton.INTEREST_PROTOCOL_SUI_TEARS,\n    });\n\n    const { updateIntervally = true, ...restCacheOptions } = options.cacheOptions;\n    this.cacheOptions = { updateIntervally, ...restCacheOptions };\n    this.storage = options.cacheOptions.storage ?? InMemoryStorageSingleton.getInstance();\n  }\n\n  /**\n   * @static\n   * @method getInstance\n   * @async\n   * @param {InterestOptions} [options] - Options for InterestProtocolSingleton instance.\n   * @return {Promise<InterestProtocolSingleton>}\n   * @throws Error if options are not provided.\n   */\n  public static async getInstance(options?: InterestOptions): Promise<InterestProtocolSingleton> {\n    if (!InterestProtocolSingleton._instance) {\n      if (options === undefined) {\n        throw new Error(\"[InterestProtocolSingleton] Options are required in arguments to create instance.\");\n      }\n      const { suiProviderUrl, cacheOptions, lazyLoading = true } = options;\n\n      const instance = new InterestProtocolSingleton({ suiProviderUrl, cacheOptions });\n      lazyLoading ? instance.init() : await instance.init();\n\n      InterestProtocolSingleton._instance = instance;\n    }\n\n    return InterestProtocolSingleton._instance;\n  }\n\n  /**\n   * @private\n   * @method init\n   * @description Initializes the InterestProtocolSingleton instance.\n   * @return {Promise<void>}\n   */\n  private async init() {\n    console.debug(`[${this.providerName}] Singleton initiating.`);\n    await this.fillCacheFromStorage();\n    await this.updateCaches();\n    this.cacheOptions.updateIntervally && this.updateCachesIntervally();\n\n    this.bufferEvent(\"cachesUpdate\", this.getCoins());\n  }\n\n  /**\n   * Fills the cache from storage asynchronously.\n   *\n   * @private\n   * @return {Promise<void>} A promise that resolves when the cache is filled from storage.\n   */\n  private async fillCacheFromStorage(): Promise<void> {\n    try {\n      const { coinsCache, pathsCache } = await getCoinsAndPathsCaches({\n        storage: this.storage,\n        provider: this.providerName,\n        updateCacheInterval: this.cacheOptions.updateIntervalInMs,\n      });\n\n      this.coinsCache = coinsCache;\n      this.pathsCache = pathsCache;\n    } catch (error) {\n      console.error(`[${this.providerName}] fillCacheFromStorage failed:`, error);\n    }\n  }\n\n  /**\n   * Checks if the storage cache is empty.\n   *\n   * @private\n   * @return {boolean} True if the storage cache is empty, false otherwise.\n   */\n  private isStorageCacheEmpty() {\n    const isCacheEmpty = this.coinsCache.size === 0 || this.pathsCache.size === 0;\n\n    return isCacheEmpty;\n  }\n\n  /**\n   * @private\n   * @method updateCaches\n   * @description Updates caches.\n   * @return {Promise<void>}\n   */\n  private async updateCaches({ force }: { force: boolean } = { force: false }): Promise<void> {\n    const isCacheEmpty = this.isStorageCacheEmpty();\n\n    if (isCacheEmpty || force) {\n      try {\n        await this.updatePoolsCache();\n        await this.updatePathsAndCoinsCache();\n        this.emit(\"cachesUpdate\", this.getCoins());\n\n        await storeCaches({\n          provider: this.providerName,\n          storage: this.storage,\n          coinsCache: this.getCoins(),\n          pathsCache: this.getPaths(),\n        });\n\n        console.debug(\"[Interest] Caches are updated and stored.\");\n      } catch (error) {\n        console.error(\"[Interest] Caches update failed:\", error);\n      }\n    }\n  }\n\n  /**\n   * @private\n   * @method updateCachesIntervally\n   * @description Updates caches periodically.\n   * @return {void}\n   */\n  private updateCachesIntervally(): void {\n    let isUpdatingCurrently = false;\n    this.intervalId = setInterval(async () => {\n      try {\n        if (isUpdatingCurrently) {\n          return;\n        }\n        isUpdatingCurrently = true;\n        await this.updateCaches({ force: true });\n      } finally {\n        isUpdatingCurrently = false;\n      }\n    }, this.cacheOptions.updateIntervalInMs);\n\n    exitHandlerWrapper({ intervalId: this.intervalId, providerName: this.providerName });\n  }\n\n  /**\n   * @private\n   * @method updatePoolsCache\n   * @description Updates pools cache.\n   * @return {Promise<void>}\n   */\n  private async updatePoolsCache(): Promise<void> {\n    try {\n      const { pools }: { pools: readonly InterestPool[] } = await this.interestSdk.getPools();\n      const isValidPoolsResponse = isApiResponseValid(pools);\n\n      if (!isValidPoolsResponse) {\n        console.error(\"[Interest] Pools response:\", pools);\n        throw new Error(\"Pools response from API is not valid\");\n      }\n\n      this.poolsCache = pools;\n    } catch (error) {\n      console.error(\"[Interest.updatePoolsCache]:\", error);\n    }\n  }\n\n  /**\n   * @private\n   * @method updatePathsAndCoinsCache\n   * @description Updates paths and coins cache.\n   * @return {Promise<void>}\n   */\n  private async updatePathsAndCoinsCache(): Promise<void> {\n    const { pathMap, coinTypesSet } = getPathMapAndCoinTypesSet(this.poolsCache);\n    this.pathsCache = pathMap;\n\n    await Promise.all(\n      Array.from(coinTypesSet.values()).map(async (coinType: string) => {\n        try {\n          const metadata: CoinMetadata | null = await this.provider.getCoinMetadata({ coinType });\n\n          if (metadata !== null) {\n            this.coinsCache.set(coinType, { symbol: metadata.symbol, type: coinType, decimals: metadata.decimals });\n          }\n        } catch (error) {\n          console.error(`[Interest] Error while fetching metadata about coin ${coinType}:`, error);\n        }\n      }),\n    );\n  }\n\n  /**\n   * @public\n   * @method getPool\n   * @description Gets the pool with the specified coin types.\n   * @param {string} coinTypeA - Coin type A.\n   * @param {string} coinTypeB - Coin type B.\n   * @return {Pool} The pool object.\n   */\n  public getPool(coinTypeA: string, coinTypeB: string): InterestPool {\n    const pool: InterestPool | undefined = this.poolsCache.find(\n      (pool: InterestPool) => pool.coinTypes.includes(coinTypeA) && pool.coinTypes.includes(coinTypeB),\n    );\n\n    if (!pool) {\n      throw new Error(`[Interest] Cannot find pool with coinTypeA \"${coinTypeA}\" and coinTypeB \"${coinTypeB}\".`);\n    }\n\n    return pool;\n  }\n\n  /**\n   * @public\n   * @method getPools\n   * @description Gets all pools.\n   * @return {InterestPool[]} Array of pools.\n   */\n  public getPools(): InterestPool[] {\n    return this.poolsCache;\n  }\n\n  /**\n   * @public\n   * @method getCoins\n   * @description Gets the updated coins cache.\n   * @return {UpdatedCoinsCache} Updated coins cache.\n   */\n  public getCoins(): UpdatedCoinsCache {\n    const allCoins: CommonCoinData[] = Array.from(this.coinsCache.values());\n    return { provider: this.providerName, data: allCoins };\n  }\n\n  /**\n   * @public\n   * @method getPaths\n   * @description Gets the paths cache.\n   * @return {Map<string, CommonPoolData>} Paths cache.\n   */\n  public getPaths(): Map<string, CommonPoolData> {\n    return this.pathsCache;\n  }\n\n  /**\n   * @public\n   * @method getRouteData\n   * @description Gets route data.\n   * @param {Object} params - Parameters for route data.\n   * @param {string} params.coinTypeFrom - Coin type from.\n   * @param {string} params.coinTypeTo - Coin type to.\n   * @param {string} params.inputAmount - Input amount.\n   * @return {Promise<{ outputAmount: bigint, route: InterestRouteData }>} Route data.\n   */\n  public async getRouteData({\n    coinTypeFrom,\n    coinTypeTo,\n    inputAmount,\n    slippagePercentage,\n  }: {\n    coinTypeFrom: string;\n    coinTypeTo: string;\n    inputAmount: string;\n    slippagePercentage: number;\n    publicKey: string;\n  }): Promise<{ outputAmount: bigint; route: InterestRouteData }> {\n    // Interest Protocol Routing crashes, when using SHORT_SUI_COIN_TYPE\n    if (isSuiCoinType(coinTypeFrom)) {\n      coinTypeFrom = LONG_SUI_COIN_TYPE;\n    } else if (isSuiCoinType(coinTypeTo)) {\n      coinTypeTo = LONG_SUI_COIN_TYPE;\n    }\n\n    const inputCoinData = await this.provider.getCoinMetadata({ coinType: coinTypeFrom });\n\n    if (inputCoinData === null) {\n      throw new Error(`[Interest] Cannot get coin metadata for \"${coinTypeFrom}\".`);\n    }\n\n    const inputCoinDecimals = inputCoinData.decimals;\n    const formattedInputAmount = new BigNumber(inputAmount).multipliedBy(10 ** inputCoinDecimals).toString();\n\n    const { routes, poolsMap } = await this.interestSdk.getRoutesQuotes({\n      coinIn: coinTypeFrom,\n      coinOut: coinTypeTo,\n      amount: BigInt(formattedInputAmount),\n    });\n\n    const [coinPath, poolObjectIdPath, amountObject] = getBestInterestRoute(routes);\n    const bestRoute: SwapRouteArgs[\"route\"] = [coinPath, poolObjectIdPath];\n    const amountWithSlippage = getAmountWithSlippage(amountObject.amount.toString(), slippagePercentage);\n\n    return {\n      outputAmount: BigInt(amountWithSlippage),\n      route: {\n        bestRoute,\n        poolsMap,\n        inputCoinType: coinTypeFrom,\n        minAmount: BigInt(amountWithSlippage),\n        formattedInputAmount,\n      },\n    };\n  }\n\n  /**\n   * @public\n   * @method getSwapTransaction\n   * @description Retrieves the swap transaction for the given route and public key.\n   * @param {InterestRouteData} route - The complete trade route.\n   * @param {string} publicKey - The public key.\n   * @return {Promise<TransactionBlock>} A Promise that resolves to the swap transaction.\n   */\n  public async getSwapTransaction({\n    route,\n    publicKey,\n  }: {\n    route: InterestRouteData;\n    publicKey: string;\n    slippagePercentage: number;\n  }): Promise<TransactionBlock> {\n    const tx = new UpdatedTransactionBlock();\n    const { bestRoute, poolsMap, inputCoinType, minAmount, formattedInputAmount } = route;\n\n    const inputCoinObjects = await getUserCoinObjects({ coinType: inputCoinType, provider: this.provider, publicKey });\n    let destinationObjectId: MoveObjectArgument;\n\n    // If SUI is an input coin, just split a needed for a swap input amount from gas object.\n    if (isSuiCoinType(inputCoinType)) {\n      const [coin] = tx.splitCoins(tx.gas, [tx.pure(formattedInputAmount)]);\n      destinationObjectId = coin;\n    } else {\n      // If the input coin is not SUI, merge all its objects into one and split the needed for the swap input amount\n      // from the merge-result object.\n      const { destinationObjectId: mergeDestination } = WalletManagerSingleton.mergeAllCoinObjects({\n        coinObjects: inputCoinObjects,\n        txb: tx,\n      });\n\n      const [coin] = tx.splitCoins(tx.object(mergeDestination), [tx.pure(formattedInputAmount)]);\n      destinationObjectId = coin;\n    }\n\n    const { coinOut, txb } = this.interestSdk.swapRoute({\n      txb: tx,\n      coinIn: destinationObjectId,\n      route: bestRoute,\n      poolsMap,\n      minAmount,\n    });\n\n    txb.transferObjects([coinOut], txb.pure(publicKey));\n\n    const txBlock = new TransactionBlock(TransactionBlock.from(txb.serialize()));\n\n    return txBlock;\n  }\n\n  /**\n   * Gets a transaction block for swapping tokens based on provided swap data.\n   *\n   * Note: This method is not implemented yet.\n   *\n   * @public\n   * @async\n   * @param {SwapRequiredData} route - The required data for the swap.\n   * @param {string} publicKey - The public key of the user.\n   * @param {number} [slippagePercentage=10] - The slippage percentage.\n   * @return {Promise<TransactionBlock>} A Promise that resolves to a TransactionBlock.\n   */\n  public async getSwapTransactionDoctored({\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    route,\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    publicKey,\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    slippagePercentage = 10,\n  }: {\n    route: InterestRouteData;\n    publicKey: string;\n    slippagePercentage: number;\n  }): Promise<TransactionBlock> {\n    throw new Error(`[${this.providerName}] getSwapTransactionDoctored method not implemented`);\n  }\n\n  /**\n   * Removes the current instance of AftermathSingleton.\n   *\n   * Disclaimer: While this method in this class is marked as public, it is strongly discouraged\n   * to use it directly unless you are certain about the behavior.\n   */\n  public static removeInstance() {\n    InterestProtocolSingleton._instance = undefined;\n  }\n\n  public buildDcaTxBlockAdapter = () => {\n    throw new Error(\"Not implemented\");\n  };\n}\n","import { SuiClient as UpdatedSuiClient } from \"@mysten/sui.js-0.51.2/client\";\nimport { CoinStruct, PaginatedCoins, SuiClient } from \"@mysten/sui.js/client\";\n\n/**\n * @description Retrieves all coin objects associated with a wallet with `publicKey` and specified `coinType`.\n *\n * @param {Object} params - Parameters object.\n * @param {string} params.publicKey - The public key of the wallet.\n * @param {string} params.coinType - The coin type of specified coin.\n * @param {string} params.provider - The Sui Client to fetch coin objects data.\n * @return {Promise<CoinStruct[]>} A promise that resolves to an array of coin objects data.\n */\nexport async function getUserCoinObjects({\n  coinType,\n  publicKey,\n  provider,\n}: {\n  coinType: string;\n  publicKey: string;\n  provider: SuiClient | UpdatedSuiClient;\n}): Promise<CoinStruct[]> {\n  const pageCapacity = 50;\n  const allObjects: CoinStruct[] = [];\n  let nextCursor: string | null | undefined = null;\n  let assets: PaginatedCoins = await provider.getCoins({\n    owner: publicKey,\n    coinType,\n    limit: pageCapacity,\n    cursor: nextCursor,\n  });\n\n  // Fetching and combining part\n  while (assets.hasNextPage) {\n    const coinObjects: CoinStruct[] = assets.data;\n    allObjects.push(...coinObjects);\n\n    nextCursor = assets.nextCursor;\n    assets = await provider.getCoins({\n      owner: publicKey,\n      coinType,\n      limit: pageCapacity,\n      cursor: nextCursor,\n    });\n  }\n\n  // In case user has less tokens than `pageCapacity` (1 page only), we should put them into `allObjects`\n  const coinObjects: CoinStruct[] = assets.data;\n  allObjects.push(...coinObjects);\n\n  return allObjects;\n}\n","/* eslint-disable require-jsdoc */\nimport {\n  CoinState,\n  InterestPool,\n  RebalancingParams,\n  StableFees,\n  StablePoolState,\n  VolatileFees,\n  VolatilePoolState,\n} from \"@interest-protocol/clamm-sdk\";\n\nexport function isApiResponseValid(pools: unknown): pools is InterestPool[] {\n  return pools !== undefined && Array.isArray(pools) && pools.length > 0 && pools.every(isInterestPool);\n}\n\nexport function isInterestPool(pool: unknown): pool is InterestPool {\n  if (\n    typeof pool !== \"object\" ||\n    pool === null ||\n    !(\"poolObjectId\" in pool && typeof pool.poolObjectId === \"string\") ||\n    !(\"lpCoinType\" in pool && typeof pool.lpCoinType === \"string\") ||\n    !(\"isStable\" in pool && typeof pool.isStable === \"boolean\") ||\n    !(\"coinTypes\" in pool && Array.isArray(pool.coinTypes)) ||\n    !(\"state\" in pool && typeof pool.state === \"object\")\n  ) {\n    return false;\n  }\n\n  if (pool.isStable) {\n    if (!isStablePoolState(pool.state)) {\n      return false;\n    }\n  } else {\n    if (!isVolatilePoolState(pool.state)) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nexport function isStablePoolState(state: unknown): state is StablePoolState {\n  return (\n    typeof state === \"object\" &&\n    state !== null &&\n    \"lpCoinSupply\" in state &&\n    typeof state.lpCoinSupply === \"bigint\" &&\n    \"lpCoinDecimals\" in state &&\n    typeof state.lpCoinDecimals === \"number\" &&\n    \"balances\" in state &&\n    Array.isArray(state.balances) &&\n    state.balances.every((balance: unknown) => typeof balance === \"bigint\") &&\n    \"initialA\" in state &&\n    typeof state.initialA === \"bigint\" &&\n    \"futureA\" in state &&\n    typeof state.futureA === \"bigint\" &&\n    \"initialATime\" in state &&\n    typeof state.initialATime === \"bigint\" &&\n    \"futureATime\" in state &&\n    typeof state.futureATime === \"bigint\" &&\n    \"nCoins\" in state &&\n    typeof state.nCoins === \"number\" &&\n    \"fees\" in state &&\n    isStableFees(state.fees)\n  );\n}\n\nexport function isVolatilePoolState(state: unknown): state is VolatilePoolState {\n  return (\n    typeof state === \"object\" &&\n    state !== null &&\n    \"a\" in state &&\n    typeof state.a === \"bigint\" &&\n    \"futureA\" in state &&\n    typeof state.futureA === \"bigint\" &&\n    \"gamma\" in state &&\n    typeof state.gamma === \"bigint\" &&\n    \"initialTime\" in state &&\n    typeof state.initialTime === \"bigint\" &&\n    \"futureGamma\" in state &&\n    typeof state.futureGamma === \"bigint\" &&\n    \"futureTime\" in state &&\n    typeof state.futureTime === \"bigint\" &&\n    \"adminBalance\" in state &&\n    typeof state.adminBalance === \"bigint\" &&\n    \"balances\" in state &&\n    Array.isArray(state.balances) &&\n    state.balances.every((balance) => typeof balance === \"bigint\") &&\n    \"d\" in state &&\n    typeof state.d === \"bigint\" &&\n    \"fees\" in state &&\n    isVolatileFees(state.fees) &&\n    \"lastPriceTimestamp\" in state &&\n    typeof state.lastPriceTimestamp === \"bigint\" &&\n    \"lpCoinSupply\" in state &&\n    typeof state.lpCoinSupply === \"bigint\" &&\n    \"maxA\" in state &&\n    typeof state.maxA === \"bigint\" &&\n    \"minA\" in state &&\n    typeof state.minA === \"bigint\" &&\n    \"nCoins\" in state &&\n    typeof state.nCoins === \"number\" &&\n    \"rebalancingParams\" in state &&\n    isRebalancingParams(state.rebalancingParams) &&\n    \"virtualPrice\" in state &&\n    typeof state.virtualPrice === \"bigint\" &&\n    \"xcpProfit\" in state &&\n    typeof state.xcpProfit === \"bigint\" &&\n    \"xcpProfitA\" in state &&\n    typeof state.xcpProfitA === \"bigint\" &&\n    \"notAdjusted\" in state &&\n    typeof state.notAdjusted === \"boolean\" &&\n    \"coinStateMap\" in state &&\n    isCoinStateMap(state.coinStateMap)\n  );\n}\n\nfunction isStableFees(fees: unknown): fees is StableFees {\n  return (\n    typeof fees === \"object\" &&\n    fees !== null &&\n    \"feeInPercent\" in fees &&\n    typeof fees.feeInPercent === \"bigint\" &&\n    \"feeOutPercent\" in fees &&\n    typeof fees.feeOutPercent === \"bigint\" &&\n    \"adminFeePercent\" in fees &&\n    typeof fees.adminFeePercent === \"bigint\"\n  );\n}\n\nfunction isVolatileFees(fees: unknown): fees is VolatileFees {\n  return (\n    typeof fees === \"object\" &&\n    fees !== null &&\n    \"adminFee\" in fees &&\n    typeof fees.adminFee === \"bigint\" &&\n    \"gammaFee\" in fees &&\n    typeof fees.gammaFee === \"bigint\" &&\n    \"midFee\" in fees &&\n    typeof fees.midFee === \"bigint\" &&\n    \"outFee\" in fees &&\n    typeof fees.outFee === \"bigint\"\n  );\n}\n\nfunction isRebalancingParams(params: unknown): params is RebalancingParams {\n  return (\n    typeof params === \"object\" &&\n    params !== null &&\n    \"adjustmentStep\" in params &&\n    typeof params.adjustmentStep === \"bigint\" &&\n    \"extraProfit\" in params &&\n    typeof params.extraProfit === \"bigint\" &&\n    \"maHalfTime\" in params &&\n    typeof params.maHalfTime === \"bigint\"\n  );\n}\n\nfunction isCoinStateMap(map: unknown): map is Record<string, CoinState> {\n  return typeof map === \"object\" && map !== null && Object.values(map).every(isCoinState);\n}\n\nfunction isCoinState(state: unknown): state is CoinState {\n  return (\n    typeof state === \"object\" &&\n    state !== null &&\n    \"index\" in state &&\n    typeof state.index === \"number\" &&\n    \"lastPrice\" in state &&\n    typeof state.lastPrice === \"bigint\" &&\n    \"price\" in state &&\n    typeof state.price === \"bigint\" &&\n    \"priceOracle\" in state &&\n    typeof state.priceOracle === \"bigint\" &&\n    \"type\" in state &&\n    typeof state.type === \"string\"\n  );\n}\n","import { GetRouteQuotesReturn, InterestPool } from \"@interest-protocol/clamm-sdk\";\nimport BigNumber from \"bignumber.js\";\nimport { CommonPoolData } from \"../types\";\nimport { ROUTES_QUOTES_AMOUNT_OBJECT_INDEX } from \"./config\";\n\nexport const getPathMapAndCoinTypesSet = (\n  pools: InterestPool[],\n): {\n  pathMap: Map<string, CommonPoolData>;\n  coinTypesSet: Set<string>;\n} => {\n  const pathMap: Map<string, CommonPoolData> = new Map();\n  const coinTypesSet: Set<string> = new Set();\n\n  pools.forEach((pool: InterestPool) => {\n    const coinTypes = pool.coinTypes;\n    const base: string = coinTypes[0];\n    const quote: string = coinTypes[1];\n\n    // Fill pathMap\n    const commonPoolData: CommonPoolData = {\n      base,\n      quote,\n    };\n    const poolKey = `${base}-${quote}`;\n    pathMap.set(poolKey, commonPoolData);\n\n    // Fill coinTypeSet\n    coinTypesSet.add(base);\n    coinTypesSet.add(quote);\n  });\n\n  return { pathMap, coinTypesSet };\n};\n\nexport const getBestInterestRoute = (routes: GetRouteQuotesReturn[\"routes\"]): GetRouteQuotesReturn[\"routes\"][0] => {\n  const bestRoute = routes.reduce((bestRoute, currentRoute) => {\n    const bestAmount = bestRoute[ROUTES_QUOTES_AMOUNT_OBJECT_INDEX].amount;\n    const currentAmount = currentRoute[ROUTES_QUOTES_AMOUNT_OBJECT_INDEX].amount;\n\n    return bestAmount > currentAmount ? bestRoute : currentRoute;\n  });\n\n  return bestRoute;\n};\n\nexport const getAmountWithSlippage = (amount: string, slippagePercentage: number): string => {\n  const slippageAmount = new BigNumber(amount).multipliedBy(slippagePercentage).div(100);\n\n  return new BigNumber(amount).minus(slippageAmount).toFixed(0);\n};\n","export const ROUTES_QUOTES_AMOUNT_OBJECT_INDEX = 2;\n","import { GetCacheParams, IStorage, RedisStorageClient, SetCacheParams, StorageValue } from \"./types\";\nimport { isStorageValue } from \"./utils/typeguards\";\n\n/**\n * Singleton class for Redis storage implementation.\n *\n * Disclaimer: While the methods in this class are marked as public,\n * it is strongly discouraged to use them directly unless you are certain\n * about their behavior. For typical SDK usage, consider interacting with\n * the SDK's public API instead of directly using the methods of this class.\n * External usage may lead to unintended behavior and issues.\n */\nexport class RedisStorageSingleton implements IStorage {\n  private static _instance: RedisStorageSingleton | undefined;\n  private client: RedisStorageClient;\n  private static version = 3;\n\n  /**\n   * Constructs a RedisStorageSingleton instance.\n   * @param {RedisStorageClient} client - The Redis client instance.\n   */\n  private constructor(client: RedisStorageClient) {\n    this.client = client;\n  }\n\n  /**\n   * Gets the instance of the RedisStorageSingleton.\n   * @param {RedisStorageClient} [client] - The optional Redis client instance.\n   * @return {RedisStorageSingleton} - The singleton instance.\n   * @throws {Error} If the client is not provided for the first instance creation.\n   */\n  public static getInstance(client?: RedisStorageClient): RedisStorageSingleton {\n    if (!RedisStorageSingleton._instance) {\n      if (client === undefined) {\n        throw new Error(\"[RedisStorage] Client is required in arguments to create instance.\");\n      }\n\n      const instance = new RedisStorageSingleton(client);\n      RedisStorageSingleton._instance = instance;\n    }\n\n    return RedisStorageSingleton._instance;\n  }\n\n  /**\n   * Sets cache data in Redis.\n   * @param {SetCacheParams} params - Parameters containing provider, property, and value.\n   * @return {Promise<void>} - A promise that resolves once the cache is set.\n   * @throws {Error} - Throws an error if setting the cache fails.\n   */\n  public async setCache(params: SetCacheParams): Promise<void> {\n    const { provider, property, value } = params;\n    const key = `${provider}.${property}.${RedisStorageSingleton.version}`;\n    const stringifiedValue: string = JSON.stringify(value);\n\n    const setResult = await this.client.set(key, stringifiedValue);\n\n    if (setResult !== \"OK\") {\n      console.debug(\"[RedisStorageSingleton] setCache failed for setting data in redis, params: \", params);\n      throw new Error(\"[RedisStorageSingleton] setCache failed\");\n    }\n  }\n\n  /**\n   * Retrieves cache data from Redis.\n   * @param {GetCacheParams} params - Parameters containing provider and property.\n   * @return {Promise<StorageValue>} - A promise that resolves to the retrieved StorageValue or null if not found.\n   * @throws {Error} - Throws an error if the retrieved value is not a valid StorageValue.\n   */\n  public async getCache(params: GetCacheParams): Promise<StorageValue> {\n    const { provider, property } = params;\n    const key = `${provider}.${property}.${RedisStorageSingleton.version}`;\n    const value = await this.client.get(key);\n\n    if (value === null) {\n      return null;\n    }\n\n    const parsedValue: unknown = JSON.parse(value);\n\n    if (isStorageValue(parsedValue)) {\n      return parsedValue;\n    } else {\n      throw new Error(`[RedisStorage] getCache: value ${value} is not StorageValue.`);\n    }\n  }\n\n  /**\n   * Removes the current instance of RedisStorageSingleton.\n   *\n   * Disclaimer: While this method in this class is marked as public, it is strongly discouraged\n   * to use it directly unless you are certain about the behavior.\n   */\n  public static removeInstance() {\n    RedisStorageSingleton._instance = undefined;\n  }\n}\n","/* eslint-disable require-jsdoc */\nimport { SuiClient, SuiTransactionBlockResponse } from \"@mysten/sui.js/client\";\nimport { TransactionBlock } from \"@mysten/sui.js/transactions\";\nimport { SUI_DECIMALS, fromB64 } from \"@mysten/sui.js/utils\";\nimport BigNumber from \"bignumber.js\";\nimport {\n  buy as createBuyTicketTransaction,\n  createUserState as createUserStateTransaction,\n} from \"./__generated__/meme/meme/functions\";\nimport { State, UserState } from \"./__generated__/meme/meme/structs\";\nimport { SURF } from \"./__generated__/meme/surf/structs\";\nimport { SurfDogConfig } from \"./types\";\n\nexport class SurfdogLaunchpadSingleton {\n  private static _instance: SurfdogLaunchpadSingleton;\n  private provider: SuiClient;\n  private config: SurfDogConfig;\n  public static GAS_BUDGET_FOR_BUYING_TICKET = 10_000_000;\n\n  /**\n   * Constructs a new instance of the SuiProvider class with the provided SUI provider URL.\n   *\n   * @private\n   * @constructor\n   * @param {string} suiProviderUrl - The URL of the SUI provider.\n   * @param {SurfDogConfig} [config] - Config for SurfDog\n   */\n  private constructor(suiProviderUrl: string, config: SurfDogConfig) {\n    this.provider = new SuiClient({ url: suiProviderUrl });\n    this.config = config;\n  }\n\n  /**\n   * @public\n   * @method getInstance\n   * @description Gets the singleton instance of SurfdogLaunchpadSingleton.\n   * @param {string} [suiProviderUrl] - Url of SUI provider.\n   * @param {SurfDogConfig} [config] - Config for SurfDog\n   * @return {SurfdogLaunchpadSingleton} The singleton instance of SurfdogLaunchpadSingleton.\n   */\n  public static getInstance(suiProviderUrl?: string, config?: SurfDogConfig): SurfdogLaunchpadSingleton {\n    if (!SurfdogLaunchpadSingleton._instance) {\n      if (suiProviderUrl === undefined) {\n        throw new Error(\n          \"[SurfdogLaunchpadSingleton] SUI provider url is required in arguments to create SurfdogLaunchpad instance.\",\n        );\n      }\n\n      if (config === undefined) {\n        throw new Error(\n          \"[SurfdogLaunchpadSingleton] config is required in arguments to create SurfdogLaunchpad instance.\",\n        );\n      }\n\n      const instance = new SurfdogLaunchpadSingleton(suiProviderUrl, config);\n      SurfdogLaunchpadSingleton._instance = instance;\n    }\n\n    return SurfdogLaunchpadSingleton._instance;\n  }\n\n  public async getUserState(publicKey: string) {\n    // TODO: Might be dangeours in case user has more than 50 user states\n    const object = await this.provider.getOwnedObjects({\n      filter: { StructType: UserState.$typeName },\n      options: {\n        showContent: true,\n        showOwner: true,\n        showType: true,\n        showStorageRebate: true,\n        showBcs: true,\n      },\n      owner: publicKey,\n    });\n\n    if (!(Array.isArray(object.data) && object.data[0] && object.data[0].data && object.data[0].data.bcs)) {\n      console.warn(`User ${publicKey} does not have state objects`);\n\n      return null;\n    }\n\n    const userStateBcs = object.data[0].data.bcs;\n\n    const isBcsBytesInStateBcs = \"bcsBytes\" in userStateBcs;\n    if (!isBcsBytesInStateBcs) {\n      console.error(\"[SurfdogLaunchpadSingleton.getUserState] bcsBytes does not exist stateBcs\", userStateBcs);\n      throw new Error(\"bcsBytes does not exist stateBcs\");\n    }\n\n    const userState = UserState.fromBcs(fromB64(userStateBcs.bcsBytes));\n    const userGameState = {\n      allTickets: userState.allTickets,\n      id: userState.id,\n      wonTickets: userState.wonTickets,\n    };\n\n    return userGameState;\n  }\n\n  public async getGameState() {\n    const object = await this.provider.getObject({\n      id: this.config.GAME_ADDRESS,\n      options: {\n        showBcs: true,\n        showContent: true,\n      },\n    });\n\n    if (!object.data) {\n      console.error(\"[SurfdogLaunchpadSingleton.getGameState] object.data\", object.data);\n      throw new Error(\"Failed to fetch game state: object.data is empty\");\n    }\n\n    const stateBcs = object.data.bcs;\n    if (!stateBcs) {\n      console.error(\"[SurfdogLaunchpadSingleton.getGameState] State does not exist bsc\", stateBcs);\n      throw new Error(\"State does not exist bsc\");\n    }\n\n    const isBcsBytesInStateBcs = \"bcsBytes\" in stateBcs;\n    if (!isBcsBytesInStateBcs) {\n      console.error(\"[SurfdogLaunchpadSingleton.getGameState] bcsBytes does not exist stateBcs\", stateBcs);\n      throw new Error(\"bcsBytes does not exist stateBcs\");\n    }\n\n    const globalState = State.fromBcs(State.phantom(SURF.phantom()), fromB64(stateBcs.bcsBytes));\n    const globalStateParsed = {\n      allTickets: globalState.allTickets,\n      startTimestamp: globalState.start,\n      ticketPrice: globalState.ticketPrice,\n      tokensPerTicket: globalState.tokensPerTicket,\n      winningTickets: globalState.wonTickets,\n      balanceLeft: globalState.balance.value,\n    };\n\n    return globalStateParsed;\n  }\n\n  public async createUserState() {\n    const tx = new TransactionBlock();\n\n    const userStateTxRes = createUserStateTransaction(tx);\n\n    return { tx, txRes: userStateTxRes };\n  }\n\n  public async buyTicket({ ticketPrice, userStateId }: { ticketPrice: string; userStateId: string }) {\n    const tx = new TransactionBlock();\n\n    const [coin] = tx.splitCoins(tx.gas, [tx.pure(ticketPrice)]);\n\n    const buyUserTicketTxRes = createBuyTicketTransaction(tx, SURF.$typeName, {\n      clock: this.config.CLOCK_ADDRESS,\n      state: this.config.GAME_ADDRESS,\n      userState: userStateId,\n      payment: coin,\n    });\n\n    tx.setGasBudget(SurfdogLaunchpadSingleton.GAS_BUDGET_FOR_BUYING_TICKET);\n\n    return { tx, txRes: buyUserTicketTxRes };\n  }\n\n  public checkSpinStatusByTx({ tx }: { tx: SuiTransactionBlockResponse }) {\n    if (!tx.balanceChanges) {\n      console.error(\"[SurfdogLaunchpadSingleton.checkSpinStatusByTx]\", tx);\n\n      throw new Error(\"No balanceChanges present in spin transaction\");\n    }\n\n    const surfMoved = tx.balanceChanges.find((a) => a.coinType === SURF.$typeName);\n    if (surfMoved) {\n      // user has won\n      // console.debug(\"[SurfdogLaunchpadSingleton.checkSpinStatusByTx] user won\");\n      return true;\n    } else {\n      // user has lost\n      // console.debug(\"[SurfdogLaunchpadSingleton.checkSpinStatusByTx] user lost\");\n      return false;\n    }\n  }\n\n  public getMaxTicketsCount(suiBalance: string, ticketPrice: string) {\n    const suiBalanceBN = new BigNumber(suiBalance);\n    const ticketPriceBN = new BigNumber(ticketPrice);\n    const gasBudgetBN = new BigNumber(SurfdogLaunchpadSingleton.GAS_BUDGET_FOR_BUYING_TICKET).dividedBy(\n      10 ** SUI_DECIMALS,\n    );\n\n    let ticketsCount = 0;\n    let availableSuiBalanceBN = suiBalanceBN;\n\n    while (availableSuiBalanceBN.gte(ticketPriceBN.plus(gasBudgetBN))) {\n      ticketsCount = ticketsCount + 1;\n      availableSuiBalanceBN = availableSuiBalanceBN.minus(ticketPriceBN.plus(gasBudgetBN));\n    }\n\n    return ticketsCount;\n  }\n}\n","export const PACKAGE_ID = \"0xe2d76c57bb1cf8b511f6f4bbbab7d575ab221d2c84b3ccb5eee2ef999c7dc61f\";\nexport const PUBLISHED_AT = \"0xe2d76c57bb1cf8b511f6f4bbbab7d575ab221d2c84b3ccb5eee2ef999c7dc61f\";\n","import {\n  TransactionArgument,\n  TransactionBlock,\n  TransactionArgument as TransactionObjectArgument,\n} from \"@mysten/sui.js/transactions\";\nimport { bcs, ObjectArg as SuiObjectArg } from \"@mysten/sui.js/bcs\";\nimport { BcsType } from \"@mysten/bcs\";\n\nexport interface FieldsWithTypes {\n  /* eslint-disable @typescript-eslint/no-explicit-any */\n  fields: Record<string, any>;\n  type: string;\n}\n\nexport type ObjectId = string;\n\nexport type ObjectCallArg = { Object: SuiObjectArg };\n\nexport type ObjectArg = string | ObjectCallArg | TransactionArgument;\n\nexport type PureArg = bigint | string | number | boolean | null | TransactionArgument | Array<PureArg>;\nexport type GenericArg = ObjectArg | PureArg | Array<ObjectArg> | Array<PureArg> | Array<GenericArg>;\n\nexport function parseTypeName(name: string): { typeName: string; typeArgs: string[] } {\n  const parsed = bcs.parseTypeName(name);\n  return { typeName: parsed.name, typeArgs: parsed.params as string[] };\n}\n\nexport function isTransactionArgument(arg: GenericArg): arg is TransactionArgument {\n  if (!arg || typeof arg !== \"object\" || Array.isArray(arg)) {\n    return false;\n  }\n\n  return \"kind\" in arg;\n}\n\nexport function isTransactionObjectArgument(arg: GenericArg): arg is TransactionObjectArgument {\n  if (!isTransactionArgument(arg)) {\n    return false;\n  }\n\n  if (arg.kind === \"Input\" && arg.type === \"pure\") {\n    return false;\n  }\n\n  return true;\n}\n\nexport function obj(txb: TransactionBlock, arg: ObjectArg) {\n  return isTransactionArgument(arg) ? arg : txb.object(arg);\n}\n\nexport function compressSuiAddress(addr: string): string {\n  // remove leading zeros\n  const stripped = addr.split(\"0x\").join(\"\");\n  for (let i = 0; i < stripped.length; i++) {\n    if (stripped[i] !== \"0\") {\n      return `0x${stripped.substring(i)}`;\n    }\n  }\n  return \"0x0\";\n}\n\n// Recursively removes leading zeros from a type.\n// e.g. `0x00000002::module::Name<0x00001::a::C>` -> `0x2::module::Name<0x1::a::C>`\nexport function compressSuiType(type: string): string {\n  const { typeName, typeArgs } = parseTypeName(type);\n  switch (typeName) {\n    case \"bool\":\n    case \"u8\":\n    case \"u16\":\n    case \"u32\":\n    case \"u64\":\n    case \"u128\":\n    case \"u256\":\n    case \"address\":\n    case \"signer\":\n      return typeName;\n    case \"vector\":\n      return `vector<${compressSuiType(typeArgs[0])}>`;\n    default: {\n      const tok = typeName.split(\"::\");\n      tok[0] = compressSuiAddress(tok[0]);\n      const compressedName = tok.join(\"::\");\n      if (typeArgs.length > 0) {\n        return `${compressedName}<${typeArgs.map((typeArg) => compressSuiType(typeArg)).join(\",\")}>`;\n      } else {\n        return compressedName;\n      }\n    }\n  }\n}\n\nexport function composeSuiType(typeName: string, ...typeArgs: string[]): string {\n  if (typeArgs.length > 0) {\n    return `${typeName}<${typeArgs.join(\", \")}>`;\n  } else {\n    return typeName;\n  }\n}\n","import { PUBLISHED_AT } from \"..\";\nimport { ObjectArg, obj } from \"../../_framework/util\";\nimport { TransactionArgument, TransactionBlock } from \"@mysten/sui.js/transactions\";\n\nexport interface BuyArgs {\n  state: ObjectArg;\n  userState: ObjectArg;\n  payment: ObjectArg;\n  clock: ObjectArg;\n}\n\nexport function buy(txb: TransactionBlock, typeArg: string, args: BuyArgs) {\n  return txb.moveCall({\n    target: `${PUBLISHED_AT}::meme::buy`,\n    typeArguments: [typeArg],\n    arguments: [obj(txb, args.state), obj(txb, args.userState), obj(txb, args.payment), obj(txb, args.clock)],\n  });\n}\n\nexport interface CreateStateArgs {\n  deposit: ObjectArg;\n  start: bigint | TransactionArgument;\n  end: bigint | TransactionArgument;\n}\n\nexport function createState(txb: TransactionBlock, typeArg: string, args: CreateStateArgs) {\n  return txb.moveCall({\n    target: `${PUBLISHED_AT}::meme::create_state`,\n    typeArguments: [typeArg],\n    arguments: [obj(txb, args.deposit), txb.pure(args.start, \"u64\"), txb.pure(args.end, \"u64\")],\n  });\n}\n\nexport function createUserState(txb: TransactionBlock) {\n  return txb.moveCall({\n    target: `${PUBLISHED_AT}::meme::create_user_state`,\n    arguments: [],\n  });\n}\n\nexport function init(txb: TransactionBlock) {\n  return txb.moveCall({\n    target: `${PUBLISHED_AT}::meme::init`,\n    arguments: [],\n  });\n}\n","import { BcsType, bcs, fromHEX, toHEX } from \"@mysten/bcs\";\nimport { FieldsWithTypes, compressSuiType, parseTypeName } from \"./util\";\nimport { SuiClient, SuiParsedData } from \"@mysten/sui.js/client\";\n\nexport interface StructClass {\n  $typeName: string;\n  $fullTypeName: string;\n  $typeArgs: string[];\n  toJSONField(): Record<string, any>;\n  toJSON(): Record<string, any>;\n}\n\nexport interface VectorClass {\n  $fullTypeName: string;\n  toJSONField(): any[];\n\n  readonly vec: any;\n\n  readonly kind: \"VectorClass\";\n}\n\nexport class Vector<T extends TypeArgument> implements VectorClass {\n  readonly $fullTypeName: `vector<${ToTypeStr<T>}>`;\n\n  readonly vec: Array<ToField<T>>;\n  constructor(fullTypeName: string, vec: Array<ToField<T>>) {\n    this.$fullTypeName = fullTypeName as `vector<${ToTypeStr<T>}>`;\n    this.vec = vec;\n  }\n\n  toJSONField(): Array<ToJSON<T>> {\n    return null as any;\n  }\n\n  readonly kind = \"VectorClass\";\n}\n\nexport type Primitive = \"bool\" | \"u8\" | \"u16\" | \"u32\" | \"u64\" | \"u128\" | \"u256\" | \"address\";\nexport type TypeArgument = StructClass | Primitive | VectorClass;\n\nexport interface StructClassReified<T extends StructClass, Fields> {\n  typeName: T[\"$typeName\"]; // e.g., '0x2::balance::Balance', without type arguments\n  fullTypeName: ToTypeStr<T>; // e.g., '0x2::balance::Balance<0x2::sui:SUI>'\n  typeArgs: T[\"$typeArgs\"]; // e.g., ['0x2::sui:SUI']\n  reifiedTypeArgs: Array<Reified<TypeArgument, any> | PhantomReified<PhantomTypeArgument>>;\n  bcs: BcsType<any>;\n  fromFields(fields: Record<string, any>): T;\n  fromFieldsWithTypes(item: FieldsWithTypes): T;\n  fromBcs(data: Uint8Array): T;\n  fromJSONField: (field: any) => T;\n  fromJSON: (json: Record<string, any>) => T;\n  fromSuiParsedData: (content: SuiParsedData) => T;\n  fetch: (client: SuiClient, id: string) => Promise<T>;\n  new: (fields: Fields) => T;\n  kind: \"StructClassReified\";\n}\n\nexport interface VectorClassReified<T extends VectorClass> {\n  fullTypeName: ToTypeStr<T>;\n  bcs: BcsType<any>;\n  fromFields(fields: any[]): T;\n  fromFieldsWithTypes(item: FieldsWithTypes): T;\n  fromJSONField: (field: any) => T;\n  kind: \"VectorClassReified\";\n}\n\nexport type Reified<T extends TypeArgument, Fields> = T extends Primitive\n  ? Primitive\n  : T extends StructClass\n    ? StructClassReified<T, Fields>\n    : T extends VectorClass\n      ? VectorClassReified<T>\n      : never;\n\nexport type ToTypeArgument<\n  T extends Primitive | StructClassReified<StructClass, any> | VectorClassReified<VectorClass>,\n> = T extends Primitive\n  ? T\n  : T extends StructClassReified<infer U, any>\n    ? U\n    : T extends VectorClassReified<infer U>\n      ? U\n      : never;\n\nexport type ToPhantomTypeArgument<T extends PhantomReified<PhantomTypeArgument>> =\n  T extends PhantomReified<infer U> ? U : never;\n\nexport type PhantomTypeArgument = string;\n\nexport interface PhantomReified<P> {\n  phantomType: P;\n  kind: \"PhantomReified\";\n}\n\nexport function phantom<T extends Reified<TypeArgument, any>>(reified: T): PhantomReified<ToTypeStr<ToTypeArgument<T>>>;\nexport function phantom<P extends PhantomTypeArgument>(phantomType: P): PhantomReified<P>;\nexport function phantom(type: string | Reified<TypeArgument, any>): PhantomReified<string> {\n  if (typeof type === \"string\") {\n    return {\n      phantomType: type,\n      kind: \"PhantomReified\",\n    };\n  } else {\n    return {\n      phantomType: type.fullTypeName,\n      kind: \"PhantomReified\",\n    };\n  }\n}\n\nexport type ToTypeStr<T extends TypeArgument> = T extends Primitive\n  ? T\n  : T extends StructClass\n    ? T[\"$fullTypeName\"]\n    : T extends VectorClass\n      ? T[\"$fullTypeName\"]\n      : never;\n\nexport type PhantomToTypeStr<T extends PhantomTypeArgument> = T extends PhantomTypeArgument ? T : never;\n\nexport function vector<T extends Reified<TypeArgument, any>>(T: T): VectorClassReified<Vector<ToTypeArgument<T>>> {\n  const fullTypeName = `vector<${extractType(T)}>` as `vector<${ToTypeStr<ToTypeArgument<T>>}>`;\n\n  return {\n    fullTypeName,\n    bcs: bcs.vector(toBcs(T)),\n    fromFieldsWithTypes: (item: FieldsWithTypes) => {\n      return new Vector(\n        fullTypeName,\n        (item as unknown as any[]).map((field: any) => decodeFromFieldsWithTypes(T, field)),\n      );\n    },\n    fromFields: (fields: any[]) => {\n      return new Vector(\n        fullTypeName,\n        fields.map((field) => decodeFromFields(T, field)),\n      );\n    },\n\n    fromJSONField: (field: any) =>\n      new Vector(\n        fullTypeName,\n        field.map((field: any) => decodeFromJSONField(T, field)),\n      ),\n    kind: \"VectorClassReified\",\n  };\n}\n\nexport type ToJSON<T extends TypeArgument> = T extends \"bool\"\n  ? boolean\n  : T extends \"u8\"\n    ? number\n    : T extends \"u16\"\n      ? number\n      : T extends \"u32\"\n        ? number\n        : T extends \"u64\"\n          ? string\n          : T extends \"u128\"\n            ? string\n            : T extends \"u256\"\n              ? string\n              : T extends \"address\"\n                ? string\n                : T extends { $typeName: \"0x1::string::String\" }\n                  ? string\n                  : T extends { $typeName: \"0x1::ascii::String\" }\n                    ? string\n                    : T extends { $typeName: \"0x2::object::UID\" }\n                      ? string\n                      : T extends { $typeName: \"0x2::object::ID\" }\n                        ? string\n                        : T extends { $typeName: \"0x2::url::Url\" }\n                          ? string\n                          : T extends {\n                                $typeName: \"0x1::option::Option\";\n                                __inner: infer U extends TypeArgument;\n                              }\n                            ? ToJSON<U> | null\n                            : T extends VectorClass\n                              ? ReturnType<T[\"toJSONField\"]>\n                              : T extends StructClass\n                                ? ReturnType<T[\"toJSONField\"]>\n                                : never;\n\nexport type ToField<T extends TypeArgument> = T extends \"bool\"\n  ? boolean\n  : T extends \"u8\"\n    ? number\n    : T extends \"u16\"\n      ? number\n      : T extends \"u32\"\n        ? number\n        : T extends \"u64\"\n          ? bigint\n          : T extends \"u128\"\n            ? bigint\n            : T extends \"u256\"\n              ? bigint\n              : T extends \"address\"\n                ? string\n                : T extends { $typeName: \"0x1::string::String\" }\n                  ? string\n                  : T extends { $typeName: \"0x1::ascii::String\" }\n                    ? string\n                    : T extends { $typeName: \"0x2::object::UID\" }\n                      ? string\n                      : T extends { $typeName: \"0x2::object::ID\" }\n                        ? string\n                        : T extends { $typeName: \"0x2::url::Url\" }\n                          ? string\n                          : T extends {\n                                $typeName: \"0x1::option::Option\";\n                                __inner: infer U extends TypeArgument;\n                              }\n                            ? ToField<U> | null\n                            : T extends VectorClass\n                              ? T[\"vec\"]\n                              : T extends StructClass\n                                ? T\n                                : never;\n\nconst Address = bcs.bytes(32).transform({\n  input: (val: string) => fromHEX(val),\n  output: (val) => toHEX(val),\n});\n\nexport function toBcs<T extends Reified<TypeArgument, any>>(arg: T): BcsType<any> {\n  switch (arg) {\n    case \"bool\":\n      return bcs.bool();\n    case \"u8\":\n      return bcs.u8();\n    case \"u16\":\n      return bcs.u16();\n    case \"u32\":\n      return bcs.u32();\n    case \"u64\":\n      return bcs.u64();\n    case \"u128\":\n      return bcs.u128();\n    case \"u256\":\n      return bcs.u256();\n    case \"address\":\n      return Address;\n    default:\n      return arg.bcs;\n  }\n}\n\nexport function extractType<T extends Reified<TypeArgument, any>>(reified: T): ToTypeStr<ToTypeArgument<T>>;\nexport function extractType<T extends PhantomReified<PhantomTypeArgument>>(\n  reified: T,\n): PhantomToTypeStr<ToPhantomTypeArgument<T>>;\nexport function extractType<T extends Reified<TypeArgument, any> | PhantomReified<PhantomTypeArgument>>(\n  reified: T,\n): string;\nexport function extractType(reified: Reified<TypeArgument, any> | PhantomReified<string>): string {\n  switch (reified) {\n    case \"u8\":\n    case \"u16\":\n    case \"u32\":\n    case \"u64\":\n    case \"u128\":\n    case \"u256\":\n    case \"bool\":\n    case \"address\":\n      return reified;\n  }\n  switch (reified.kind) {\n    case \"PhantomReified\":\n      return reified.phantomType;\n    case \"StructClassReified\":\n      return reified.fullTypeName;\n    case \"VectorClassReified\":\n      return reified.fullTypeName;\n  }\n\n  throw new Error(\"unreachable\");\n}\n\nexport function decodeFromFields(reified: Reified<TypeArgument, any>, field: any) {\n  switch (reified) {\n    case \"bool\":\n    case \"u8\":\n    case \"u16\":\n    case \"u32\":\n      return field;\n    case \"u64\":\n    case \"u128\":\n    case \"u256\":\n      return BigInt(field);\n    case \"address\":\n      return `0x${field}`;\n  }\n  if (reified.kind === \"VectorClassReified\") {\n    return reified.fromFields(field).vec;\n  }\n  switch (reified.typeName) {\n    case \"0x1::string::String\":\n    case \"0x1::ascii::String\":\n      return new TextDecoder().decode(Uint8Array.from(field.bytes)).toString();\n    case \"0x2::url::Url\":\n      return new TextDecoder().decode(Uint8Array.from(field.url.bytes)).toString();\n    case \"0x2::object::ID\":\n      return `0x${field.bytes}`;\n    case \"0x2::object::UID\":\n      return `0x${field.id.bytes}`;\n    case \"0x1::option::Option\": {\n      if (field.vec.length === 0) {\n        return null;\n      }\n      return (reified.fromFields(field) as any).vec[0];\n    }\n    default:\n      return reified.fromFields(field);\n  }\n}\n\nexport function decodeFromFieldsWithTypes(reified: Reified<TypeArgument, any>, item: any) {\n  switch (reified) {\n    case \"bool\":\n    case \"u8\":\n    case \"u16\":\n    case \"u32\":\n      return item;\n    case \"u64\":\n    case \"u128\":\n    case \"u256\":\n      return BigInt(item);\n    case \"address\":\n      return item;\n  }\n  if (reified.kind === \"VectorClassReified\") {\n    return reified.fromFieldsWithTypes(item).vec;\n  }\n  switch (reified.typeName) {\n    case \"0x1::string::String\":\n    case \"0x1::ascii::String\":\n    case \"0x2::url::Url\":\n    case \"0x2::object::ID\":\n      return item;\n    case \"0x2::object::UID\":\n      return item.id;\n    case \"0x2::balance::Balance\":\n      return reified.fromFields({ value: BigInt(item) });\n    case \"0x1::option::Option\": {\n      if (item === null) {\n        return null;\n      }\n      return decodeFromFieldsWithTypes((reified as any).reifiedTypeArgs[0], item);\n    }\n    default:\n      return reified.fromFieldsWithTypes(item);\n  }\n}\n\nexport function assertReifiedTypeArgsMatch(\n  fullType: string,\n  typeArgs: string[],\n  reifiedTypeArgs: Array<Reified<TypeArgument, any> | PhantomReified<string>>,\n) {\n  if (reifiedTypeArgs.length !== typeArgs.length) {\n    throw new Error(\n      `provided item has mismatching number of type argments ${fullType} (expected ${reifiedTypeArgs.length}, got ${typeArgs.length}))`,\n    );\n  }\n  for (let i = 0; i < typeArgs.length; i++) {\n    if (compressSuiType(typeArgs[i]) !== compressSuiType(extractType(reifiedTypeArgs[i]))) {\n      throw new Error(\n        `provided item has mismatching type argments ${fullType} (expected ${extractType(\n          reifiedTypeArgs[i],\n        )}, got ${typeArgs[i]}))`,\n      );\n    }\n  }\n}\n\nexport function assertFieldsWithTypesArgsMatch(\n  item: FieldsWithTypes,\n  reifiedTypeArgs: Array<Reified<TypeArgument, any> | PhantomReified<string>>,\n) {\n  const { typeArgs: itemTypeArgs } = parseTypeName(item.type);\n  assertReifiedTypeArgsMatch(item.type, itemTypeArgs, reifiedTypeArgs);\n}\n\nexport function fieldToJSON<T extends TypeArgument>(type: string, field: ToField<T>): ToJSON<T> {\n  const { typeName, typeArgs } = parseTypeName(type);\n  switch (typeName) {\n    case \"bool\":\n      return field as any;\n    case \"u8\":\n    case \"u16\":\n    case \"u32\":\n      return field as any;\n    case \"u64\":\n    case \"u128\":\n    case \"u256\":\n      return field.toString() as any;\n    case \"address\":\n    case \"signer\":\n      return field as any;\n    case \"vector\":\n      return (field as any[]).map((item: any) => fieldToJSON(typeArgs[0], item)) as any;\n    // handle special types\n    case \"0x1::string::String\":\n    case \"0x1::ascii::String\":\n    case \"0x2::url::Url\":\n    case \"0x2::object::ID\":\n    case \"0x2::object::UID\":\n      return field as any;\n    case \"0x1::option::Option\": {\n      if (field === null) {\n        return null as any;\n      }\n      return fieldToJSON(typeArgs[0], field);\n    }\n    default:\n      return (field as any).toJSONField();\n  }\n}\n\nexport function decodeFromJSONField(typeArg: Reified<TypeArgument, any>, field: any) {\n  switch (typeArg) {\n    case \"bool\":\n    case \"u8\":\n    case \"u16\":\n    case \"u32\":\n      return field;\n    case \"u64\":\n    case \"u128\":\n    case \"u256\":\n      return BigInt(field);\n    case \"address\":\n      return field;\n  }\n  if (typeArg.kind === \"VectorClassReified\") {\n    return typeArg.fromJSONField(field).vec;\n  }\n  switch (typeArg.typeName) {\n    case \"0x1::string::String\":\n    case \"0x1::ascii::String\":\n    case \"0x2::url::Url\":\n    case \"0x2::object::ID\":\n    case \"0x2::object::UID\":\n      return field;\n    case \"0x1::option::Option\": {\n      if (field === null) {\n        return null;\n      }\n      return decodeFromJSONField(typeArg.reifiedTypeArgs[0] as any, field);\n    }\n    default:\n      return typeArg.fromJSONField(field);\n  }\n}\n","import {\n  PhantomReified,\n  PhantomToTypeStr,\n  PhantomTypeArgument,\n  Reified,\n  StructClass,\n  ToField,\n  ToPhantomTypeArgument,\n  ToTypeStr,\n  assertFieldsWithTypesArgsMatch,\n  assertReifiedTypeArgsMatch,\n  decodeFromFields,\n  decodeFromFieldsWithTypes,\n  decodeFromJSONField,\n  extractType,\n  phantom,\n} from \"../../../../_framework/reified\";\nimport { FieldsWithTypes, composeSuiType, compressSuiType } from \"../../../../_framework/util\";\nimport { bcs, fromB64 } from \"@mysten/bcs\";\nimport { SuiClient, SuiParsedData } from \"@mysten/sui.js/client\";\n\n/* ============================== Balance =============================== */\n\nexport function isBalance(type: string): boolean {\n  type = compressSuiType(type);\n  return type.startsWith(\"0x2::balance::Balance<\");\n}\n\nexport interface BalanceFields<T extends PhantomTypeArgument> {\n  value: ToField<\"u64\">;\n}\n\nexport type BalanceReified<T extends PhantomTypeArgument> = Reified<Balance<T>, BalanceFields<T>>;\n\nexport class Balance<T extends PhantomTypeArgument> implements StructClass {\n  static readonly $typeName = \"0x2::balance::Balance\";\n  static readonly $numTypeParams = 1;\n\n  readonly $typeName = Balance.$typeName;\n\n  readonly $fullTypeName: `0x2::balance::Balance<${PhantomToTypeStr<T>}>`;\n\n  readonly $typeArgs: [PhantomToTypeStr<T>];\n\n  readonly value: ToField<\"u64\">;\n\n  private constructor(typeArgs: [PhantomToTypeStr<T>], fields: BalanceFields<T>) {\n    this.$fullTypeName = composeSuiType(\n      Balance.$typeName,\n      ...typeArgs,\n    ) as `0x2::balance::Balance<${PhantomToTypeStr<T>}>`;\n    this.$typeArgs = typeArgs;\n\n    this.value = fields.value;\n  }\n\n  static reified<T extends PhantomReified<PhantomTypeArgument>>(T: T): BalanceReified<ToPhantomTypeArgument<T>> {\n    return {\n      typeName: Balance.$typeName,\n      fullTypeName: composeSuiType(\n        Balance.$typeName,\n        ...[extractType(T)],\n      ) as `0x2::balance::Balance<${PhantomToTypeStr<ToPhantomTypeArgument<T>>}>`,\n      typeArgs: [extractType(T)] as [PhantomToTypeStr<ToPhantomTypeArgument<T>>],\n      reifiedTypeArgs: [T],\n      fromFields: (fields: Record<string, any>) => Balance.fromFields(T, fields),\n      fromFieldsWithTypes: (item: FieldsWithTypes) => Balance.fromFieldsWithTypes(T, item),\n      fromBcs: (data: Uint8Array) => Balance.fromBcs(T, data),\n      bcs: Balance.bcs,\n      fromJSONField: (field: any) => Balance.fromJSONField(T, field),\n      fromJSON: (json: Record<string, any>) => Balance.fromJSON(T, json),\n      fromSuiParsedData: (content: SuiParsedData) => Balance.fromSuiParsedData(T, content),\n      fetch: async (client: SuiClient, id: string) => Balance.fetch(client, T, id),\n      new: (fields: BalanceFields<ToPhantomTypeArgument<T>>) => {\n        return new Balance([extractType(T)], fields);\n      },\n      kind: \"StructClassReified\",\n    };\n  }\n\n  static get r() {\n    return Balance.reified;\n  }\n\n  static phantom<T extends PhantomReified<PhantomTypeArgument>>(\n    T: T,\n  ): PhantomReified<ToTypeStr<Balance<ToPhantomTypeArgument<T>>>> {\n    return phantom(Balance.reified(T));\n  }\n\n  static get p() {\n    return Balance.phantom;\n  }\n\n  static get bcs() {\n    return bcs.struct(\"Balance\", {\n      value: bcs.u64(),\n    });\n  }\n\n  static fromFields<T extends PhantomReified<PhantomTypeArgument>>(\n    typeArg: T,\n    fields: Record<string, any>,\n  ): Balance<ToPhantomTypeArgument<T>> {\n    return Balance.reified(typeArg).new({ value: decodeFromFields(\"u64\", fields.value) });\n  }\n\n  static fromFieldsWithTypes<T extends PhantomReified<PhantomTypeArgument>>(\n    typeArg: T,\n    item: FieldsWithTypes,\n  ): Balance<ToPhantomTypeArgument<T>> {\n    if (!isBalance(item.type)) {\n      throw new Error(\"not a Balance type\");\n    }\n    assertFieldsWithTypesArgsMatch(item, [typeArg]);\n\n    return Balance.reified(typeArg).new({ value: decodeFromFieldsWithTypes(\"u64\", item.fields.value) });\n  }\n\n  static fromBcs<T extends PhantomReified<PhantomTypeArgument>>(\n    typeArg: T,\n    data: Uint8Array,\n  ): Balance<ToPhantomTypeArgument<T>> {\n    return Balance.fromFields(typeArg, Balance.bcs.parse(data));\n  }\n\n  toJSONField() {\n    return {\n      value: this.value.toString(),\n    };\n  }\n\n  toJSON() {\n    return {\n      $typeName: this.$typeName,\n      $typeArgs: this.$typeArgs,\n      ...this.toJSONField(),\n    };\n  }\n\n  static fromJSONField<T extends PhantomReified<PhantomTypeArgument>>(\n    typeArg: T,\n    field: any,\n  ): Balance<ToPhantomTypeArgument<T>> {\n    return Balance.reified(typeArg).new({ value: decodeFromJSONField(\"u64\", field.value) });\n  }\n\n  static fromJSON<T extends PhantomReified<PhantomTypeArgument>>(\n    typeArg: T,\n    json: Record<string, any>,\n  ): Balance<ToPhantomTypeArgument<T>> {\n    if (json.$typeName !== Balance.$typeName) {\n      throw new Error(\"not a WithTwoGenerics json object\");\n    }\n    assertReifiedTypeArgsMatch(composeSuiType(Balance.$typeName, extractType(typeArg)), json.$typeArgs, [typeArg]);\n\n    return Balance.fromJSONField(typeArg, json);\n  }\n\n  static fromSuiParsedData<T extends PhantomReified<PhantomTypeArgument>>(\n    typeArg: T,\n    content: SuiParsedData,\n  ): Balance<ToPhantomTypeArgument<T>> {\n    if (content.dataType !== \"moveObject\") {\n      throw new Error(\"not an object\");\n    }\n    if (!isBalance(content.type)) {\n      throw new Error(`object at ${(content.fields as any).id} is not a Balance object`);\n    }\n    return Balance.fromFieldsWithTypes(typeArg, content);\n  }\n\n  static async fetch<T extends PhantomReified<PhantomTypeArgument>>(\n    client: SuiClient,\n    typeArg: T,\n    id: string,\n  ): Promise<Balance<ToPhantomTypeArgument<T>>> {\n    const res = await client.getObject({\n      id,\n      options: {\n        showBcs: true,\n      },\n    });\n    if (res.error) {\n      throw new Error(`error fetching Balance object at id ${id}: ${res.error.code}`);\n    }\n    if (res.data?.bcs?.dataType !== \"moveObject\" || !isBalance(res.data.bcs.type)) {\n      throw new Error(`object at id ${id} is not a Balance object`);\n    }\n\n    return Balance.fromBcs(typeArg, fromB64(res.data.bcs.bcsBytes));\n  }\n}\n\n/* ============================== Supply =============================== */\n\nexport function isSupply(type: string): boolean {\n  type = compressSuiType(type);\n  return type.startsWith(\"0x2::balance::Supply<\");\n}\n\nexport interface SupplyFields<T extends PhantomTypeArgument> {\n  value: ToField<\"u64\">;\n}\n\nexport type SupplyReified<T extends PhantomTypeArgument> = Reified<Supply<T>, SupplyFields<T>>;\n\nexport class Supply<T extends PhantomTypeArgument> implements StructClass {\n  static readonly $typeName = \"0x2::balance::Supply\";\n  static readonly $numTypeParams = 1;\n\n  readonly $typeName = Supply.$typeName;\n\n  readonly $fullTypeName: `0x2::balance::Supply<${PhantomToTypeStr<T>}>`;\n\n  readonly $typeArgs: [PhantomToTypeStr<T>];\n\n  readonly value: ToField<\"u64\">;\n\n  private constructor(typeArgs: [PhantomToTypeStr<T>], fields: SupplyFields<T>) {\n    this.$fullTypeName = composeSuiType(\n      Supply.$typeName,\n      ...typeArgs,\n    ) as `0x2::balance::Supply<${PhantomToTypeStr<T>}>`;\n    this.$typeArgs = typeArgs;\n\n    this.value = fields.value;\n  }\n\n  static reified<T extends PhantomReified<PhantomTypeArgument>>(T: T): SupplyReified<ToPhantomTypeArgument<T>> {\n    return {\n      typeName: Supply.$typeName,\n      fullTypeName: composeSuiType(\n        Supply.$typeName,\n        ...[extractType(T)],\n      ) as `0x2::balance::Supply<${PhantomToTypeStr<ToPhantomTypeArgument<T>>}>`,\n      typeArgs: [extractType(T)] as [PhantomToTypeStr<ToPhantomTypeArgument<T>>],\n      reifiedTypeArgs: [T],\n      fromFields: (fields: Record<string, any>) => Supply.fromFields(T, fields),\n      fromFieldsWithTypes: (item: FieldsWithTypes) => Supply.fromFieldsWithTypes(T, item),\n      fromBcs: (data: Uint8Array) => Supply.fromBcs(T, data),\n      bcs: Supply.bcs,\n      fromJSONField: (field: any) => Supply.fromJSONField(T, field),\n      fromJSON: (json: Record<string, any>) => Supply.fromJSON(T, json),\n      fromSuiParsedData: (content: SuiParsedData) => Supply.fromSuiParsedData(T, content),\n      fetch: async (client: SuiClient, id: string) => Supply.fetch(client, T, id),\n      new: (fields: SupplyFields<ToPhantomTypeArgument<T>>) => {\n        return new Supply([extractType(T)], fields);\n      },\n      kind: \"StructClassReified\",\n    };\n  }\n\n  static get r() {\n    return Supply.reified;\n  }\n\n  static phantom<T extends PhantomReified<PhantomTypeArgument>>(\n    T: T,\n  ): PhantomReified<ToTypeStr<Supply<ToPhantomTypeArgument<T>>>> {\n    return phantom(Supply.reified(T));\n  }\n\n  static get p() {\n    return Supply.phantom;\n  }\n\n  static get bcs() {\n    return bcs.struct(\"Supply\", {\n      value: bcs.u64(),\n    });\n  }\n\n  static fromFields<T extends PhantomReified<PhantomTypeArgument>>(\n    typeArg: T,\n    fields: Record<string, any>,\n  ): Supply<ToPhantomTypeArgument<T>> {\n    return Supply.reified(typeArg).new({ value: decodeFromFields(\"u64\", fields.value) });\n  }\n\n  static fromFieldsWithTypes<T extends PhantomReified<PhantomTypeArgument>>(\n    typeArg: T,\n    item: FieldsWithTypes,\n  ): Supply<ToPhantomTypeArgument<T>> {\n    if (!isSupply(item.type)) {\n      throw new Error(\"not a Supply type\");\n    }\n    assertFieldsWithTypesArgsMatch(item, [typeArg]);\n\n    return Supply.reified(typeArg).new({ value: decodeFromFieldsWithTypes(\"u64\", item.fields.value) });\n  }\n\n  static fromBcs<T extends PhantomReified<PhantomTypeArgument>>(\n    typeArg: T,\n    data: Uint8Array,\n  ): Supply<ToPhantomTypeArgument<T>> {\n    return Supply.fromFields(typeArg, Supply.bcs.parse(data));\n  }\n\n  toJSONField() {\n    return {\n      value: this.value.toString(),\n    };\n  }\n\n  toJSON() {\n    return {\n      $typeName: this.$typeName,\n      $typeArgs: this.$typeArgs,\n      ...this.toJSONField(),\n    };\n  }\n\n  static fromJSONField<T extends PhantomReified<PhantomTypeArgument>>(\n    typeArg: T,\n    field: any,\n  ): Supply<ToPhantomTypeArgument<T>> {\n    return Supply.reified(typeArg).new({ value: decodeFromJSONField(\"u64\", field.value) });\n  }\n\n  static fromJSON<T extends PhantomReified<PhantomTypeArgument>>(\n    typeArg: T,\n    json: Record<string, any>,\n  ): Supply<ToPhantomTypeArgument<T>> {\n    if (json.$typeName !== Supply.$typeName) {\n      throw new Error(\"not a WithTwoGenerics json object\");\n    }\n    assertReifiedTypeArgsMatch(composeSuiType(Supply.$typeName, extractType(typeArg)), json.$typeArgs, [typeArg]);\n\n    return Supply.fromJSONField(typeArg, json);\n  }\n\n  static fromSuiParsedData<T extends PhantomReified<PhantomTypeArgument>>(\n    typeArg: T,\n    content: SuiParsedData,\n  ): Supply<ToPhantomTypeArgument<T>> {\n    if (content.dataType !== \"moveObject\") {\n      throw new Error(\"not an object\");\n    }\n    if (!isSupply(content.type)) {\n      throw new Error(`object at ${(content.fields as any).id} is not a Supply object`);\n    }\n    return Supply.fromFieldsWithTypes(typeArg, content);\n  }\n\n  static async fetch<T extends PhantomReified<PhantomTypeArgument>>(\n    client: SuiClient,\n    typeArg: T,\n    id: string,\n  ): Promise<Supply<ToPhantomTypeArgument<T>>> {\n    const res = await client.getObject({\n      id,\n      options: {\n        showBcs: true,\n      },\n    });\n    if (res.error) {\n      throw new Error(`error fetching Supply object at id ${id}: ${res.error.code}`);\n    }\n    if (res.data?.bcs?.dataType !== \"moveObject\" || !isSupply(res.data.bcs.type)) {\n      throw new Error(`object at id ${id} is not a Supply object`);\n    }\n\n    return Supply.fromBcs(typeArg, fromB64(res.data.bcs.bcsBytes));\n  }\n}\n","import * as reified from \"../../../../_framework/reified\";\nimport {\n  PhantomReified,\n  Reified,\n  StructClass,\n  ToField,\n  ToTypeArgument,\n  ToTypeStr,\n  TypeArgument,\n  Vector,\n  assertFieldsWithTypesArgsMatch,\n  assertReifiedTypeArgsMatch,\n  decodeFromFields,\n  decodeFromFieldsWithTypes,\n  decodeFromJSONField,\n  extractType,\n  fieldToJSON,\n  phantom,\n  toBcs,\n} from \"../../../../_framework/reified\";\nimport { FieldsWithTypes, composeSuiType, compressSuiType } from \"../../../../_framework/util\";\nimport { BcsType, bcs, fromB64, fromHEX, toHEX } from \"@mysten/bcs\";\nimport { SuiClient, SuiParsedData } from \"@mysten/sui.js/client\";\n\n/* ============================== DynamicFields =============================== */\n\nexport function isDynamicFields(type: string): boolean {\n  type = compressSuiType(type);\n  return type.startsWith(\"0x2::object::DynamicFields<\");\n}\n\nexport interface DynamicFieldsFields<K extends TypeArgument> {\n  names: ToField<Vector<K>>;\n}\n\nexport type DynamicFieldsReified<K extends TypeArgument> = Reified<DynamicFields<K>, DynamicFieldsFields<K>>;\n\nexport class DynamicFields<K extends TypeArgument> implements StructClass {\n  static readonly $typeName = \"0x2::object::DynamicFields\";\n  static readonly $numTypeParams = 1;\n\n  readonly $typeName = DynamicFields.$typeName;\n\n  readonly $fullTypeName: `0x2::object::DynamicFields<${ToTypeStr<K>}>`;\n\n  readonly $typeArgs: [ToTypeStr<K>];\n\n  readonly names: ToField<Vector<K>>;\n\n  private constructor(typeArgs: [ToTypeStr<K>], fields: DynamicFieldsFields<K>) {\n    this.$fullTypeName = composeSuiType(\n      DynamicFields.$typeName,\n      ...typeArgs,\n    ) as `0x2::object::DynamicFields<${ToTypeStr<K>}>`;\n    this.$typeArgs = typeArgs;\n\n    this.names = fields.names;\n  }\n\n  static reified<K extends Reified<TypeArgument, any>>(K: K): DynamicFieldsReified<ToTypeArgument<K>> {\n    return {\n      typeName: DynamicFields.$typeName,\n      fullTypeName: composeSuiType(\n        DynamicFields.$typeName,\n        ...[extractType(K)],\n      ) as `0x2::object::DynamicFields<${ToTypeStr<ToTypeArgument<K>>}>`,\n      typeArgs: [extractType(K)] as [ToTypeStr<ToTypeArgument<K>>],\n      reifiedTypeArgs: [K],\n      fromFields: (fields: Record<string, any>) => DynamicFields.fromFields(K, fields),\n      fromFieldsWithTypes: (item: FieldsWithTypes) => DynamicFields.fromFieldsWithTypes(K, item),\n      fromBcs: (data: Uint8Array) => DynamicFields.fromBcs(K, data),\n      bcs: DynamicFields.bcs(toBcs(K)),\n      fromJSONField: (field: any) => DynamicFields.fromJSONField(K, field),\n      fromJSON: (json: Record<string, any>) => DynamicFields.fromJSON(K, json),\n      fromSuiParsedData: (content: SuiParsedData) => DynamicFields.fromSuiParsedData(K, content),\n      fetch: async (client: SuiClient, id: string) => DynamicFields.fetch(client, K, id),\n      new: (fields: DynamicFieldsFields<ToTypeArgument<K>>) => {\n        return new DynamicFields([extractType(K)], fields);\n      },\n      kind: \"StructClassReified\",\n    };\n  }\n\n  static get r() {\n    return DynamicFields.reified;\n  }\n\n  static phantom<K extends Reified<TypeArgument, any>>(\n    K: K,\n  ): PhantomReified<ToTypeStr<DynamicFields<ToTypeArgument<K>>>> {\n    return phantom(DynamicFields.reified(K));\n  }\n\n  static get p() {\n    return DynamicFields.phantom;\n  }\n\n  static get bcs() {\n    return <K extends BcsType<any>>(K: K) =>\n      bcs.struct(`DynamicFields<${K.name}>`, {\n        names: bcs.vector(K),\n      });\n  }\n\n  static fromFields<K extends Reified<TypeArgument, any>>(\n    typeArg: K,\n    fields: Record<string, any>,\n  ): DynamicFields<ToTypeArgument<K>> {\n    return DynamicFields.reified(typeArg).new({ names: decodeFromFields(reified.vector(typeArg), fields.names) });\n  }\n\n  static fromFieldsWithTypes<K extends Reified<TypeArgument, any>>(\n    typeArg: K,\n    item: FieldsWithTypes,\n  ): DynamicFields<ToTypeArgument<K>> {\n    if (!isDynamicFields(item.type)) {\n      throw new Error(\"not a DynamicFields type\");\n    }\n    assertFieldsWithTypesArgsMatch(item, [typeArg]);\n\n    return DynamicFields.reified(typeArg).new({\n      names: decodeFromFieldsWithTypes(reified.vector(typeArg), item.fields.names),\n    });\n  }\n\n  static fromBcs<K extends Reified<TypeArgument, any>>(typeArg: K, data: Uint8Array): DynamicFields<ToTypeArgument<K>> {\n    const typeArgs = [typeArg];\n\n    return DynamicFields.fromFields(typeArg, DynamicFields.bcs(toBcs(typeArgs[0])).parse(data));\n  }\n\n  toJSONField() {\n    return {\n      names: fieldToJSON<Vector<K>>(`vector<${this.$typeArgs[0]}>`, this.names),\n    };\n  }\n\n  toJSON() {\n    return {\n      $typeName: this.$typeName,\n      $typeArgs: this.$typeArgs,\n      ...this.toJSONField(),\n    };\n  }\n\n  static fromJSONField<K extends Reified<TypeArgument, any>>(typeArg: K, field: any): DynamicFields<ToTypeArgument<K>> {\n    return DynamicFields.reified(typeArg).new({ names: decodeFromJSONField(reified.vector(typeArg), field.names) });\n  }\n\n  static fromJSON<K extends Reified<TypeArgument, any>>(\n    typeArg: K,\n    json: Record<string, any>,\n  ): DynamicFields<ToTypeArgument<K>> {\n    if (json.$typeName !== DynamicFields.$typeName) {\n      throw new Error(\"not a WithTwoGenerics json object\");\n    }\n    assertReifiedTypeArgsMatch(composeSuiType(DynamicFields.$typeName, extractType(typeArg)), json.$typeArgs, [\n      typeArg,\n    ]);\n\n    return DynamicFields.fromJSONField(typeArg, json);\n  }\n\n  static fromSuiParsedData<K extends Reified<TypeArgument, any>>(\n    typeArg: K,\n    content: SuiParsedData,\n  ): DynamicFields<ToTypeArgument<K>> {\n    if (content.dataType !== \"moveObject\") {\n      throw new Error(\"not an object\");\n    }\n    if (!isDynamicFields(content.type)) {\n      throw new Error(`object at ${(content.fields as any).id} is not a DynamicFields object`);\n    }\n    return DynamicFields.fromFieldsWithTypes(typeArg, content);\n  }\n\n  static async fetch<K extends Reified<TypeArgument, any>>(\n    client: SuiClient,\n    typeArg: K,\n    id: string,\n  ): Promise<DynamicFields<ToTypeArgument<K>>> {\n    const res = await client.getObject({\n      id,\n      options: {\n        showBcs: true,\n      },\n    });\n    if (res.error) {\n      throw new Error(`error fetching DynamicFields object at id ${id}: ${res.error.code}`);\n    }\n    if (res.data?.bcs?.dataType !== \"moveObject\" || !isDynamicFields(res.data.bcs.type)) {\n      throw new Error(`object at id ${id} is not a DynamicFields object`);\n    }\n\n    return DynamicFields.fromBcs(typeArg, fromB64(res.data.bcs.bcsBytes));\n  }\n}\n\n/* ============================== ID =============================== */\n\nexport function isID(type: string): boolean {\n  type = compressSuiType(type);\n  return type === \"0x2::object::ID\";\n}\n\nexport interface IDFields {\n  bytes: ToField<\"address\">;\n}\n\nexport type IDReified = Reified<ID, IDFields>;\n\nexport class ID implements StructClass {\n  static readonly $typeName = \"0x2::object::ID\";\n  static readonly $numTypeParams = 0;\n\n  readonly $typeName = ID.$typeName;\n\n  readonly $fullTypeName: \"0x2::object::ID\";\n\n  readonly $typeArgs: [];\n\n  readonly bytes: ToField<\"address\">;\n\n  private constructor(typeArgs: [], fields: IDFields) {\n    this.$fullTypeName = composeSuiType(ID.$typeName, ...typeArgs) as \"0x2::object::ID\";\n    this.$typeArgs = typeArgs;\n\n    this.bytes = fields.bytes;\n  }\n\n  static reified(): IDReified {\n    return {\n      typeName: ID.$typeName,\n      fullTypeName: composeSuiType(ID.$typeName, ...[]) as \"0x2::object::ID\",\n      typeArgs: [] as [],\n      reifiedTypeArgs: [],\n      fromFields: (fields: Record<string, any>) => ID.fromFields(fields),\n      fromFieldsWithTypes: (item: FieldsWithTypes) => ID.fromFieldsWithTypes(item),\n      fromBcs: (data: Uint8Array) => ID.fromBcs(data),\n      bcs: ID.bcs,\n      fromJSONField: (field: any) => ID.fromJSONField(field),\n      fromJSON: (json: Record<string, any>) => ID.fromJSON(json),\n      fromSuiParsedData: (content: SuiParsedData) => ID.fromSuiParsedData(content),\n      fetch: async (client: SuiClient, id: string) => ID.fetch(client, id),\n      new: (fields: IDFields) => {\n        return new ID([], fields);\n      },\n      kind: \"StructClassReified\",\n    };\n  }\n\n  static get r() {\n    return ID.reified();\n  }\n\n  static phantom(): PhantomReified<ToTypeStr<ID>> {\n    return phantom(ID.reified());\n  }\n\n  static get p() {\n    return ID.phantom();\n  }\n\n  static get bcs() {\n    return bcs.struct(\"ID\", {\n      bytes: bcs.bytes(32).transform({ input: (val: string) => fromHEX(val), output: (val: Uint8Array) => toHEX(val) }),\n    });\n  }\n\n  static fromFields(fields: Record<string, any>): ID {\n    return ID.reified().new({ bytes: decodeFromFields(\"address\", fields.bytes) });\n  }\n\n  static fromFieldsWithTypes(item: FieldsWithTypes): ID {\n    if (!isID(item.type)) {\n      throw new Error(\"not a ID type\");\n    }\n\n    return ID.reified().new({ bytes: decodeFromFieldsWithTypes(\"address\", item.fields.bytes) });\n  }\n\n  static fromBcs(data: Uint8Array): ID {\n    return ID.fromFields(ID.bcs.parse(data));\n  }\n\n  toJSONField() {\n    return {\n      bytes: this.bytes,\n    };\n  }\n\n  toJSON() {\n    return {\n      $typeName: this.$typeName,\n      $typeArgs: this.$typeArgs,\n      ...this.toJSONField(),\n    };\n  }\n\n  static fromJSONField(field: any): ID {\n    return ID.reified().new({ bytes: decodeFromJSONField(\"address\", field.bytes) });\n  }\n\n  static fromJSON(json: Record<string, any>): ID {\n    if (json.$typeName !== ID.$typeName) {\n      throw new Error(\"not a WithTwoGenerics json object\");\n    }\n\n    return ID.fromJSONField(json);\n  }\n\n  static fromSuiParsedData(content: SuiParsedData): ID {\n    if (content.dataType !== \"moveObject\") {\n      throw new Error(\"not an object\");\n    }\n    if (!isID(content.type)) {\n      throw new Error(`object at ${(content.fields as any).id} is not a ID object`);\n    }\n    return ID.fromFieldsWithTypes(content);\n  }\n\n  static async fetch(client: SuiClient, id: string): Promise<ID> {\n    const res = await client.getObject({\n      id,\n      options: {\n        showBcs: true,\n      },\n    });\n    if (res.error) {\n      throw new Error(`error fetching ID object at id ${id}: ${res.error.code}`);\n    }\n    if (res.data?.bcs?.dataType !== \"moveObject\" || !isID(res.data.bcs.type)) {\n      throw new Error(`object at id ${id} is not a ID object`);\n    }\n\n    return ID.fromBcs(fromB64(res.data.bcs.bcsBytes));\n  }\n}\n\n/* ============================== Ownership =============================== */\n\nexport function isOwnership(type: string): boolean {\n  type = compressSuiType(type);\n  return type === \"0x2::object::Ownership\";\n}\n\nexport interface OwnershipFields {\n  owner: ToField<\"address\">;\n  status: ToField<\"u64\">;\n}\n\nexport type OwnershipReified = Reified<Ownership, OwnershipFields>;\n\nexport class Ownership implements StructClass {\n  static readonly $typeName = \"0x2::object::Ownership\";\n  static readonly $numTypeParams = 0;\n\n  readonly $typeName = Ownership.$typeName;\n\n  readonly $fullTypeName: \"0x2::object::Ownership\";\n\n  readonly $typeArgs: [];\n\n  readonly owner: ToField<\"address\">;\n  readonly status: ToField<\"u64\">;\n\n  private constructor(typeArgs: [], fields: OwnershipFields) {\n    this.$fullTypeName = composeSuiType(Ownership.$typeName, ...typeArgs) as \"0x2::object::Ownership\";\n    this.$typeArgs = typeArgs;\n\n    this.owner = fields.owner;\n    this.status = fields.status;\n  }\n\n  static reified(): OwnershipReified {\n    return {\n      typeName: Ownership.$typeName,\n      fullTypeName: composeSuiType(Ownership.$typeName, ...[]) as \"0x2::object::Ownership\",\n      typeArgs: [] as [],\n      reifiedTypeArgs: [],\n      fromFields: (fields: Record<string, any>) => Ownership.fromFields(fields),\n      fromFieldsWithTypes: (item: FieldsWithTypes) => Ownership.fromFieldsWithTypes(item),\n      fromBcs: (data: Uint8Array) => Ownership.fromBcs(data),\n      bcs: Ownership.bcs,\n      fromJSONField: (field: any) => Ownership.fromJSONField(field),\n      fromJSON: (json: Record<string, any>) => Ownership.fromJSON(json),\n      fromSuiParsedData: (content: SuiParsedData) => Ownership.fromSuiParsedData(content),\n      fetch: async (client: SuiClient, id: string) => Ownership.fetch(client, id),\n      new: (fields: OwnershipFields) => {\n        return new Ownership([], fields);\n      },\n      kind: \"StructClassReified\",\n    };\n  }\n\n  static get r() {\n    return Ownership.reified();\n  }\n\n  static phantom(): PhantomReified<ToTypeStr<Ownership>> {\n    return phantom(Ownership.reified());\n  }\n\n  static get p() {\n    return Ownership.phantom();\n  }\n\n  static get bcs() {\n    return bcs.struct(\"Ownership\", {\n      owner: bcs.bytes(32).transform({ input: (val: string) => fromHEX(val), output: (val: Uint8Array) => toHEX(val) }),\n      status: bcs.u64(),\n    });\n  }\n\n  static fromFields(fields: Record<string, any>): Ownership {\n    return Ownership.reified().new({\n      owner: decodeFromFields(\"address\", fields.owner),\n      status: decodeFromFields(\"u64\", fields.status),\n    });\n  }\n\n  static fromFieldsWithTypes(item: FieldsWithTypes): Ownership {\n    if (!isOwnership(item.type)) {\n      throw new Error(\"not a Ownership type\");\n    }\n\n    return Ownership.reified().new({\n      owner: decodeFromFieldsWithTypes(\"address\", item.fields.owner),\n      status: decodeFromFieldsWithTypes(\"u64\", item.fields.status),\n    });\n  }\n\n  static fromBcs(data: Uint8Array): Ownership {\n    return Ownership.fromFields(Ownership.bcs.parse(data));\n  }\n\n  toJSONField() {\n    return {\n      owner: this.owner,\n      status: this.status.toString(),\n    };\n  }\n\n  toJSON() {\n    return {\n      $typeName: this.$typeName,\n      $typeArgs: this.$typeArgs,\n      ...this.toJSONField(),\n    };\n  }\n\n  static fromJSONField(field: any): Ownership {\n    return Ownership.reified().new({\n      owner: decodeFromJSONField(\"address\", field.owner),\n      status: decodeFromJSONField(\"u64\", field.status),\n    });\n  }\n\n  static fromJSON(json: Record<string, any>): Ownership {\n    if (json.$typeName !== Ownership.$typeName) {\n      throw new Error(\"not a WithTwoGenerics json object\");\n    }\n\n    return Ownership.fromJSONField(json);\n  }\n\n  static fromSuiParsedData(content: SuiParsedData): Ownership {\n    if (content.dataType !== \"moveObject\") {\n      throw new Error(\"not an object\");\n    }\n    if (!isOwnership(content.type)) {\n      throw new Error(`object at ${(content.fields as any).id} is not a Ownership object`);\n    }\n    return Ownership.fromFieldsWithTypes(content);\n  }\n\n  static async fetch(client: SuiClient, id: string): Promise<Ownership> {\n    const res = await client.getObject({\n      id,\n      options: {\n        showBcs: true,\n      },\n    });\n    if (res.error) {\n      throw new Error(`error fetching Ownership object at id ${id}: ${res.error.code}`);\n    }\n    if (res.data?.bcs?.dataType !== \"moveObject\" || !isOwnership(res.data.bcs.type)) {\n      throw new Error(`object at id ${id} is not a Ownership object`);\n    }\n\n    return Ownership.fromBcs(fromB64(res.data.bcs.bcsBytes));\n  }\n}\n\n/* ============================== UID =============================== */\n\nexport function isUID(type: string): boolean {\n  type = compressSuiType(type);\n  return type === \"0x2::object::UID\";\n}\n\nexport interface UIDFields {\n  id: ToField<ID>;\n}\n\nexport type UIDReified = Reified<UID, UIDFields>;\n\nexport class UID implements StructClass {\n  static readonly $typeName = \"0x2::object::UID\";\n  static readonly $numTypeParams = 0;\n\n  readonly $typeName = UID.$typeName;\n\n  readonly $fullTypeName: \"0x2::object::UID\";\n\n  readonly $typeArgs: [];\n\n  readonly id: ToField<ID>;\n\n  private constructor(typeArgs: [], fields: UIDFields) {\n    this.$fullTypeName = composeSuiType(UID.$typeName, ...typeArgs) as \"0x2::object::UID\";\n    this.$typeArgs = typeArgs;\n\n    this.id = fields.id;\n  }\n\n  static reified(): UIDReified {\n    return {\n      typeName: UID.$typeName,\n      fullTypeName: composeSuiType(UID.$typeName, ...[]) as \"0x2::object::UID\",\n      typeArgs: [] as [],\n      reifiedTypeArgs: [],\n      fromFields: (fields: Record<string, any>) => UID.fromFields(fields),\n      fromFieldsWithTypes: (item: FieldsWithTypes) => UID.fromFieldsWithTypes(item),\n      fromBcs: (data: Uint8Array) => UID.fromBcs(data),\n      bcs: UID.bcs,\n      fromJSONField: (field: any) => UID.fromJSONField(field),\n      fromJSON: (json: Record<string, any>) => UID.fromJSON(json),\n      fromSuiParsedData: (content: SuiParsedData) => UID.fromSuiParsedData(content),\n      fetch: async (client: SuiClient, id: string) => UID.fetch(client, id),\n      new: (fields: UIDFields) => {\n        return new UID([], fields);\n      },\n      kind: \"StructClassReified\",\n    };\n  }\n\n  static get r() {\n    return UID.reified();\n  }\n\n  static phantom(): PhantomReified<ToTypeStr<UID>> {\n    return phantom(UID.reified());\n  }\n\n  static get p() {\n    return UID.phantom();\n  }\n\n  static get bcs() {\n    return bcs.struct(\"UID\", {\n      id: ID.bcs,\n    });\n  }\n\n  static fromFields(fields: Record<string, any>): UID {\n    return UID.reified().new({ id: decodeFromFields(ID.reified(), fields.id) });\n  }\n\n  static fromFieldsWithTypes(item: FieldsWithTypes): UID {\n    if (!isUID(item.type)) {\n      throw new Error(\"not a UID type\");\n    }\n\n    return UID.reified().new({ id: decodeFromFieldsWithTypes(ID.reified(), item.fields.id) });\n  }\n\n  static fromBcs(data: Uint8Array): UID {\n    return UID.fromFields(UID.bcs.parse(data));\n  }\n\n  toJSONField() {\n    return {\n      id: this.id,\n    };\n  }\n\n  toJSON() {\n    return {\n      $typeName: this.$typeName,\n      $typeArgs: this.$typeArgs,\n      ...this.toJSONField(),\n    };\n  }\n\n  static fromJSONField(field: any): UID {\n    return UID.reified().new({ id: decodeFromJSONField(ID.reified(), field.id) });\n  }\n\n  static fromJSON(json: Record<string, any>): UID {\n    if (json.$typeName !== UID.$typeName) {\n      throw new Error(\"not a WithTwoGenerics json object\");\n    }\n\n    return UID.fromJSONField(json);\n  }\n\n  static fromSuiParsedData(content: SuiParsedData): UID {\n    if (content.dataType !== \"moveObject\") {\n      throw new Error(\"not an object\");\n    }\n    if (!isUID(content.type)) {\n      throw new Error(`object at ${(content.fields as any).id} is not a UID object`);\n    }\n    return UID.fromFieldsWithTypes(content);\n  }\n\n  static async fetch(client: SuiClient, id: string): Promise<UID> {\n    const res = await client.getObject({\n      id,\n      options: {\n        showBcs: true,\n      },\n    });\n    if (res.error) {\n      throw new Error(`error fetching UID object at id ${id}: ${res.error.code}`);\n    }\n    if (res.data?.bcs?.dataType !== \"moveObject\" || !isUID(res.data.bcs.type)) {\n      throw new Error(`object at id ${id} is not a UID object`);\n    }\n\n    return UID.fromBcs(fromB64(res.data.bcs.bcsBytes));\n  }\n}\n","import { Balance } from \"../../_dependencies/source/0x2/balance/structs\";\nimport { UID } from \"../../_dependencies/source/0x2/object/structs\";\nimport {\n  PhantomReified,\n  PhantomToTypeStr,\n  PhantomTypeArgument,\n  Reified,\n  StructClass,\n  ToField,\n  ToPhantomTypeArgument,\n  ToTypeStr,\n  assertFieldsWithTypesArgsMatch,\n  assertReifiedTypeArgsMatch,\n  decodeFromFields,\n  decodeFromFieldsWithTypes,\n  decodeFromJSONField,\n  extractType,\n  phantom,\n} from \"../../_framework/reified\";\nimport { FieldsWithTypes, composeSuiType, compressSuiType } from \"../../_framework/util\";\nimport { bcs, fromB64 } from \"@mysten/bcs\";\nimport { SuiClient, SuiParsedData } from \"@mysten/sui.js/client\";\n\n/* ============================== MemCoinOwnerCap =============================== */\n\nexport function isMemCoinOwnerCap(type: string): boolean {\n  type = compressSuiType(type);\n  return type === \"0xd06278ad71b5a4d622f179bd21d163d2efc8aaf14e1750884026f63e3d07ca3a::meme::MemCoinOwnerCap\";\n}\n\nexport interface MemCoinOwnerCapFields {\n  id: ToField<UID>;\n}\n\nexport type MemCoinOwnerCapReified = Reified<MemCoinOwnerCap, MemCoinOwnerCapFields>;\n\nexport class MemCoinOwnerCap implements StructClass {\n  static readonly $typeName =\n    \"0xd06278ad71b5a4d622f179bd21d163d2efc8aaf14e1750884026f63e3d07ca3a::meme::MemCoinOwnerCap\";\n  static readonly $numTypeParams = 0;\n\n  readonly $typeName = MemCoinOwnerCap.$typeName;\n\n  readonly $fullTypeName: \"0xd06278ad71b5a4d622f179bd21d163d2efc8aaf14e1750884026f63e3d07ca3a::meme::MemCoinOwnerCap\";\n\n  readonly $typeArgs: [];\n\n  readonly id: ToField<UID>;\n\n  private constructor(typeArgs: [], fields: MemCoinOwnerCapFields) {\n    this.$fullTypeName = composeSuiType(\n      MemCoinOwnerCap.$typeName,\n      ...typeArgs,\n    ) as \"0xd06278ad71b5a4d622f179bd21d163d2efc8aaf14e1750884026f63e3d07ca3a::meme::MemCoinOwnerCap\";\n    this.$typeArgs = typeArgs;\n\n    this.id = fields.id;\n  }\n\n  static reified(): MemCoinOwnerCapReified {\n    return {\n      typeName: MemCoinOwnerCap.$typeName,\n      fullTypeName: composeSuiType(\n        MemCoinOwnerCap.$typeName,\n        ...[],\n      ) as \"0xd06278ad71b5a4d622f179bd21d163d2efc8aaf14e1750884026f63e3d07ca3a::meme::MemCoinOwnerCap\",\n      typeArgs: [] as [],\n      reifiedTypeArgs: [],\n      fromFields: (fields: Record<string, any>) => MemCoinOwnerCap.fromFields(fields),\n      fromFieldsWithTypes: (item: FieldsWithTypes) => MemCoinOwnerCap.fromFieldsWithTypes(item),\n      fromBcs: (data: Uint8Array) => MemCoinOwnerCap.fromBcs(data),\n      bcs: MemCoinOwnerCap.bcs,\n      fromJSONField: (field: any) => MemCoinOwnerCap.fromJSONField(field),\n      fromJSON: (json: Record<string, any>) => MemCoinOwnerCap.fromJSON(json),\n      fromSuiParsedData: (content: SuiParsedData) => MemCoinOwnerCap.fromSuiParsedData(content),\n      fetch: async (client: SuiClient, id: string) => MemCoinOwnerCap.fetch(client, id),\n      new: (fields: MemCoinOwnerCapFields) => {\n        return new MemCoinOwnerCap([], fields);\n      },\n      kind: \"StructClassReified\",\n    };\n  }\n\n  static get r() {\n    return MemCoinOwnerCap.reified();\n  }\n\n  static phantom(): PhantomReified<ToTypeStr<MemCoinOwnerCap>> {\n    return phantom(MemCoinOwnerCap.reified());\n  }\n\n  static get p() {\n    return MemCoinOwnerCap.phantom();\n  }\n\n  static get bcs() {\n    return bcs.struct(\"MemCoinOwnerCap\", {\n      id: UID.bcs,\n    });\n  }\n\n  static fromFields(fields: Record<string, any>): MemCoinOwnerCap {\n    return MemCoinOwnerCap.reified().new({ id: decodeFromFields(UID.reified(), fields.id) });\n  }\n\n  static fromFieldsWithTypes(item: FieldsWithTypes): MemCoinOwnerCap {\n    if (!isMemCoinOwnerCap(item.type)) {\n      throw new Error(\"not a MemCoinOwnerCap type\");\n    }\n\n    return MemCoinOwnerCap.reified().new({ id: decodeFromFieldsWithTypes(UID.reified(), item.fields.id) });\n  }\n\n  static fromBcs(data: Uint8Array): MemCoinOwnerCap {\n    return MemCoinOwnerCap.fromFields(MemCoinOwnerCap.bcs.parse(data));\n  }\n\n  toJSONField() {\n    return {\n      id: this.id,\n    };\n  }\n\n  toJSON() {\n    return {\n      $typeName: this.$typeName,\n      $typeArgs: this.$typeArgs,\n      ...this.toJSONField(),\n    };\n  }\n\n  static fromJSONField(field: any): MemCoinOwnerCap {\n    return MemCoinOwnerCap.reified().new({ id: decodeFromJSONField(UID.reified(), field.id) });\n  }\n\n  static fromJSON(json: Record<string, any>): MemCoinOwnerCap {\n    if (json.$typeName !== MemCoinOwnerCap.$typeName) {\n      throw new Error(\"not a WithTwoGenerics json object\");\n    }\n\n    return MemCoinOwnerCap.fromJSONField(json);\n  }\n\n  static fromSuiParsedData(content: SuiParsedData): MemCoinOwnerCap {\n    if (content.dataType !== \"moveObject\") {\n      throw new Error(\"not an object\");\n    }\n    if (!isMemCoinOwnerCap(content.type)) {\n      throw new Error(`object at ${(content.fields as any).id} is not a MemCoinOwnerCap object`);\n    }\n    return MemCoinOwnerCap.fromFieldsWithTypes(content);\n  }\n\n  static async fetch(client: SuiClient, id: string): Promise<MemCoinOwnerCap> {\n    const res = await client.getObject({\n      id,\n      options: {\n        showBcs: true,\n      },\n    });\n    if (res.error) {\n      throw new Error(`error fetching MemCoinOwnerCap object at id ${id}: ${res.error.code}`);\n    }\n    if (res.data?.bcs?.dataType !== \"moveObject\" || !isMemCoinOwnerCap(res.data.bcs.type)) {\n      throw new Error(`object at id ${id} is not a MemCoinOwnerCap object`);\n    }\n\n    return MemCoinOwnerCap.fromBcs(fromB64(res.data.bcs.bcsBytes));\n  }\n}\n\n/* ============================== State =============================== */\n\nexport function isState(type: string): boolean {\n  type = compressSuiType(type);\n  return type.startsWith(\"0xd06278ad71b5a4d622f179bd21d163d2efc8aaf14e1750884026f63e3d07ca3a::meme::State<\");\n}\n\nexport interface StateFields<T extends PhantomTypeArgument> {\n  id: ToField<UID>;\n  start: ToField<\"u64\">;\n  end: ToField<\"u64\">;\n  nextTick: ToField<\"u64\">;\n  allTickets: ToField<\"u64\">;\n  wonTickets: ToField<\"u64\">;\n  ticketPrice: ToField<\"u64\">;\n  tokensPerTicket: ToField<\"u64\">;\n  balance: ToField<Balance<T>>;\n}\n\nexport type StateReified<T extends PhantomTypeArgument> = Reified<State<T>, StateFields<T>>;\n\nexport class State<T extends PhantomTypeArgument> implements StructClass {\n  static readonly $typeName = \"0xd06278ad71b5a4d622f179bd21d163d2efc8aaf14e1750884026f63e3d07ca3a::meme::State\";\n  static readonly $numTypeParams = 1;\n\n  readonly $typeName = State.$typeName;\n\n  readonly $fullTypeName: `0xd06278ad71b5a4d622f179bd21d163d2efc8aaf14e1750884026f63e3d07ca3a::meme::State<${PhantomToTypeStr<T>}>`;\n\n  readonly $typeArgs: [PhantomToTypeStr<T>];\n\n  readonly id: ToField<UID>;\n  readonly start: ToField<\"u64\">;\n  readonly end: ToField<\"u64\">;\n  readonly nextTick: ToField<\"u64\">;\n  readonly allTickets: ToField<\"u64\">;\n  readonly wonTickets: ToField<\"u64\">;\n  readonly ticketPrice: ToField<\"u64\">;\n  readonly tokensPerTicket: ToField<\"u64\">;\n  readonly balance: ToField<Balance<T>>;\n\n  private constructor(typeArgs: [PhantomToTypeStr<T>], fields: StateFields<T>) {\n    this.$fullTypeName = composeSuiType(\n      State.$typeName,\n      ...typeArgs,\n    ) as `0xd06278ad71b5a4d622f179bd21d163d2efc8aaf14e1750884026f63e3d07ca3a::meme::State<${PhantomToTypeStr<T>}>`;\n    this.$typeArgs = typeArgs;\n\n    this.id = fields.id;\n    this.start = fields.start;\n    this.end = fields.end;\n    this.nextTick = fields.nextTick;\n    this.allTickets = fields.allTickets;\n    this.wonTickets = fields.wonTickets;\n    this.ticketPrice = fields.ticketPrice;\n    this.tokensPerTicket = fields.tokensPerTicket;\n    this.balance = fields.balance;\n  }\n\n  static reified<T extends PhantomReified<PhantomTypeArgument>>(T: T): StateReified<ToPhantomTypeArgument<T>> {\n    return {\n      typeName: State.$typeName,\n      fullTypeName: composeSuiType(\n        State.$typeName,\n        ...[extractType(T)],\n      ) as `0xd06278ad71b5a4d622f179bd21d163d2efc8aaf14e1750884026f63e3d07ca3a::meme::State<${PhantomToTypeStr<ToPhantomTypeArgument<T>>}>`,\n      typeArgs: [extractType(T)] as [PhantomToTypeStr<ToPhantomTypeArgument<T>>],\n      reifiedTypeArgs: [T],\n      fromFields: (fields: Record<string, any>) => State.fromFields(T, fields),\n      fromFieldsWithTypes: (item: FieldsWithTypes) => State.fromFieldsWithTypes(T, item),\n      fromBcs: (data: Uint8Array) => State.fromBcs(T, data),\n      bcs: State.bcs,\n      fromJSONField: (field: any) => State.fromJSONField(T, field),\n      fromJSON: (json: Record<string, any>) => State.fromJSON(T, json),\n      fromSuiParsedData: (content: SuiParsedData) => State.fromSuiParsedData(T, content),\n      fetch: async (client: SuiClient, id: string) => State.fetch(client, T, id),\n      new: (fields: StateFields<ToPhantomTypeArgument<T>>) => {\n        return new State([extractType(T)], fields);\n      },\n      kind: \"StructClassReified\",\n    };\n  }\n\n  static get r() {\n    return State.reified;\n  }\n\n  static phantom<T extends PhantomReified<PhantomTypeArgument>>(\n    T: T,\n  ): PhantomReified<ToTypeStr<State<ToPhantomTypeArgument<T>>>> {\n    return phantom(State.reified(T));\n  }\n\n  static get p() {\n    return State.phantom;\n  }\n\n  static get bcs() {\n    return bcs.struct(\"State\", {\n      id: UID.bcs,\n      start: bcs.u64(),\n      end: bcs.u64(),\n      next_tick: bcs.u64(),\n      all_tickets: bcs.u64(),\n      won_tickets: bcs.u64(),\n      ticket_price: bcs.u64(),\n      tokens_per_ticket: bcs.u64(),\n      balance: Balance.bcs,\n    });\n  }\n\n  static fromFields<T extends PhantomReified<PhantomTypeArgument>>(\n    typeArg: T,\n    fields: Record<string, any>,\n  ): State<ToPhantomTypeArgument<T>> {\n    return State.reified(typeArg).new({\n      id: decodeFromFields(UID.reified(), fields.id),\n      start: decodeFromFields(\"u64\", fields.start),\n      end: decodeFromFields(\"u64\", fields.end),\n      nextTick: decodeFromFields(\"u64\", fields.next_tick),\n      allTickets: decodeFromFields(\"u64\", fields.all_tickets),\n      wonTickets: decodeFromFields(\"u64\", fields.won_tickets),\n      ticketPrice: decodeFromFields(\"u64\", fields.ticket_price),\n      tokensPerTicket: decodeFromFields(\"u64\", fields.tokens_per_ticket),\n      balance: decodeFromFields(Balance.reified(typeArg), fields.balance),\n    });\n  }\n\n  static fromFieldsWithTypes<T extends PhantomReified<PhantomTypeArgument>>(\n    typeArg: T,\n    item: FieldsWithTypes,\n  ): State<ToPhantomTypeArgument<T>> {\n    if (!isState(item.type)) {\n      throw new Error(\"not a State type\");\n    }\n    assertFieldsWithTypesArgsMatch(item, [typeArg]);\n\n    return State.reified(typeArg).new({\n      id: decodeFromFieldsWithTypes(UID.reified(), item.fields.id),\n      start: decodeFromFieldsWithTypes(\"u64\", item.fields.start),\n      end: decodeFromFieldsWithTypes(\"u64\", item.fields.end),\n      nextTick: decodeFromFieldsWithTypes(\"u64\", item.fields.next_tick),\n      allTickets: decodeFromFieldsWithTypes(\"u64\", item.fields.all_tickets),\n      wonTickets: decodeFromFieldsWithTypes(\"u64\", item.fields.won_tickets),\n      ticketPrice: decodeFromFieldsWithTypes(\"u64\", item.fields.ticket_price),\n      tokensPerTicket: decodeFromFieldsWithTypes(\"u64\", item.fields.tokens_per_ticket),\n      balance: decodeFromFieldsWithTypes(Balance.reified(typeArg), item.fields.balance),\n    });\n  }\n\n  static fromBcs<T extends PhantomReified<PhantomTypeArgument>>(\n    typeArg: T,\n    data: Uint8Array,\n  ): State<ToPhantomTypeArgument<T>> {\n    return State.fromFields(typeArg, State.bcs.parse(data));\n  }\n\n  toJSONField() {\n    return {\n      id: this.id,\n      start: this.start.toString(),\n      end: this.end.toString(),\n      nextTick: this.nextTick.toString(),\n      allTickets: this.allTickets.toString(),\n      wonTickets: this.wonTickets.toString(),\n      ticketPrice: this.ticketPrice.toString(),\n      tokensPerTicket: this.tokensPerTicket.toString(),\n      balance: this.balance.toJSONField(),\n    };\n  }\n\n  toJSON() {\n    return {\n      $typeName: this.$typeName,\n      $typeArgs: this.$typeArgs,\n      ...this.toJSONField(),\n    };\n  }\n\n  static fromJSONField<T extends PhantomReified<PhantomTypeArgument>>(\n    typeArg: T,\n    field: any,\n  ): State<ToPhantomTypeArgument<T>> {\n    return State.reified(typeArg).new({\n      id: decodeFromJSONField(UID.reified(), field.id),\n      start: decodeFromJSONField(\"u64\", field.start),\n      end: decodeFromJSONField(\"u64\", field.end),\n      nextTick: decodeFromJSONField(\"u64\", field.nextTick),\n      allTickets: decodeFromJSONField(\"u64\", field.allTickets),\n      wonTickets: decodeFromJSONField(\"u64\", field.wonTickets),\n      ticketPrice: decodeFromJSONField(\"u64\", field.ticketPrice),\n      tokensPerTicket: decodeFromJSONField(\"u64\", field.tokensPerTicket),\n      balance: decodeFromJSONField(Balance.reified(typeArg), field.balance),\n    });\n  }\n\n  static fromJSON<T extends PhantomReified<PhantomTypeArgument>>(\n    typeArg: T,\n    json: Record<string, any>,\n  ): State<ToPhantomTypeArgument<T>> {\n    if (json.$typeName !== State.$typeName) {\n      throw new Error(\"not a WithTwoGenerics json object\");\n    }\n    assertReifiedTypeArgsMatch(composeSuiType(State.$typeName, extractType(typeArg)), json.$typeArgs, [typeArg]);\n\n    return State.fromJSONField(typeArg, json);\n  }\n\n  static fromSuiParsedData<T extends PhantomReified<PhantomTypeArgument>>(\n    typeArg: T,\n    content: SuiParsedData,\n  ): State<ToPhantomTypeArgument<T>> {\n    if (content.dataType !== \"moveObject\") {\n      throw new Error(\"not an object\");\n    }\n    if (!isState(content.type)) {\n      throw new Error(`object at ${(content.fields as any).id} is not a State object`);\n    }\n    return State.fromFieldsWithTypes(typeArg, content);\n  }\n\n  static async fetch<T extends PhantomReified<PhantomTypeArgument>>(\n    client: SuiClient,\n    typeArg: T,\n    id: string,\n  ): Promise<State<ToPhantomTypeArgument<T>>> {\n    const res = await client.getObject({\n      id,\n      options: {\n        showBcs: true,\n      },\n    });\n    if (res.error) {\n      throw new Error(`error fetching State object at id ${id}: ${res.error.code}`);\n    }\n    if (res.data?.bcs?.dataType !== \"moveObject\" || !isState(res.data.bcs.type)) {\n      throw new Error(`object at id ${id} is not a State object`);\n    }\n\n    return State.fromBcs(typeArg, fromB64(res.data.bcs.bcsBytes));\n  }\n}\n\n/* ============================== UserState =============================== */\n\nexport function isUserState(type: string): boolean {\n  type = compressSuiType(type);\n  return type === \"0xd06278ad71b5a4d622f179bd21d163d2efc8aaf14e1750884026f63e3d07ca3a::meme::UserState\";\n}\n\nexport interface UserStateFields {\n  id: ToField<UID>;\n  wonTickets: ToField<\"u64\">;\n  allTickets: ToField<\"u64\">;\n}\n\nexport type UserStateReified = Reified<UserState, UserStateFields>;\n\nexport class UserState implements StructClass {\n  static readonly $typeName = \"0xd06278ad71b5a4d622f179bd21d163d2efc8aaf14e1750884026f63e3d07ca3a::meme::UserState\";\n  static readonly $numTypeParams = 0;\n\n  readonly $typeName = UserState.$typeName;\n\n  readonly $fullTypeName: \"0xd06278ad71b5a4d622f179bd21d163d2efc8aaf14e1750884026f63e3d07ca3a::meme::UserState\";\n\n  readonly $typeArgs: [];\n\n  readonly id: ToField<UID>;\n  readonly wonTickets: ToField<\"u64\">;\n  readonly allTickets: ToField<\"u64\">;\n\n  private constructor(typeArgs: [], fields: UserStateFields) {\n    this.$fullTypeName = composeSuiType(\n      UserState.$typeName,\n      ...typeArgs,\n    ) as \"0xd06278ad71b5a4d622f179bd21d163d2efc8aaf14e1750884026f63e3d07ca3a::meme::UserState\";\n    this.$typeArgs = typeArgs;\n\n    this.id = fields.id;\n    this.wonTickets = fields.wonTickets;\n    this.allTickets = fields.allTickets;\n  }\n\n  static reified(): UserStateReified {\n    return {\n      typeName: UserState.$typeName,\n      fullTypeName: composeSuiType(\n        UserState.$typeName,\n        ...[],\n      ) as \"0xd06278ad71b5a4d622f179bd21d163d2efc8aaf14e1750884026f63e3d07ca3a::meme::UserState\",\n      typeArgs: [] as [],\n      reifiedTypeArgs: [],\n      fromFields: (fields: Record<string, any>) => UserState.fromFields(fields),\n      fromFieldsWithTypes: (item: FieldsWithTypes) => UserState.fromFieldsWithTypes(item),\n      fromBcs: (data: Uint8Array) => UserState.fromBcs(data),\n      bcs: UserState.bcs,\n      fromJSONField: (field: any) => UserState.fromJSONField(field),\n      fromJSON: (json: Record<string, any>) => UserState.fromJSON(json),\n      fromSuiParsedData: (content: SuiParsedData) => UserState.fromSuiParsedData(content),\n      fetch: async (client: SuiClient, id: string) => UserState.fetch(client, id),\n      new: (fields: UserStateFields) => {\n        return new UserState([], fields);\n      },\n      kind: \"StructClassReified\",\n    };\n  }\n\n  static get r() {\n    return UserState.reified();\n  }\n\n  static phantom(): PhantomReified<ToTypeStr<UserState>> {\n    return phantom(UserState.reified());\n  }\n\n  static get p() {\n    return UserState.phantom();\n  }\n\n  static get bcs() {\n    return bcs.struct(\"UserState\", {\n      id: UID.bcs,\n      won_tickets: bcs.u64(),\n      all_tickets: bcs.u64(),\n    });\n  }\n\n  static fromFields(fields: Record<string, any>): UserState {\n    return UserState.reified().new({\n      id: decodeFromFields(UID.reified(), fields.id),\n      wonTickets: decodeFromFields(\"u64\", fields.won_tickets),\n      allTickets: decodeFromFields(\"u64\", fields.all_tickets),\n    });\n  }\n\n  static fromFieldsWithTypes(item: FieldsWithTypes): UserState {\n    if (!isUserState(item.type)) {\n      throw new Error(\"not a UserState type\");\n    }\n\n    return UserState.reified().new({\n      id: decodeFromFieldsWithTypes(UID.reified(), item.fields.id),\n      wonTickets: decodeFromFieldsWithTypes(\"u64\", item.fields.won_tickets),\n      allTickets: decodeFromFieldsWithTypes(\"u64\", item.fields.all_tickets),\n    });\n  }\n\n  static fromBcs(data: Uint8Array): UserState {\n    return UserState.fromFields(UserState.bcs.parse(data));\n  }\n\n  toJSONField() {\n    return {\n      id: this.id,\n      wonTickets: this.wonTickets.toString(),\n      allTickets: this.allTickets.toString(),\n    };\n  }\n\n  toJSON() {\n    return {\n      $typeName: this.$typeName,\n      $typeArgs: this.$typeArgs,\n      ...this.toJSONField(),\n    };\n  }\n\n  static fromJSONField(field: any): UserState {\n    return UserState.reified().new({\n      id: decodeFromJSONField(UID.reified(), field.id),\n      wonTickets: decodeFromJSONField(\"u64\", field.wonTickets),\n      allTickets: decodeFromJSONField(\"u64\", field.allTickets),\n    });\n  }\n\n  static fromJSON(json: Record<string, any>): UserState {\n    if (json.$typeName !== UserState.$typeName) {\n      throw new Error(\"not a WithTwoGenerics json object\");\n    }\n\n    return UserState.fromJSONField(json);\n  }\n\n  static fromSuiParsedData(content: SuiParsedData): UserState {\n    if (content.dataType !== \"moveObject\") {\n      throw new Error(\"not an object\");\n    }\n    if (!isUserState(content.type)) {\n      throw new Error(`object at ${(content.fields as any).id} is not a UserState object`);\n    }\n    return UserState.fromFieldsWithTypes(content);\n  }\n\n  static async fetch(client: SuiClient, id: string): Promise<UserState> {\n    const res = await client.getObject({\n      id,\n      options: {\n        showBcs: true,\n      },\n    });\n    if (res.error) {\n      throw new Error(`error fetching UserState object at id ${id}: ${res.error.code}`);\n    }\n    if (res.data?.bcs?.dataType !== \"moveObject\" || !isUserState(res.data.bcs.type)) {\n      throw new Error(`object at id ${id} is not a UserState object`);\n    }\n\n    return UserState.fromBcs(fromB64(res.data.bcs.bcsBytes));\n  }\n}\n","import {\n  PhantomReified,\n  Reified,\n  StructClass,\n  ToField,\n  ToTypeStr,\n  decodeFromFields,\n  decodeFromFieldsWithTypes,\n  decodeFromJSONField,\n  phantom,\n} from \"../../_framework/reified\";\nimport { FieldsWithTypes, composeSuiType, compressSuiType } from \"../../_framework/util\";\nimport { bcs, fromB64 } from \"@mysten/bcs\";\nimport { SuiClient, SuiParsedData } from \"@mysten/sui.js/client\";\n\n/* ============================== SURF =============================== */\n\nexport function isSURF(type: string): boolean {\n  type = compressSuiType(type);\n  return type === \"0xd06278ad71b5a4d622f179bd21d163d2efc8aaf14e1750884026f63e3d07ca3a::surf::SURF\";\n}\n\nexport interface SURFFields {\n  dummyField: ToField<\"bool\">;\n}\n\nexport type SURFReified = Reified<SURF, SURFFields>;\n\nexport class SURF implements StructClass {\n  static readonly $typeName = \"0xd06278ad71b5a4d622f179bd21d163d2efc8aaf14e1750884026f63e3d07ca3a::surf::SURF\";\n  static readonly $numTypeParams = 0;\n\n  readonly $typeName = SURF.$typeName;\n\n  readonly $fullTypeName: \"0xd06278ad71b5a4d622f179bd21d163d2efc8aaf14e1750884026f63e3d07ca3a::surf::SURF\";\n\n  readonly $typeArgs: [];\n\n  readonly dummyField: ToField<\"bool\">;\n\n  private constructor(typeArgs: [], fields: SURFFields) {\n    this.$fullTypeName = composeSuiType(\n      SURF.$typeName,\n      ...typeArgs,\n    ) as \"0xd06278ad71b5a4d622f179bd21d163d2efc8aaf14e1750884026f63e3d07ca3a::surf::SURF\";\n    this.$typeArgs = typeArgs;\n\n    this.dummyField = fields.dummyField;\n  }\n\n  static reified(): SURFReified {\n    return {\n      typeName: SURF.$typeName,\n      fullTypeName: composeSuiType(\n        SURF.$typeName,\n        ...[],\n      ) as \"0xd06278ad71b5a4d622f179bd21d163d2efc8aaf14e1750884026f63e3d07ca3a::surf::SURF\",\n      typeArgs: [] as [],\n      reifiedTypeArgs: [],\n      fromFields: (fields: Record<string, any>) => SURF.fromFields(fields),\n      fromFieldsWithTypes: (item: FieldsWithTypes) => SURF.fromFieldsWithTypes(item),\n      fromBcs: (data: Uint8Array) => SURF.fromBcs(data),\n      bcs: SURF.bcs,\n      fromJSONField: (field: any) => SURF.fromJSONField(field),\n      fromJSON: (json: Record<string, any>) => SURF.fromJSON(json),\n      fromSuiParsedData: (content: SuiParsedData) => SURF.fromSuiParsedData(content),\n      fetch: async (client: SuiClient, id: string) => SURF.fetch(client, id),\n      new: (fields: SURFFields) => {\n        return new SURF([], fields);\n      },\n      kind: \"StructClassReified\",\n    };\n  }\n\n  static get r() {\n    return SURF.reified();\n  }\n\n  static phantom(): PhantomReified<ToTypeStr<SURF>> {\n    return phantom(SURF.reified());\n  }\n\n  static get p() {\n    return SURF.phantom();\n  }\n\n  static get bcs() {\n    return bcs.struct(\"SURF\", {\n      dummy_field: bcs.bool(),\n    });\n  }\n\n  static fromFields(fields: Record<string, any>): SURF {\n    return SURF.reified().new({ dummyField: decodeFromFields(\"bool\", fields.dummy_field) });\n  }\n\n  static fromFieldsWithTypes(item: FieldsWithTypes): SURF {\n    if (!isSURF(item.type)) {\n      throw new Error(\"not a SURF type\");\n    }\n\n    return SURF.reified().new({ dummyField: decodeFromFieldsWithTypes(\"bool\", item.fields.dummy_field) });\n  }\n\n  static fromBcs(data: Uint8Array): SURF {\n    return SURF.fromFields(SURF.bcs.parse(data));\n  }\n\n  toJSONField() {\n    return {\n      dummyField: this.dummyField,\n    };\n  }\n\n  toJSON() {\n    return {\n      $typeName: this.$typeName,\n      $typeArgs: this.$typeArgs,\n      ...this.toJSONField(),\n    };\n  }\n\n  static fromJSONField(field: any): SURF {\n    return SURF.reified().new({ dummyField: decodeFromJSONField(\"bool\", field.dummyField) });\n  }\n\n  static fromJSON(json: Record<string, any>): SURF {\n    if (json.$typeName !== SURF.$typeName) {\n      throw new Error(\"not a WithTwoGenerics json object\");\n    }\n\n    return SURF.fromJSONField(json);\n  }\n\n  static fromSuiParsedData(content: SuiParsedData): SURF {\n    if (content.dataType !== \"moveObject\") {\n      throw new Error(\"not an object\");\n    }\n    if (!isSURF(content.type)) {\n      throw new Error(`object at ${(content.fields as any).id} is not a SURF object`);\n    }\n    return SURF.fromFieldsWithTypes(content);\n  }\n\n  static async fetch(client: SuiClient, id: string): Promise<SURF> {\n    const res = await client.getObject({\n      id,\n      options: {\n        showBcs: true,\n      },\n    });\n    if (res.error) {\n      throw new Error(`error fetching SURF object at id ${id}: ${res.error.code}`);\n    }\n    if (res.data?.bcs?.dataType !== \"moveObject\" || !isSURF(res.data.bcs.type)) {\n      throw new Error(`object at id ${id} is not a SURF object`);\n    }\n\n    return SURF.fromBcs(fromB64(res.data.bcs.bcsBytes));\n  }\n}\n","export const CHAIN = \"sui:mainnet\";\nexport const GAME_ADDRESS = \"0xefbee845f696399fb22e23bb54694b45bf0f2e11e8165cf99c830c8d862f56df\";\nexport const PROGRAM_ADDRESS = \"0xe2d76c57bb1cf8b511f6f4bbbab7d575ab221d2c84b3ccb5eee2ef999c7dc61f\";\nexport const CLOCK_ADDRESS = \"0x0000000000000000000000000000000000000000000000000000000000000006\";\nexport const TICKET_SUPPLY = BigInt(40_000);\nexport const TICKET_REWARD = BigInt(17_500_000_000_000);\nexport const SALE_SUPPLY = TICKET_REWARD * TICKET_SUPPLY;\nexport const SURF_DECIMALS = BigInt(6);\n","export const GAME_ADDRESS = \"0xa8cf842832915a2dd203f8604a78a12a686fdba987d19065092fe92b09029619\";\nexport const PROGRAM_ADDRESS = \"0xae40d60ccae9366903e142ad222b91953e699221c51b9a2647d69cfe8ef2ff39\";\nexport const CLOCK_ADDRESS = \"0x0000000000000000000000000000000000000000000000000000000000000006\";\nexport const TICKET_SUPPLY = BigInt(40_000);\nexport const TICKET_REWARD = BigInt(17_500_000_000_000);\nexport const SALE_SUPPLY = TICKET_REWARD * TICKET_SUPPLY;\nexport const SURF_DECIMALS = BigInt(6);\n"],"mappings":"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","names":["getCoinsMap","getPathMapAndCoinTypesSet","getPathsMap","isApiResponseValid","import_utils","userEvents","ptr","obj","module","obj","module","import_utils","BigNumber","import_bignumber","BigNumber","import_bignumber","import_ed25519","import_utils","import_transactions","import_utils","import_bignumber","import_bech32","BigNumber","coinObjects","UpdatedTransactionBlock","obj","d","import_transactions","import_bignumber","BigNumber","feeAmount","amount","providersByOutputAmountsMap","routesByProviderMap","BigNumber","feeAmount","import_client","import_transactions","import_utils","obj","import_bignumber","userEvents","obj","BigNumber","DCATimescale","import_client","import_transactions","obj","import_bignumber","userObjects","import_bcs","import_utils","BigNumber","import_bignumber","BigNumber","import_client","import_bignumber","BigNumber","import_transactions","import_transactions","import_bignumber","StorageProperty","import_bignumber","BigNumber","import_bignumber","BigNumber","pool","BigNumber","import_cetus_sui_clmm_sdk","import_utils","import_bignumber","import_bn","isApiResponseValid","obj","import_transactions","BN","price","Decimal","CetusClmmSDK","isApiResponseValid","BigNumber","BN","userEvents","pool","import_ts_sdk","import_transactions","import_bignumber","BNumber","BigNumber","isCoinMetadataValid","import_transactions","import_ts_sdk","import_transactions","DCA_ROUTER","InputIndex","swapPatterns","buildDcaTxBlock","inputIdx","buildDcaTxBlock","import_client","import_bignumber","import_turbos_clmm_sdk","import_transactions","import_utils","typeArguments","import_transactions","DCA_ROUTER","InputIndex","swapPatterns","buildDcaTxBlock","inputIdx","import_bignumber","getPathsMap","getCoinsMap","BigNumber","buildDcaTxBlock","getPathsMap","getCoinsMap","BigNumber","import_client","import_transactions","import_bignumber","coinObjects","isApiResponseValid","import_bignumber","getPathMapAndCoinTypesSet","bestRoute","BigNumber","isApiResponseValid","getPathMapAndCoinTypesSet","pool","BigNumber","UpdatedTransactionBlock","import_utils","import_transactions","import_ed25519","import_client","import_transactions","import_utils","import_bignumber","import_bcs","isTransactionArgument","obj","isTransactionArgument","obj","import_bcs","field","Address","import_bcs","import_bcs","import_bcs","import_bcs","BigNumber","CLOCK_ADDRESS","GAME_ADDRESS","PROGRAM_ADDRESS","SALE_SUPPLY","SURF_DECIMALS","TICKET_REWARD","TICKET_SUPPLY"]}